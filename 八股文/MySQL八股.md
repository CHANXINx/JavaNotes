## 1. SQL和NOSQL的区别?
>?

前者是关系型数据库，常见的有MySQL、Oracle、SQL Server等。关系型数据库存储结构化数据，逻辑上以二维列表存在，每一行代表一个数据记录，每一列代表一个数据属性。

后者是非关系型数据库，常见的有Redis、MongoDB等，存储方式可以是JSON文档、哈希表等方式。

## 2. 数据库三大范式是什么?
>
1. 数据库表每一列都不可再分，具有原子性，例如地址，可以拆分为省份、市区等。
2. 数据库表中的每个实例或记录都可被唯一区分，即需要有主键。
3. 任何非主属性不依赖于其他非主属性，即非主键外字段必须互不依赖。

反范式：例如冗余字段，虽然违反了第三范式，使得非主键外的其他字段形成了相互依赖，但是这样避免了联表查询，用空间换时间，提高了查询效率。


## 3. Char和Varchar的区别?
> [!abstract]- 摘要
> aaa

### char类型:
char是固定长度的字符串类型，定义时指定长度，存储时会在末尾补空格来填充至指定长度。
###### **优点：** 
1. 适合存储固定长度的数据，例如身份证等。
2. 无需额外的磁盘空间来存储长度信息；
3. **不会产生内存碎片**
###### **缺点：**
1. char类型会导致末尾空格数据丢失，如`"chanxin   "`会被填充至`"chanxin        "`，导致无法获取原本有几个空格。
### varchar类型
varchar是可变长度的字符串类型，定义时需要指定最大长度。存储占用空间取决于字符串实际长度。
###### **优点：**
1. 节约存储空间；
###### **缺点：**
1. **会产生内存碎片。**
	- varchar(100)，假设存储的数据为51字节（包括50字节的字符串与1字节的长度信息），那么当该数据更新了，导致占用内存增加了，但是此时数据页无法扩展出新空间所以无法覆盖到原来位置，就会发生页分裂。
2. 需要额外1~2个字节(超过255字节则需要2个字节)来存储数据长度信息。

## 4. 说一下外键约束。

外键是用于建立表之间关系的，定义了表中的某一列或某几个列，这些列的值必须在另一个表中作为主键出现。作用是维护表中的数据一致性和完整性。

## 5. 为什么不推荐使用外键?
1. **性能问题**：每次执行DML语句都需要额外检测外键约束的完整性，降低了更新性能；
2. **锁竞争问题**：多个事务同时插入或更新时，为了确保一致性，需要获取额外的锁，导致锁竞争甚至死锁问题，降低并发性能。
3. **无法适应分库分表**：分库分表会安静中，数据存在于不同的数据库中，外键难以跨越数据库来建立关系。并且，分库分表环境中，数据的一致性更难维护。

## 6. 执行一条SQL请求的过程是什么?
1. 使用**连接器**，通过客户端/服务器通信协议与MySQL建立连接，并查询判断是否有权限；
2. 在MySQL8.0之前，还会查询是否开启缓存，若开启且命中缓存，则直接返回查询结果；
3. 由**解析器**进行词法与语法分析，并生成解析树。**预处理器**会根据MySQL规则进一步分析解析树是否合法，如表或列是否存在。
4. 由**优化器**来生成执行计划，并根据索引看看是否能优化，选择查询成本最小的计划。
	- 执行EXPLAIN语句获取的就是执行计划。
5. **执行器**来操作存储引擎执行SQL语句，获得查询结果并返回。同时，若开启缓存，在返回前还会将结果存储于缓存中。

## 7. 介绍MySQL的三种存储引擎
|          |  InnoDB   | MyISAM |
| :------: | :-------: | :----: |
|  **事务**  |    支持     |  不支持   |
|  **外键**  |    支持     |  不支持   |
| **聚簇索引** |    支持     |  不支持   |
| **锁级别**  | 支持行级锁、表级锁 |  表级锁   |
| **行数保存** |    不支持    |   支持   |
| **清空方式** |   逐行删除    |  重建表   |
| **默认版本** |  5.5 之后   | 5.5 之前 |
| **全文索引** |  5.6以后支持  |   支持   |
InnoDB适合频繁修改以及需要更高安全性的应用；MyISAM则适合查询较多的场景。

## ---
## 8. 索引是什么? 有什么好处?
索引是一种数据结构，可以减少查询时扫描的数据量，提高查询速度。

## 9. MySQL的索引是怎么实现的?
InnoDB引擎采用了B+树作为了索引的数据结构。B+树是一种多叉树，非叶结点只存储索引，叶子节点存储数据和用于链接节点的前后指针。
由于非叶结点只存储索引，所以相对B树和二叉树，树的高度更低，因此磁盘I/O次数更少，查询效率更更高。

>`千万数据只需要3-4层高度即可满足。`
>1个内存页16KB，假设一个索引键值16字节，那么一个结点（内存页）占用$1024\times16/16=1024$个键值。

## 10. 聚簇索引和非聚簇索引的区别是什么?

0. 聚簇索引也叫主键索引，非聚簇索引也叫二级索引。
1. **数据存储**：聚簇索引的叶子结点包含了索引主键和对应的整行数据；而非聚簇索引的叶子结点不包含完整数据，只包含对应指向该行数据的主键值。
2. **索引和数据的关系**：进行查询时，通过聚簇索引可以直接获取完整数据；而通过非聚簇索引查询，若查询了索引字段之外的字段，还需要回表查询。
3. **唯一性**：聚簇索引通常是基于主键构建的，因此每一个表只能有一个聚簇索引；而非聚簇索引，一个表可以有多个。

若表中不包含主键，那么首先会使用**①不为空的unique唯一索引**来作为聚簇索引。若也不存在，则会选择**②隐藏主键rowid**作为聚簇索引。
[[#rowid是什么?]]

### rowid是什么?
rowid 是一个特殊的隐藏自增列，**它为表中的每一行分配一个唯一的标识符**。这个标识符是内部生成的，通常用于快速定位和访问表中的具体行，提供了一个快速访问行的机制。

## 11. 什么字段适合作为主键?
1. 主键字段具有唯一性，且不能为空。
2. 最好具有递增趋势，这样能减少页分裂和内存碎片。
3. 不建议使用业务数据作为主键，因为无法预测业务字段未来是否会重用；
4. 通常采用自增id作为主键，但仅限于单机系统。对于分布式系统，需要采用分布式id方案。

## 12. 采用UUID和自增id作为主键，哪个好?/自增id作为主键的优点.
### UUID:
UUID 是一个 128 位长的唯一标识符，通常以字符串形式表示。
**优点：**
1. **全局唯一**：采用不同算法生成，几乎可以保证全球范围内唯一，避免了多台机器之间的主键冲突问题，因此也适用于分布式系统。
2. **不可预测性**：随机生成，很难被猜测出来，安全性较高。

**缺点：**
1. **占用空间大**：通常以字符串形式存储，占用空间比较大；
2. **不适合范围查询**：UUID不是自增的，所以不支持范围查询。范围查询通常是依赖于主键的顺序性来快速定位数据，如果主键非自增，通常需要扫描更多的数据来确认数据是否在指定范围内。
3. **效率低**：
	1. **查询效率低**：UUID作为主键创建索引时，因为UUID占用16个字节，相比于主键id，会占用更多的内存空间，导致内存页所能包含的数据更少，因此增加了磁盘I/O的需求，导致查询效率低。
	2. **写入效率低**：由于UUID是随机生成的，不具有自增性。因此新的UUID可能会插入到叶子结点的中间位置，导致索引页分裂和更多的I/O操作，影响了写入性能。（同时，数据分布在不同的内存页，也影响了查询性能。）

### 自增ID:
**优点：**
1. **占用空间小**：自增ID是数字，占用内存远小于UUID，节省存储空间；
2. **顺序插入，减少页分裂**：ID是递增的，新记录一般插入在索引页的末尾，避免了随机写入带来的页分裂和性能开销；
3. **查询效率高**：ID自增，索引中的数据存储顺序和值一致。
	- 因此。进行范围查询时可以更快定位范围的起始点，提高查询效率；
	- 在物理存储上记录也较为连续，减少IO
4. **分页方便**：id连续自增，通过 `id > ? LIMIT ?` 的方式分页可以解决深度分页问题；
5. **索引效率**：保证索引顺序和插入顺序相同，减少了索引重排，提高了插入速度。

**缺点：**
1. **分库分表**：分库分表时，没办法依赖于单表的自增主键来做主键id，因为可能会发生重复；
2. **可预测**：ID是顺序自增的，所以是可预测的；
	- 例如竞对利用自增id获取订单量。
3. **可能用尽**：自增id的数据类型是int(4字节)或者bigint(8字节)，可能会存在用完的情况。

## 13. MySQL主键一定是自增的吗?
不一定。只是一般采用自增id作为主键，这样有几个好处：
1. 自增id是顺序插入的，可以减少插入删除时的页分裂、页合并等问题，提高写入性能；
2. 由于是顺序插入的，所以物理存储上也是连续的，因此范围查询时效率更高；
3. 是顺序插入，


---
## 14. 联合索引的实现原理
多个字段一起构造一个索引。
联合索引的key值是字段的值，先按首个字段排序，若首字段相等，再按照第二个字段排序。

联合索引遵循最左匹配原则。例如(a,b,c)构建联合索引，则使用索引时必须带a，并且与顺序无关，a可以在后面，因为优化器在构建执行计划时会进行优化。

## 15. 索引失效有哪些?
1. 模糊查询，如`like %xx`或者`like %xx%`；
2. 使用函数；
3. 表达式计算；
4. 字符串类型未带''，导致发生了类型转换；
5. 不遵循最左匹配原则，导致联合索引失效；
6. **WHERE语句中，如果OR前是索引列，而OR后的条件不是索引列，那么条件会失效。**

## 16. 什么是覆盖索引?
覆盖索引是指在使用非主键索引进行查找时，由于叶子结点中包含所以需要查询的字段，因此不需要回表查询，减少访问内存页次数，提高查询性能。

## 17. 什么是前缀索引?
使用前缀索引是取字段的前n个字符作为索引，减少索引字段大小，以增加一个内存页中所能存储的索引数量，提高查询性能。例如存储用户的邮箱，就可以只选择前n个长度的字符作为索引，最终长度可以通过计算区分度来决定
```MySQL
SELECT COUNT(DISTINCT LEFT(email, 4)) AS L4,
       COUNT(DISTINCT LEFT(email, 5)) AS L5,
       COUNT(DISTINCT LEFT(email, 6)) AS L6,
       COUNT(DISTINCT LEFT(email, 7)) AS L7
FROM users;
```

## 18. 什么是索引下推(Index Condition Pushdown)?
people表中（zipcode，lastname，firstname）构成一个索引，执行查询语句：
`SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;`
- 若没有索引下推优化机制，首先会通过索引获取`zipcode='95054'`查找到相应记录，并通过主键回表判断后两个条件是否符合条件；
- MySQL5.6引入索引下推优化后，MySQL会在查询号zipcode='95054'记录后，立刻检查WHERE条件是否可以通过索引中的列进行判断，只有当全部条件满足，才会使用主键定位并回表查询获取完整行记录。

总结，索引下推就是通过**将部分条件判断从执行层下推到存储引擎层进行处理**，有效减少回表次数，提高查询性能。
![[Pasted image 20241119223926.png|400]]

## 19. 什么是索引跳跃扫描(Index Skip Scan)?
MySQL8.0.13引入的新特性，对于range查询，支持不符合连锁索引最左前缀匹配的SQL依然能够使用联合索引，减少不必要的扫描，提高查询效率。

**优化原理：**
构建联合索引(f1,f2)，执行查询语句：`SELECT f1, f2 FROM t1 WHERE f2 = 40;`
通过获取f1字段的所有唯一值，然后进行范围查询，最后合并所有查询结果。
```SQL
SELECT f1, f2 FROM t1 WHERE f1 =1 and f2 = 40
UNION
SELECT f1, f2 FROM t1 WHERE f1 =2 and f2 = 40;
```

但是，当f1字段的区分度比较高时，需要扫描的行数还是会很多，此时查询还是会很慢。因此是否走索引下推，由优化器预估成本后决定。

## 20. MySQL为什么会选错索引?
## ---
---

## 21. MySQL可能出现什么并发安全问题?
### 脏读:
一个事务读取到了另一个事务未提交的变更。

### 不可重复读:
在一个事务内多次读取同一个事务，出现数据前后不一致的情况。

### 幻读:
在一个事务内多次查询某个符合查询条件的记录数量，出现前后查询的数量不一致。

## 22. 事务的隔离级别有哪些?都是如何实现的?

1. **读未提交**：可以读取到其他事务还未提交的变更。
	- 读取最新版本的数据。
2. **读已提交**：可以读取到其他事务已提交的变更。
	- 通过创建Read View实现，在每个语句执行前都会生成一个Read View。
3. **可重复读**：事务内前后查询的数据保持一致，与事务启动时看到的数据一致。
	- 通过创建Read View实现，在事务开始时就创建Read View。
4. **串行化**：事务是串行进行，当某个数据被多个事务读写时，后面请求的事务会处于阻塞等待状态。
	- 通过对数据加读写锁实现。

## 23. 可重复读隔离级别下，A提交的事务，B可以看见吗?
看不见。RR级别下，事务启动时会创建一致性视图，即使事务更新了数据并提交，事务B也可以通过undo log进行回滚，读取创建一致性事务时的数据。

## 24. ==解释下RR级别下的幻读问题。==
RR级别下，通过MVCC和间隙锁避免了大部分的幻读问题，但还是会有小部分幻读问题的发生。

**举例：**
1. RR级别下，事务A开启事务，执行查询语句开启快照读；此时事务B新插入记录并提交；事务A再对新插入的数据进行更新，此时更新成功，说明发生了幻读。
2. RR级别下，事务A开启事务，执行查询语句开启快照读；此时事务B新插入记录并提交；事务A再对新插入的数据进行更新，此时更新成功，说明发生了幻读。

要想彻底解决幻读，只能使用并行化隔离级别。

## 25. 介绍MVCC实现原理
MVCC，多版本并发控制，允许多个事务读取同一行数据而不会彼此阻塞，并且每个事务看到的数据版本是该事务开始时的数据版本。

读提交隔离级别，是在「每个select语句执行前」都会重新生成一个 Read View；
RR隔离级别，在事务开始时会创建一个ReadView，然后整个事务期间都会用这个ReadView。

## 26. 介绍下ReadView
ReadView主要用于解决可见性问题，帮助事务确定该看到哪个快照，不该看到哪个快照。
RR级别下，

---
## 27. 介绍一下MySQL的锁
![[Pasted image 20241119215143.png]]
## 28. 什么是排他锁和共享锁?
### 共享锁:
- 共享锁又称读锁、S锁，是读取操作创建的锁。其他用户可以并发读取数据，**但任何事务都不能对数据进行修改**（获取数据上的排他锁），直到已释放所有共享锁。
- 如果事务T对事务A加了共享锁，其他事务只能对A再加共享锁，不能加排他锁。

### 排他锁:
- 排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。获得排他锁的事务既能读数据，又能修改数据。

## 29. 什么是意向锁?
若事务A对某行记录加了行锁，而事务B申请整张表加表锁，那么就需要判断表中是否有行锁，若通过全表扫描来检测，那么效率很低，因此引入意向锁来快速判断。

所以，**意向锁是数据库管理系统中用于实现锁协议的一种锁机制，是用于处理不同锁粒度之间（主要是表锁与行锁） 的并发性问题。**
	行锁与行锁之间的并发问题通过行级互斥锁实现。

意向锁共有两种：1)意向共享锁；2)意向排他锁。共享+共享√，共享+排他×，排他+排他×.

## 30. binlog, redolog和undolog的区别?
### binlog:
binlog主要用于对数据库进行**数据备份、主从复制和崩溃恢复**等操作。binlog是MySQL用于记录所有**DDL语句和DML语句**的一种二进制文件。

### redolog:
redolog是MySQL用于**实现崩溃恢复和数据持久性**的一种机制。在事务进行过程中，MySQL会**将事务做了什么改动**记录到Redo Log中。当系统崩溃或者发生异常情况时，MySQL会利用Redo Log中的记录信息来进行恢复操作，将事务所做的修改持久化到磁盘中。

### undolog:
Undo Log则用于在**事务回滚或系统崩溃时撤销（回滚）事务所做的修改**。当一个事务执行过程中，MySQL会将**事务修改前的数据**记录到Undo Log中。如果事务需要回滚，则会从Undo Log中找到相应的记录来**撤销事务所做的修改**。

## 31. ==什么是事务的两阶段提交?==
![[Pasted image 20241120013145.png|450]]
将事务的更新分为Prepare准备阶段和Commit提交阶段。
- **准备阶段**：MySQL将事务的更新操作记录到redo log中，并将其标记为Prepare状态；紧接着，MySQL将更新操作写入binlog。
- **提交阶段**：MySQL将binlog记录标记为commit提交状态，并确保事务的修改持久化到数据库中。
两阶段提交确保了binlog和redolog的数据一致性，从而保证数据库在崩溃恢复等场景下的可靠性和稳定性。

假设第一阶段提交已完成，binlog已写入，但是第二阶段还未完成，redolog仍未被标记为commit状态，此时数据库宕机崩溃，那么重启后，事务会回滚还是提交？

判断回滚还是提交的基本原则：**保证binlog与redolog的一致性，保证binlog能完全恢复数据。**
- 因为binlog已落盘，所以此时会根据redolog中的记录将数据恢复，并提交事务。
	- 若此时将事务回滚，那么binlog中就会多出一条记录(已写入的binlog不能被修改！)，导致数据不一致。
## --- 
## 32. 一条update语句是如何执行的?

## 33. SQL语句如何实现insertOrUpdate功能?
使用`INSERT INTO ... ON DUPLICATE KEY UPDATE;`，如果数据库中已存在具有相同主键或唯一索引的记录，则更新记录，否则插入记录。

**需要满足以下条件：**
1. 表必须有主键或唯一索引；
2. 插入的数据必须包含主键或唯一索引列；
3. 主键或唯一索引列的值不能为 NULL。

**举例：**
```SQL
INSERT INTO student (id, name, age) VALUES (1, 'Alice', 20)
ON DUPLICATE KEY UPDATE name='Alice', age=20;
```

**实现原理：**
1. 首先尝试插入新行，在插入过程中会检查表中是否存在与新插入的数据相同的主键或者唯一索引；
2. 若无，则直接插入新记录；若存在冲突，则执行更新操作；
3. 根据`ON DUPLIACATE KEY`后面的字段与对应值执行更新操作。

---
## ---
## 34. ~~分布式id方案^<sup>美团leaf分布式id</sup>~~


