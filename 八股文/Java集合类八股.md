## 1. Hash冲突的解决方式有什么？
### 链地址法：
将同一个hash值的元素连接成一个链表。

优点：
1. 处理冲突简单；
2. 适合经常插入和删除的情况；
3. 适合没有预定空间的情况。

缺点：
1. 冲突较多时，链表过长使得查询复杂度变高。

### 开放定址法:
当发生Hash冲突时，继续探索其他空位，直到找到空槽位。实现方式有1）线性探测；2）二次探测；3）双重散列

开放定址法的优点是：  
- 空间效率：由于不需要额外的数据结构（如链表），开放寻址法通常比链地址法**使用更少的内存**
- 缓存友好性：由于数据存储在连续的内存空间，所以在**寻址时可能有更好的缓存性能**。

开放寻址法也有缺点：  
- 当负载因子（即表中已占用的槽位比例）较高时，**查找空槽位的时间可能会显著增加**。  
- **删除操作相对复杂**，因为简单地将槽位置为空可能会打断探测序列。

**线性探测**：
- 发生冲突时，顺序检查表中的下一个槽位，直到找到空位。
- 线性探测的问题在于“聚集”：一旦发生多次连续冲突，就会形成一长串被占用的槽位，这会影响后续插入和查找的效率。

**二次探测：**
- 与线性探测相同的是都是顺序检查，但是二次探测是依次检查后1、4、9个槽位。
- 可以减少聚集问题，但仍可能发生较小范围的聚集。

**双重散列：**
- 使用与初始定位不同的哈希函数来确定下一个探测位置。
	- 例如`hash2(key) = 3 - key % 3`，在插入key=15发生冲突，第一个探测的位置为1，则下一个探测的位置为 $1+(3- 15 \% 3)=4$
	  ![[Pasted image 20241120223713.png]]
- 减少了聚集，并能更好地分散键的分布。

### 再哈希法：
发生冲突时，使用不同的哈希函数计算哈希值，并在该哈希值对应槽位为空时直接存储。
- 双重散列是在第一个冲突槽位的基础上加上第二个哈希值来获得下一个检测槽位，而再哈希是直接的第二个槽位就是第二个哈希值。

## 2. HashMap的数据结构是怎样的？
JDK1.7以前，是通过数组+链表的数据结构进行存储的。数组中的每一个元素都被称为一个桶(bucket)，桶中存放链表的头结点(Entry)。
![[Pasted image 20241120225226.png]]
JDK1.8以后，是红黑树结构。
## 3. HashMap、Hashtable和ConcurrentHashMap的区别？

## 4. HashMap在get和put时经过哪些步骤？
## 5. 为什么HashMap的默认负载因子设置成0.75？

## 6. HashMap的初始容量设置成多少合适？
## 7. HashMap是如何扩容的？

## 8. 为什么JDK8中HashMap的数据结构要转成红黑树？

## 9. HashMap的hash方法是如何实现的？


## 10. Set是如何保证元素不重复的