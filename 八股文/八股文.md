# Java基础:
## 1. JDK6与JDK7中的substring原理与区别:
**substring的作用:**
`substring(int beginIndex, int endIndex)`:截取并返回`[beginIndex,endIndex-1]`范围的字符串子串.

### JDK6中的substring:
jkd6中,String类内部存在三个成员变量:
`char value[]`:存储真正的字符数组;
`int offset`:数组的第一个位置索引
`int count`:字符串中包含的字符个数.

jdk6中,当调用substring方法的时候，会**创建一个新的string对象**，但是这个string的值仍然指向堆中的**同一个字符数组**。这两个对象中**只有count和offset 的值是不同的**:
![[Pasted image 20241016153919.png|450]]
`this.value = value`,引用的还是原来的字符数组.
```java
//JDK 6
String(int offset, int count, char value[]) {
    this.value = value; //相同的字符数组.
    this.offset = offset;
    this.count = count;
}

public String substring(int beginIndex, int endIndex) {
    //check boundary
    return  new String(offset + beginIndex, endIndex - beginIndex, value);
}
```

#### **存在的问题:**
如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。**这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串**（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。

```java
x = x.substring(x, y) + ""
```

### JDK7中的substring:
在jdk 7 中，substring方法会在**堆内存中创建一个新的数组**。
![[Pasted image 20241016154303.png]]
使用`this.value = Arrays.copyOfRange(value, offset, offset + count); `创建新数组.
```java
//JDK 7
public String(char value[], int offset, int count) {
    //check boundary
    // 与jdk6中不同,创建了一个新的字符数组!
    this.value = Arrays.copyOfRange(value, offset, offset + count); 
    
}

public String substring(int beginIndex, int endIndex) {
    //check boundary
    int subLen = endIndex - beginIndex;
    return new String(value, beginIndex, subLen);
}
```

# 集合类:

# Spring:

## 1. 介绍一下Spring的IOC:
IOC,全称Inverse Of Control,控制反转.
传统的程序设计中,应用程序代码通常控制对象的创建和管理.例如,当一个对象需要依赖其他对象时,程序通过new等方式创建对象.而在IOC中,控制关系反转,**控制权交由Spring容器管理,容器负责创建和管理对象**!并在有需要时**注入**程序中.

**优点:**
1. 使用者无需关心引用bean的全部细节.
2. 不用创建多个相同的bean导致浪费.
3. Bean的修改使用方无需感知.

## 2. 介绍一下Spring的AOP:
AOP,全称Aspect-Oriented Programming,面向切面编程,即把公用的逻辑抽出,让开发者能更专注于业务!
面向切面编程是面向对象编程思想的补充. AOP面向不同切面,并且**一个切面可以横跨多个类和对象操作**,极大地丰富了开发者的使用方式,提高了开发效率.

# MySQL:

# [[Redis八股]]


# 计算机网络

## 1. JWT令牌详解:
### 出现背景:
互联网服务离不开用户认证。一般流程是下面这样:
> 1、用户向服务器发送用户名和密码。
> 2、服务器验证通过后，在**当前对话（session）里面保存相关数据**，比如用户角色、登录时间等等。
> 3、服务器向用户返回一个session_id，**写入用户的Cookie。**
> 4、用户随后的每一次请求,都会**通过 Cookie将session_id 传回服务器**。
> 5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

### JWT令牌原理:
JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户.

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器**完全只靠这个对象认定用户身份**。为了防止用户篡改数据，服务器在生成这个对象的时候，会**加上签名**（详见后文）。

**服务器就不保存任何 session 数据了，也就是说，服务器变成==无状态==了，从而比较容易实现扩展。**

### JWT的数据结构:
JWT由三个部分组成:`头部(Header).负载(Payload).签名(Signature)`,三者之间通过`.`隔开.
#### Header:
Header 部分是一个JSON对象，描述JWT的元数据,样例如下:
```JavaScript
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`表示签名算法,默认为`HMAC SHA256`(写成HS256);
- `typ`表示token类型,JWT令牌统一写成JWT.

#### Payload:
Payload部分也是一个JSON对象，用来存放实际需要传递的数据.JWT规定了7个官方字段:
- iss (issuer)：签发人
- **exp (expiration time)：过期时间**
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号
除了官方字段，你还可以在这个部分**定义私有字段**，下面就是一个例子:
```JavaScript
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
**JWT 默认是不加密**的，任何人都可以读到，所以不要把秘密信息放在这个部分。

#### Signature:
Signature部分是对前两部分的签名,防止数据篡改.

首先，需要**指定一个密钥（secret）**。这个**密钥只有服务器才知道，不能泄露给用户**。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。
>即`签名=HS257(Header.Payload,secret)`
```JavaScript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
计算出签名后,**将Header,Payload与Signature之间用`.`进行拼接**就得到了Token,就可以返回给用户了.
即对Header和Payload使用Base64URL算法生成JSON字符串,然后加上密钥,三者使用`.`进行拼接,获得最终的token.

### JWT的使用方式:
客户端收到服务器返回的 JWT，**可以储存在 Cookie 里面，也可以储存在 localStorage。**

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript 
> Authorization: Bearer <token>
 ```

另一种做法是,跨域的时候,JWT就放在POST请求的数据体里面。

### JWT的几个特点:
1. JWT**默认是不加密**，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次.
2. JWT不加密的情况下，不能将秘密数据写入JWT。
3. JWT不仅可以用于认证，也可以**用于交换信息**。有效使用JWT，可以**降低服务器查询数据库的次数。**
4. JWT的最大缺点是，由于服务器不保存 session 状态，因此**无法在使用过程中废止某个 token**，或者更改token的权限。也就是说，一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
5. JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，**JWT的有效期应该设置得比较短**。对于一些比较重要的权限，使用时应该再次对用户进行认证。
6. 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。

![[Pasted image 20241011012123.png]]

## 2. WebSocket详解
### 出现背景:
根本原因在于HTTP协议的缺点,通信只能由客户端发起. 例如,如果想了解当天的天气,只能是由客户端想服务端发起查询请求,服务端返回查询结果. 而无法做到服务端向客户端主动推送消息.

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用**轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息**。最典型的场景就是聊天室。

轮询的效率很低,并且浪费资源,因为客户端和服务端必须不停连接,或者HTTP连接始终打开.

### 简介:
WebSocket的最大特点就是，**服务器可以主动向客户端推送信息,客户端也可以主动向服务器发送信息**，是真正的双向通信，属于服务器推送技术的一种。

WebSocket的其他特点:
1. 建立**在 TCP 协议**之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL.

### WebSocket出现之前的即时通讯方式:
1. **定期轮询:**
	- **客户端按照某个时间间隔不断地向服务端发送请求**，请求服务端的最新数据然后更新客户端显示。这种方式实际上**浪费了大量流量并且对服务端造成了很大压力**。
2. **SSE(Server-Sent Event,服务器推送事件):**
	- SSE是一种允许服务端向客户端推送新数据的HTML5技术.

# 面试题总结:
## 1. 表总结:
### employee表:
![[Pasted image 20241009170520.png]]
**主键id**,姓名,**用户名(unique)**,密码,电话号码,性别,状态,创建时间和修改时间.

### Catagory表:
![[Pasted image 20241009170708.png]]
利用type的值来区分是菜品还是套餐(0是菜品,1是套餐).
### shopping_cart表:
![[Pasted image 20241009183137.png]]
保存的是购物车中的菜品,当需要查询某个用户的购物车时,可以通过`listById()`来实现.

### address_book表:
![[Pasted image 20241009183849.png]]
### orders订单表:
![[Pasted image 20241009184509.png]]
![[Pasted image 20241009211945.png]]
### order_detail订单明细表:
![[Pasted image 20241009184455.png]]
## 2. 你的Redis主要的应用场景是什么?
**缓存逻辑分析：**
- **每个分类下的菜品保存一份缓存数据**
- 数据库中菜品数据**有变更时清理缓存数据**

![[Pasted image 20241009182953.png|400]]
- key名设计遵循`业务前缀:分类id`. (**业务前缀使用常量类来定义,避免出错.**)
	由阿里云Redis开发规范可知: Key的设计要遵循几个原则:
	1) **可读性+可管理性**:以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如`业务名:表名:id`
	2) **简洁性:** `user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}`,当key太大时,内存占用不可忽视.
	3) **不要包含特殊字符:** 
```java
//构造redis中的key，规则：dish_分类id
String key = "dish_" + categoryId;
```
Redis主要用于需要展示的菜品. 因为如果用户访问量比较大,那么全都查询数据库,数据库的压力会很大，因此我们将需要展示的菜品缓存到Redis中，在需要展示菜品时，就首先从Redis中查询，减小了数据库的压力！
![[Pasted image 20241009181231.png]]

查询菜品时，先查询Redis，若Redis不存在该数据，再去查询数据库。
修改菜品时，需要清理缓存，保证数据库和Redis中的数据一致性。然后在用户下次访问时，查询数据库，然后返回数据，同时将数据写入Redis中。

## 3. 你的SpringCache的使用场景是什么？

## 4. 考虑过商品超卖问题吗?


## 5. jwt验证流程

![[Pasted image 20241009165022.png]]
首先,用户登录时发起请求,登录成功后会生成jwt令牌.后端会返回jwt token给前端,前端会将令牌保存起来,并在后续的请求中都携带该令牌.后续的请求会被拦截器拦截,然后解析token,并存入ThreadLocal中,便于后续的使用.
## 6. ThreadLocal是什么?
ThreadLocal是一个线程内的局部变量,为每个线程提供一份单独的存储空间,具备线程隔离的效果,只有在该线程内才能获取到其中的值,线程外则无法访问.
## 7. 如何实现的公共字段填充？
首先是在菜品分类中，用户表中，都有创建时间和更新时间，创建人id和修改人id的字段，这些字段可以抽取出来进行统一处理，减少代码的冗余。
**实现思路：** 
- 首先我自定义了一个注解`@AUTOFILL`，用于标识需要实现自动填充的方法。
- 其次是需要更新的时候也就是INSERT和UPDATE操作，查询是不需要更新的。所以我定义了一个枚举类，用于标识是INSERT还是UPDATE。
- 自定义了切面类AutoFillAspect，**统一拦截加入了AutoFill注解**的方法，通过反射为公共字段赋值.
	- 具体而言,在切面类中**定义切点,用于定义哪些连接点会被拦截并应用通知**.
	- 然后是前置通知,在通知中**通过方法签名和注解中的标识类型**来判断要执行什么方法,最后就是在方法内对字段进行赋值了!
```Java
package com.sky.aspect;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect {

    /**
     * 切入点
     */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut(){}

    /**
     * 前置通知，在通知中进行公共字段的赋值
     */
    @Before("autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint){
        /////////////////////重要////////////////////////////////////
        //可先进行调试，是否能进入该方法 提前在mapper方法添加AutoFill注解
        log.info("开始进行公共字段自动填充...");

    }
}
```

```Java
/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect {

    /**
     * 切入点
     */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut(){}

    /**
     * 前置通知，在通知中进行公共字段的赋值
     */
    @Before("autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint){
        log.info("开始进行公共字段自动填充...");

        //获取到当前被拦截的方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        //获取到当前被拦截的方法的参数--实体对象
        Object[] args = joinPoint.getArgs();
        if(args == null || args.length == 0){
            return;
        }

        Object entity = args[0];

        //准备赋值的数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        //根据当前不同的操作类型，为对应的属性通过反射来赋值
        if(operationType == OperationType.INSERT){
            //为4个公共字段赋值
            try {
                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

                //通过反射为对象属性赋值
                setCreateTime.invoke(entity,now);
                setCreateUser.invoke(entity,currentId);
                setUpdateTime.invoke(entity,now);
                setUpdateUser.invoke(entity,currentId);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else if(operationType == OperationType.UPDATE){
            //为2个公共字段赋值
            try {
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

                //通过反射为对象属性赋值
                setUpdateTime.invoke(entity,now);
                setUpdateUser.invoke(entity,currentId);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```
## 8. payload中的信息会被解密吗?

## 9. 密文密码能被存入负载中吗?

## 10. ==WebSocket的作用?==
使用WebSocket主要是**实现了管理端页面和服务端保持长连接状态**,当用户下单或点击催单功能时,都会调用WebSocket相关API实现服务端向客户端推送消息!

**具体实现:**
**在OrderServiceImpl中注入WebSocketServer对象，修改paySuccess方法，加入如下代码：**
- 用户支付成功后,调用WebSocket的相关API实现服务端向客户端推送消息;
- 获取相关信息,向客户端浏览器发送JSON字符串;
- 客户端浏览器解析JSON字符串,判断是来单还是催单,执行对应功能.
``` hl:7
Map map = new HashMap();
map.put("type", 1);//消息类型，1表示来单提醒
map.put("orderId", orders.getId());
map.put("content", "订单号：" + outTradeNo);

//通过WebSocket实现来单提醒，向客户端浏览器推送消息
webSocketServer.sendToAllClient(JSON.toJSONString(map));
```

**在OrderServiceImpl中实现reminder方法：**
用户点击催单,发送GET请求.
```
//基于WebSocket实现催单
Map map = new HashMap();
map.put("type", 2);//2代表用户催单
map.put("orderId", id);
map.put("content", "订单号：" + orders.getNumber());

webSocketServer.sendToAllClient(JSON.toJSONString(map));
```

- **WebSocket介绍:**
	WebSocket 是基于 TCP 的一种新的**网络协议**。它实现了浏览器与服务器**全双工通信**——浏览器和服务器**只需要完成一次握手**，两者之间就可以创建**持久性**的连接，并进行**双向**数据传输。
	
	**HTTP协议和WebSocket协议对比：**
	-  HTTP是**短连接**
	-  WebSocket是**长连接**
	-  HTTP通信是**单向**的，基于请求响应模式
	-  WebSocket支持**双向**通信
	-  HTTP和WebSocket底层都是TCP连接
	
	**WebSocket缺点：**
	- 服务器长期维护长连接需要一定的成本
	- 各个浏览器支持程度不一
	- WebSocket 是长连接，受网络限制比较大，需要处理好重连
	**结论：** WebSocket并不能完全取代HTTP，它只适合在特定的场景下使用
	
	**应用场景:** 视频弹幕, 网页聊天,体育实况,股票基金报价实时更新.
## 11. 你是如何校验收货地址是否超出配送范围的?

## 12. SpringTask定时任务.
1. 使用SpringTask实现每分钟检查一次支付超时订单,并将订单状态修改为"已取消";
2. 使用SpringTask实现每天凌晨定时检查是否存在"派送中"订单,将派送中订单修改为"已完成".

**具体怎么实现的?**
1. 引入SpringTask定时任务包,然后在启动类上加入@EnableScheduling开启任务调度;
2. 创建定时任务类,在里面实现业务逻辑,具体就是针对上面两种定时任务,添加两个实现逻辑的方法(具体的操作交由Mapper层实现),加上@Scheduled(Cron="")注解,同时加上Cron表达式,用来指示什么时候执行该方法.

>**cron表达式:**

`秒 分 时 日期 月份 星期 [年份]`
`*`:匹配任意值,例如在字段月中,`*`表示每个月;
`?`:不指定值,**仅适用于日期和星期**.当字段`日期`或`星期`其中之一被指定了值以后，为了避免冲突，需要将另一个字段的值设为`?`。
`,`:列出枚举值.
`/`:指定数值的增量.在字段`分钟`中，`0/15`表示从第0分钟开始，每15分钟。在字段`分钟`中`3/20`表示从第3分钟开始，每20分钟。
`-`:指定范围。|在字段`分钟`中，`5-20`表示从5分钟到20分钟之间每隔一分钟触发一次。

|                                 |                      |
| ------------------------------- | -------------------- |
| 每天上午10:15执行任务                   | `0 15 10 ? * *`      |
| 每天中午12:00执行任务                   | `0 0 12 * * ?`       |
| 每天上午10:00点、下午14:00以及下午16:00执行任务 | `0 0 10,14,16 * * ?` |
| 每天14:00开始,每隔5分钟执行一次.            | `0 0/5 14 * * ?`     |

