# Java基础:
## 

# 集合类:

# Spring:

## 介绍一下Spring的IOC:
IOC,全称Inverse Of Control,控制反转.
传统的程序设计中,应用程序代码通常控制对象的创建和管理.例如,当一个对象需要依赖其他对象时,程序通过new等方式创建对象.而在IOC中,控制关系反转,**控制权交由Spring容器管理,容器负责创建和管理对象**!并在有需要时**注入**程序中.

**优点:**
1. 使用者无需关心引用bean的全部细节.
2. 不用创建多个相同的bean导致浪费.
3. Bean的修改使用方无需感知.

## 介绍一下Spring的AOP:
AOP,全称Aspect-Oriented Programming,面向切面编程,即把公用的逻辑抽出,让开发者能更专注于业务!
面向切面编程是面向对象编程思想的补充. AOP面向不同切面,并且**一个切面可以横跨多个类和对象操作**,极大地丰富了开发者的使用方式,提高了开发效率.

# MySQL:

# Redis:
## 介绍一下Redis的底层数据结构:
共五种,分别是`String,List,Set,Hash,ZSet`. 后续版本更新又添加了`BitMap,HyperLogLog,GEO,Stream`.

**使用场景:**
BitMap: 常用来做状态统计,例如用户签到记录.
HyperLogLog: 海量数据基数统计, 比如百万级用户UV
GEO: 存储地理信息,比如滴滴打车的用户定位?
Stream: 消息队列,相比于使用List实现的消息队列,优点是:1)可以自动生成全局唯一消息id; 2)支持以消费组形式消费数据.
## ZSet用过吗?
用过. 用于实现排行榜功能. 数据结构为:`key:member:score`.
赋值可用`ZADD key score member`,为
增加点赞数量用: `ZINCRBY key increment member`,可在原有score基础上增量增加.
查询排行可以用`ZREVRANGE key start stop`来查询降序的排行.

## ZSet的底层实现是什么?
ZSet底层是使用**压缩列表或跳表**实现的.
当集合的元素个数小于128,且每个元素的值小于64字节,使用压缩列表.
当不满足上述条件,例如元素个数大于128个,或存在元素大于64字节,则采用跳表.
然后,在Redis7中废除了压缩列表,使用listpack数据结构替代.

## ==跳表是怎么实现的?==
跳表是在链表的基础上改进过来的. 主要原因就是链表的查询需要逐一查找,时间复杂度是O(N),所以引入了跳表,实现了**多层的有序链表**,优点就是提高了查询效率(O(logN)),更快速定位数据.
![[Pasted image 20241009232226.png]]
**查询值为4的节点:**
链表查询:需要从头节点开始遍历,查询4次才能查询到目标节点.
跳表查询:可直接从L2层级跳到节点上,再往后查询一次就可以查询到目标节点了,只需要查找2次.

**跳表的数据结构:**
```C
typedef struct zskiplistNode {
	//Zset 对象的元素值 
	sds ele; 
	//元素权重值 
	double score; 
	//后向指针 
	struct zskiplistNode *backward; 
	//节点的level数组，保存每层上的前向指针和跨度 
	struct zskiplistLevel { 
		struct zskiplistNode *forward; 
		unsigned long span; } level[]; 
	} zskiplistNode;
```
内部存在ele和score变量,对应了member和score. 
然后还有个后向指针,便于倒序查找.
然后还有个**level[]数组**,里面保存了前向指针和**跨度**.

## ==Redis为什么使用跳表而不是用B+树?==
1. **内存占用**上,跳表更加灵活:
	平衡树每个节点包含2个指针,而跳表的每个节点包含的指针平均数目是`1/(1-p)`个,取决于p的大小.在Redis中,p的值为0.25,因此平均每个节点包含的指针就是`4/3`,比平衡树更有优势.
2. **范围查找**时,跳表操作更简单:
	B+树在查找到区间的左边界时(也就是较小的值),还需要继续中序遍历查找右边界的节点,那么在实现上就略显困难. 而在跳表上进行范围查询,只需要查找到小值后,在第一层进行若干次遍历再查找到右边界即可.
3. **算法实现**上,跳表更简单:
	B+树的插入和删除操作可能会导致树的结构的改变,逻辑复杂;而跳表的插入和删除只需要修改相邻节点的指针即可.

## 压缩列表是怎么实现的？
## 介绍一下Redis中的listpack.

## 哈希表是怎么扩容的？
首先,正常情况下数据都存储在`哈希表1`中. 当数据量逐渐增加时,此时需要就需要有`哈希表2`,分配的空间大小一般为表1的**2倍**. 然后**表1的数据会迁移到表2**中,然后**表2会被设置成表1**,最后表2中又会再次新建一个空白的哈希表,为下次扩容做准备.

这涉及到一个问题,就是如果数据量很大,并且由于**Redis是单线程**的,所以数据在由表1迁移至表2时,会**引起Redis的阻塞**,导致无法服务其他请求.

所以Redis采用了**渐进式rehash**,也就是将数据分多次迁移.具体而言,是 
1) **先给`哈希表2`分配空间**,
2) 然后在执行增删改查操作时,会**按顺序将数据迁移到`哈希表2`中**.

在渐进式更新过程中,新增操作会将数据保存到`哈希表2`中.
查询操作会先查询表1,再查询表2.

## String 是使用什么存储的?为什么不用 c 语言中的字符串?

## Redis为什么快?
1. 基于内存的数据库,数据存储在内存中,读写速度非常快.
2. Redis的**单线程模型**,所有操作都在一个线程内完成,无需线程切换,节省了线程切换带来的额外开销,并且也不会有死锁问题.
3. Redis在单线程的基础上,采用了**I/O多路复用技术**(epoll和select机制),实现了**单个线程同时处理多个用户端连接**的能力,从而提高了Redis的并发性能.
	- 在单线程时,允许内核中存在多个监听Socket和已连接的Socket,内核会一直监听这些Socket的连接请求或数据请求.
4. 采用了**高效的数据结构**,在设计上进行了性能优化,能实现O(1)复杂度的读写操作.
5. Redis6.0中引入了多线程机制。采用多线程，可以使请求处理并发进行，大大提升性能。当线程在处理网络IO时，其他线程可以继续处理其他请求，减少了阻塞时间.

## 为什么Redis 6.0引入了多线程?


## Redis哪些地方使用了多线程?
