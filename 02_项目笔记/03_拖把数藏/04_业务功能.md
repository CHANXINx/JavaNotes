## 1. GateWay网关模块
#### 作用
- **路由转发**：提供流量的统一入口，根据请求的不同路径再转发到相应的下游服务。
- 因为拦截了所有流量，因此可以做限流、负载均衡；
- 可以做鉴权；

#### 源码分析
##### 组件引入
- `nft-turbo-config`：配置中心组件，用于服务的发现，以便进行路由和负载均衡；
- `nft-turbo-limiter`：也就是引入了Sentinel，用于进行限流；
- `sa-token-reactor-spring-boot3-starter`：用于进行统一鉴权； 
	- `sa-token-redis-jackson`：Sa-Token引入Redis，Redis用于保存用户登录态，实现分布式登录。
- `spring-cloud-starter-loadbalancer`：进行负载均衡；
- `sensitive-logback`：用于日志脱敏。
##### 路由转发
- lb前缀就代表了负载均衡；
- 以`nfturbo-auth`为例，就是所有`/auth`和`/token`结尾的路径都会被转发到nfturbo-auth模块。
	- id代表路由的唯一标识；
	- uri代表目标服务的地址，会根据该uri路由到nacos中心对应注册的服务；
		- uri还支持静态转发，例如`uri: http://example.com`，网关会直接将请求转发到该地址。但是静态转发和负载均衡不能一同配置。
	- predicates代表所有该前缀的路径都会被转发到该模块。
```java
routes:  
  - id: nfturbo-auth  
    uri: lb://nfturbo-auth  
    predicates:  
      - Path=/auth/**,/token/**  
  - id: nfturbo-business  
    uri: lb://nfturbo-business  
    predicates:  
      - Path=/trade/**,/order/**,/user/**,/collection/**,/wxPay/**
```
##### 负载均衡
通过路由转发，会实现将请求转发到Nacos中的对应服务的集群。通过引入LoadBalancer，可以实现负载均衡功能。
```java
    uri: lb://nfturbo-auth  
```
这里的`lb://`就起到了负载均衡的作用，实现了具体路由到集群中的哪台集群。
##### 统一鉴权
>_参考【[网关统一鉴权](https://sa-token.cc/doc.html#/micro/gateway-auth?id=%e5%be%ae%e6%9c%8d%e5%8a%a1-%e7%bd%91%e5%85%b3%e7%bb%9f%e4%b8%80%e9%89%b4%e6%9d%83)】_

继承了OAuth2来进行统一的登录和鉴权。
- **登录拦截**：定义注册全局过滤器，用于在最前方拦截所有请求，同时开放部分地址，用于登录、藏品展示以及微信支付成功的回调【因为该回调不带有登录信息】
- **权限认证**：根据请求的不同路径，判断用户是否存在对应权限。
- **异常处理**：最后还定义了`getSaResult()`方法，用于进行捕获鉴权抛出的异常，并返回给前端对应的错误信息。
```java
@Configuration  
@Slf4j  
public class SaTokenConfigure {  
  
    @Bean  
    public SaReactorFilter getSaReactorFilter() {  
        return new SaReactorFilter()  
                // 拦截地址  
                .addInclude("/**")  
                // 开放地址  
                .addExclude("/favicon.ico")  
                // 鉴权方法：每次访问进入  
                .setAuth(obj -> {  
                    // 登录校验 -- 拦截所有路由，并排除/auth/login 用于开放登录  
                    SaRouter.match("/**").notMatch("/auth/**", "/collection/collectionList", "/collection/collectionInfo", "/wxPay/**").check(r -> StpUtil.checkLogin());  
  
                    // 权限认证 -- 不同模块, 校验不同权限  
                    SaRouter.match("/admin/**", r -> StpUtil.checkRole(UserRole.ADMIN.name()));  
                    SaRouter.match("/trade/**", r -> StpUtil.checkPermission(UserPermission.AUTH.name()));  
  
                    SaRouter.match("/user/**", r -> StpUtil.checkPermissionOr(UserPermission.BASIC.name(), UserPermission.FROZEN.name()));  
                    SaRouter.match("/order/**", r -> StpUtil.checkPermissionOr(UserPermission.BASIC.name(),UserPermission.FROZEN.name()));  
                })  
                // 异常处理方法：每次setAuth函数出现异常时进入  
                .setError(this::getSaResult);  
    }  
  
    private SaResult getSaResult(Throwable throwable) {  
        switch (throwable) {  
            case NotLoginException notLoginException:  
                log.error("请先登录");  
                return SaResult.error("请先登录");  
            case NotRoleException notRoleException:  
                if (UserRole.ADMIN.name().equals(notRoleException.getRole())) {  
                    log.error("请勿越权使用！");  
                    return SaResult.error("请勿越权使用！");  
                }  
                log.error("您无权限进行此操作！");  
                return SaResult.error("您无权限进行此操作！");  
            case NotPermissionException notPermissionException:  
                if (UserPermission.AUTH.name().equals(notPermissionException.getPermission())) {  
                    log.error("请先完成实名认证！");  
                    return SaResult.error("请先完成实名认证！");  
                }  
                log.error("您无权限进行此操作！");  
                return SaResult.error("您无权限进行此操作！");  
            default:  
                return SaResult.error(throwable.getMessage());  
        }  
    }  
}
```

`StpInterfaceImpl`继承Sa-Token中的`StpInterface`接口，实现了其内部的`getPermissonList`与`getRoleList`方法：
- **获取权限列表**：通过`getPermissionList`实现，根据用户ID与登录类型，返回用户对应的权限；
	- 权限包括：INIT（创建成功）、AUTH（已实名）、ACTIVE（上链成功）、FROZEN（冻结），通过UserStateEnum枚举类定义。
- **获取角色列表**：通过`getRoleList`实现，根据用户ID与登录类型，返回用户对应的角色；
	- 角色包括ADMIN管理员与CUSTOMER游客。
```java 
/**  
 * 自定义权限验证接口  
 *  
 * @author Hollis  
 */@Component  
public class StpInterfaceImpl implements StpInterface {  
    @Override  
    public List<String> getPermissionList(Object loginId, String loginType) {  
        UserInfo userInfo = (UserInfo) StpUtil.getSessionByLoginId(loginId).get((String) loginId);  
  
        if (userInfo.getUserRole() == UserRole.ADMIN || userInfo.getState().equals(UserStateEnum.ACTIVE.name()) || userInfo.getState().equals(UserStateEnum.AUTH.name()) ) {  
            return List.of(UserPermission.BASIC.name(), UserPermission.AUTH.name());  
        }  
  
        if (userInfo.getState().equals(UserStateEnum.INIT.name())) {  
            return List.of(UserPermission.BASIC.name());  
        }  
  
        if (userInfo.getState().equals(UserStateEnum.FROZEN.name())) {  
            return List.of(UserPermission.FROZEN.name());  
        }  
  
        return List.of(UserPermission.NONE.name());  
    }  
  
    @Override  
    public List<String> getRoleList(Object loginId, String loginType) {  
        UserInfo userInfo = (UserInfo) StpUtil.getSessionByLoginId(loginId).get((String) loginId);  
        if (userInfo.getUserRole() == UserRole.ADMIN) {  
            return List.of(UserRole.ADMIN.name());  
        }  
        return List.of(UserRole.CUSTOMER.name());  
    }  
}
```

## 2. 统一认证设计
Auth模块中使用Sa-Token进行登录鉴权，实现单点登陆SSO（即一个模块登录了，其它模块就无需再次登录）。
- 首次登录时，网关将请求转发到Auth模块，基于Sa-Token实现登录鉴权，会使用Redis保存token和用户ID，然后将token返回给前端，前端保存在Cookie中，并在后续的请求中携带token；
- 后续登录请求都携带返回的token，然后对应模块会调用`StpUtil.getLoginId();`来根据token获取用户id，判断用户是否已登录。

使用Redis存储token与用户ID的好处：前端传来的参数是可能被篡改的，而根据token从Redis从获取用户ID则可避免这种情况。
![[Pasted image 20241231112332.png|550]]
## 3. 用户模块设计
### 时序图（流程图）
![[Pasted image 20250102164922.png|600]]
### 接口设计与具体实现
#### 1. 用户注册登录 
- 路径：`/auth/login`
- 请求参数：`{ "captcha": "string", "telephone": "string"}`（验证码、手机号）
- 实现逻辑：
	- 根据手机号从Redis中获取验证码，并与前端传来的验证码进行比对；
		- 若不正确，则直接返回“验证码错误”；
	- 若正确，则会根据手机号查询用户信息：
		- 若用户信息为空，则会调用service中的register方法进行用户注册【[[#用户注册逻辑]]】；
		- 若用户信息不为空，则会直接返回登录token给前端。
##### 用户注册逻辑
调用`userFacadeService.register()`方法实现用户注册：
- 请求参数：`{String telephone, String inviteCode}`【邀请码和手机号】
- 实现逻辑：
	- 首先对**手机号**加分布式锁，**避免用户重复点击造成数据库中有脏数据**；【KEY为手机号】
	- 为用户随机生成一个用户名：藏家_+6位随机数+手机号后四位；
		- 为了避免用户名重复，使用**布隆过滤器**判断用户名是否存在：若布隆存在则需要进入数据库再次查询（可能是误判），若仍存在，则重新生成新的用户名，直至不重复；若布隆过滤器返回用户名不存在，则确实不存在。
	- 若邀请码不为空，还会根据邀请码查数据库获取邀请人信息，并增加用户积分（+100分）；
		- 增加用户积分时为了避免并发情况，使用Redisson加了锁，并且是阻塞锁`lock.lock()`而不是`trylock()`。因为当前业务处理逻辑是比较快的，所以加了锁也不会很影响用户体验。
	- 以上操作做完后，调用重载register方法，写入数据库，**完成用户注册**（保存手机号、随机昵称、邀请人ID和邀请码）
	- 用户注册结束后，还需要①将用户名与邀请码写入布隆过滤器；②新增（更新）当前用户的缓存（ID缓存）。

**布隆过滤器：**
- 因为用户名不存在的概率很大，使用布隆过滤器可以快速判断用户名不存在，直接返回不存在，减少数据库的查询。
- 布隆过滤器在类初始化的时候初始化，并且由于布隆过滤器不止一个，此处的布隆过滤器的名称为`nickName`，容量为`100000L`，误判率为`0.01`。

#### 2. 发送验证码
- 路径：`/auth/sendCaptcha`
- 请求参数：`(String telephone)`
- 实现逻辑：
	- 调用Service的`generateAndSendSmsCaptcha`方法，进行验证码发送；
	- 滑动窗口限流校验，每60秒只能发送一次短信（`slidingWindowRateLimiter `）【若绕过，则会抛异常】
	- 返回短信验证码，通过HuTool工具类的随机数生成4位数验证码；
	- 使用Redis存储验证码，有效期为5分钟；【Key：`nft:turbo:captcha: telephone`，Value：验证码】
	-  创建虚拟线程（替代多线程，更方便轻量）发送验证码给用户，并使用Notice变量保存验证码与用户相关信息
		- 若成功则直接修改Notice变量的state为Success；
		- 若失败，也不做重试，让用户自行再次发送验证码即可。
##### <font color="#ff0000">滑动窗口限流：基于Redisson实现</font>
- KEY为`nft:turbo:limit:`+`telephone`，VALUE为1（限制次数），窗口大小（过期时间）为1分钟；
- 使用的是全局限流（`RateType.OVERALL`）。
	- Redisson限流器有两种模式，`RateType.OVERALL`和`RateType.PER_CLIENT`，前者全局限流，后者单机限流。
#### 3. 查询用户信息
- 路径：`/user/getUserInfo`
- 请求参数：无（直接根据cookie或LocalStorage中的token获取用户Session，进一步获取用户ID等信息）
- 具体逻辑：
	- 根据token获取用户ID，调用UserService中的`findById`方法获取用户信息：
	- `findById(Long userId)`方法做了二级缓存（本地缓存+基于Redis的分布式缓存），通过注解实现。
		- CacheType.BOTH表示既有LOCAL缓存，也有REMOTE缓存。在查询时，会先查本地缓存，再查询Redis缓存。
		- @CacheRefresh表示每隔60分钟 会自动调用`findById`方法，将最新数据更新到缓存中。
	  ```java
		@Cached(name = ":user:cache:id:", cacheType = CacheType.BOTH, key = "#userId", cacheNullValue = true)  
		@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)
			```
##### @Cache缓存如何实现的？
- 基于AOP实现的缓存的增删改查。若缓存中存在，则直接返回，不走数据库；若缓存中不存在，则查数据库，并更新到缓存。
- 如果查询数据库返回的结果是null，也会缓存到数据库中，以避免缓存穿透的问题。
#### 4. 修改用户昵称
- 路径：`/user/modifyNickName`
- 请求参数：`{"nickName": "string"}`，用户昵称
- 具体实现逻辑：
	- 根据Token获取用户ID；
	- 根据新用户昵称封装UserModifyRequest请求参数，并调用`userService.modify(userModifyRequest)`实现修改昵称操作；
	- modify方法①首先会获取用户信息，然后①判断用户是否存在与用户是否为非冻结状态；② 然后查询布隆过滤器与数据库判断用户名是否已经存在。
	- 若以上都校验通过，就会调用`updateById`方法来更新用户昵称，同时①在操作流水表中记录一条数据；②将新修改的用户名加入到布隆过滤器；③删除缓存；④封装返回结果。
		- 记录的流水信息为：用户信息+具体操作【如修改、冻结、实名等】
#### 5. 退出登录
- 路径：`/auth/logout`
- 请求参数：无
- 具体逻辑，调用Sa-Token的StpUtil.logout方法实现用户退出登录功能：
	- 获取用户token；
	- 创建一个立即失效的空cookie返回给客户端，覆盖原cookie；
	- 删除LocalStorage中的token信息；
	- 调用`logoutByTokenValue()`从Redis中删除该token信息。
#### 6. 实名认证 TODO
 - 路径：`user/auth`
 - 请求参数：`{"realname" : "string", "idcard" : "string"}`
 - 具体逻辑：
#### 7. 修改头像
- 路径：`/user/modifyProfilePhoto`
- 请求参数：`{ "file_data": MultipartFile}`
## 4. 藏品模块
### 🔍需求分析
#### 用例图
用户的功能：
- 创建链账户，用于唯一标识藏品的所有者；
- 交易藏品，支持二级市场交易；
- 销毁藏品，支持删除藏品（逻辑删除）；

平台功能：
- 上链藏品；
- 铸造藏品；
![[Pasted image 20250104110844.png|300]]
#### 时序图
![[Pasted image 20250104111023.png]]
### 💾存储设计
定义了5张表存储藏品相关信息：
-  collection：藏品表，保存藏品的信息以及库存；
- held_collection：持有藏品表，用于表明藏品被购买后，表明藏品的持有者；
- collection_stream：藏品流水表，用于记录藏品的变更记录；
- collection_snapshot：藏品快照表，用于记录藏品核心信息的修改，如价格、图片。用于回溯下单时的藏品信息。
- collection_inventory_stream：藏品库存流水表，记录藏品库存变更有关的流水，用于幂等控制和数据对账。
### 🔌接口设计
#### 1. 获取藏品列表

#### 2.获取藏品详情

#### 3.上链藏品

#### 4.藏品出售的try阶段，做库存预占用

#### 5.藏品出售的confirm阶段，做真正售出

#### 6.藏品出售的cancel阶段，做库存退还

#### 7.转移藏品

#### 8.销毁藏品

#### 9.预扣减库存
### 🙋🏻‍♂️问题分析

## 5. 藏品的库存扣减设计
### 🔍需求分析

### 💾存储设计

### 🔌接口设计
### Redis中的库存初始化
- 请求参数：`{"collectionID": "String", "identifier": "String","inventory":"Integer"}`，藏品ID、唯一标识符(幂等号)和库存
- 具体实现逻辑：
	- 根据传来的藏品信息中的藏品ID拼接Redis的KEY：`clc:inventory: + 藏品ID`；
	- 判断Redis中是否存在该键值对，若存在则直接返回；若不存在，则新建缓存，设置对应藏品、库存信息。
### ⭐扣减藏品库存
- 请求参数

### ⭐增加藏品库存
>**与库存扣减的逻辑相同**
- 请求参数：`{"collectionID": "String", "identifier": "String","inventory":"Integer"}`
- 具体实现逻辑：
	-    
### 失效藏品库存
- 请求参数：`{"collectionID": "String", "identifier": "String","inventory":"Integer"}`
- 具体实现逻辑：
	- 根据藏品ID拼接KEY，删除Redis中KEY对应的数据。
	- 将Redis中流水表中的该藏品ID对应的流水信息过期时间设置为24小时后，避免流水记录立即过期，导致对账出现问题。
### 🙋🏻‍♂️问题分析


## 6. 区块链模块设计
### 基本介绍
### 🔍需求分析

### 💾存储设计

### 🔌接口设计
### 1. 创建链账户

### 2. 创建藏品


上游
### 7. 

藏品铸造、转让和销毁，使用了**模板方法模式** （doPostExecute），前面请求路径的拼接和异步后处理的逻辑都是一致的。
### 🙋🏻‍♂️问题分析

## 7. ⭐订单模块
### 基本介绍
提供订单的全生命周期的管理。

### 🔍需求分析

### 💾存储设计
定义2张表：订单表和订单流水表。
- 订单表做了数据冗余，避免多表JOIN，提高查询性能。
- 流水表用于做订单对账以及幂等控制。
#### 状态机
- 订单有两个终态：CLOSED和FINISH，终态不可逆转。
![[Pasted image 20250105201952.png|300]]
### 🔌业务流程
#### 下单
亮点：[[基于Token校验避免订单重复提交]]

### 🙋🏻‍♂️问题分析

## 8. 商品模块设计
### 基本介绍
其实主要是为了抽象出一个商品域，把底层的具体商品类型屏蔽掉，因为我们现在有collection（藏品）、box（盲盒）等，以及我们项目中不准备做但是其实很多数藏有的——持有藏品（held_collection）的转让等等。

所以，我们定义了一个goods模块，用于和 trade、order 模块直接交互，屏蔽掉底层的差异。

goods 这一层不要做存储，最多是和缓存交互一下而已，所以，通常都把它叫做防腐层。
### 模块实现
- 使用抽象类有什么好处？在后期若添加盲盒功能，
```java
public abstract class BaseGoodsVO implements Serializable {
    /**
     * 商品名称
     *
     * @return
     */
    public abstract String getGoodsName();

    /**
     * 商品图片
     *
     * @return
     */
    public abstract String getGoodsPicUrl();

    /**
     * 卖家id
     *
     * @return
     */
    public abstract String getSellerId();

    /**
     * 版本
     *
     * @return
     */
    public abstract Integer getVersion();

    /**
     * 是否可用
     *
     * @return
     */
    public abstract Boolean available();

    /**
     * 价格
     *
     * @return
     */
    public abstract BigDecimal getPrice();
}
```
## 9. 用户的统一鉴权设计 <font color="#ff0000">TODO</font>
参考RBAC（Role Base Access Control）鉴权模型，根据用户的状态/角色的不同，区分为以下几种权限：
1、未登录用户
- 可以查看商品
- 无法查看个人信息
- 不能下单
2、未实名认证用户
- 可以查看商品
- 可以查看/操作个人信息
- 不能下单
3、已实名认证用户
- 可以下单
- 不能管理商品
4、管理员用户
- 啥都能干
- 管理商品
5、已被冻结用户
- 不能下单

用户登录时，网关