## GateWay网关设计
#### 作用
- **路由转发**：提供流量的统一入口，根据请求的不同路径再转发到相应的下游服务。
- 因为拦截了所有流量，因此可以做限流、负载均衡；
- 可以做鉴权；

#### 源码分析
##### 组件引入
- `nft-turbo-config`：配置中心组件，用于服务的发现，以便进行路由和负载均衡；
- `nft-turbo-limiter`：也就是引入了Sentinel，用于进行限流；
- `sa-token-reactor-spring-boot3-starter`：用于进行统一鉴权； 
	- `sa-token-redis-jackson`：Sa-Token引入Redis，Redis用于保存用户登录态，实现分布式登录。
- `spring-cloud-starter-loadbalancer`：进行负载均衡；
- `sensitive-logback`：用于日志脱敏。
##### 路由转发
- lb前缀就代表了负载均衡；
- 以`nfturbo-auth`为例，就是所有`/auth`和`/token`结尾的路径都会被转发到nfturbo-auth模块。
	- id代表路由的唯一标识；
	- uri代表目标服务的地址，会根据该uri路由到nacos中心对应注册的服务；
		- uri还支持静态转发，例如`uri: http://example.com`，网关会直接将请求转发到该地址。但是静态转发和负载均衡不能一同配置。
	- predicates代表所有该前缀的路径都会被转发到该模块。
```java
routes:  
  - id: nfturbo-auth  
    uri: lb://nfturbo-auth  
    predicates:  
      - Path=/auth/**,/token/**  
  - id: nfturbo-business  
    uri: lb://nfturbo-business  
    predicates:  
      - Path=/trade/**,/order/**,/user/**,/collection/**,/wxPay/**
```
##### 负载均衡
通过路由转发，会实现将请求转发到Nacos中的对应服务的集群。通过引入LoadBalancer，可以实现负载均衡功能。
```java
    uri: lb://nfturbo-auth  
```
这里的`lb://`就起到了负载均衡的作用，实现了具体路由到集群中的哪台集群。
##### 统一鉴权
>_参考【[网关统一鉴权](https://sa-token.cc/doc.html#/micro/gateway-auth?id=%e5%be%ae%e6%9c%8d%e5%8a%a1-%e7%bd%91%e5%85%b3%e7%bb%9f%e4%b8%80%e9%89%b4%e6%9d%83)】_

继承了OAuth2来进行统一的登录和鉴权。
- **登录拦截**：定义注册全局过滤器，用于在最前方拦截所有请求，同时开放部分地址，用于登录、藏品展示以及微信支付成功的回调【因为该回调不带有登录信息】
- **权限认证**：根据请求的不同路径，判断用户是否存在对应权限。
- **异常处理**：最后还定义了`getSaResult()`方法，用于进行捕获鉴权抛出的异常，并返回给前端对应的错误信息。
```java
@Configuration  
@Slf4j  
public class SaTokenConfigure {  
  
    @Bean  
    public SaReactorFilter getSaReactorFilter() {  
        return new SaReactorFilter()  
                // 拦截地址  
                .addInclude("/**")  
                // 开放地址  
                .addExclude("/favicon.ico")  
                // 鉴权方法：每次访问进入  
                .setAuth(obj -> {  
                    // 登录校验 -- 拦截所有路由，并排除/auth/login 用于开放登录  
                    SaRouter.match("/**").notMatch("/auth/**", "/collection/collectionList", "/collection/collectionInfo", "/wxPay/**").check(r -> StpUtil.checkLogin());  
  
                    // 权限认证 -- 不同模块, 校验不同权限  
                    SaRouter.match("/admin/**", r -> StpUtil.checkRole(UserRole.ADMIN.name()));  
                    SaRouter.match("/trade/**", r -> StpUtil.checkPermission(UserPermission.AUTH.name()));  
  
                    SaRouter.match("/user/**", r -> StpUtil.checkPermissionOr(UserPermission.BASIC.name(), UserPermission.FROZEN.name()));  
                    SaRouter.match("/order/**", r -> StpUtil.checkPermissionOr(UserPermission.BASIC.name(),UserPermission.FROZEN.name()));  
                })  
                // 异常处理方法：每次setAuth函数出现异常时进入  
                .setError(this::getSaResult);  
    }  
  
    private SaResult getSaResult(Throwable throwable) {  
        switch (throwable) {  
            case NotLoginException notLoginException:  
                log.error("请先登录");  
                return SaResult.error("请先登录");  
            case NotRoleException notRoleException:  
                if (UserRole.ADMIN.name().equals(notRoleException.getRole())) {  
                    log.error("请勿越权使用！");  
                    return SaResult.error("请勿越权使用！");  
                }  
                log.error("您无权限进行此操作！");  
                return SaResult.error("您无权限进行此操作！");  
            case NotPermissionException notPermissionException:  
                if (UserPermission.AUTH.name().equals(notPermissionException.getPermission())) {  
                    log.error("请先完成实名认证！");  
                    return SaResult.error("请先完成实名认证！");  
                }  
                log.error("您无权限进行此操作！");  
                return SaResult.error("您无权限进行此操作！");  
            default:  
                return SaResult.error(throwable.getMessage());  
        }  
    }  
}
```

`StpInterfaceImpl`继承Sa-Token中的`StpInterface`接口，实现了其内部的`getPermissonList`与`getRoleList`方法：
- **获取权限列表**：通过`getPermissionList`实现，根据用户ID与登录类型，返回用户对应的权限；
	- 权限包括：INIT（创建成功）、AUTH（已实名）、ACTIVE（上链成功）、FROZEN（冻结），通过UserStateEnum枚举类定义。
- **获取角色列表**：通过`getRoleList`实现，根据用户ID与登录类型，返回用户对应的角色；
	- 角色包括ADMIN管理员与CUSTOMER游客。
```java 
/**  
 * 自定义权限验证接口  
 *  
 * @author Hollis  
 */@Component  
public class StpInterfaceImpl implements StpInterface {  
    @Override  
    public List<String> getPermissionList(Object loginId, String loginType) {  
        UserInfo userInfo = (UserInfo) StpUtil.getSessionByLoginId(loginId).get((String) loginId);  
  
        if (userInfo.getUserRole() == UserRole.ADMIN || userInfo.getState().equals(UserStateEnum.ACTIVE.name()) || userInfo.getState().equals(UserStateEnum.AUTH.name()) ) {  
            return List.of(UserPermission.BASIC.name(), UserPermission.AUTH.name());  
        }  
  
        if (userInfo.getState().equals(UserStateEnum.INIT.name())) {  
            return List.of(UserPermission.BASIC.name());  
        }  
  
        if (userInfo.getState().equals(UserStateEnum.FROZEN.name())) {  
            return List.of(UserPermission.FROZEN.name());  
        }  
  
        return List.of(UserPermission.NONE.name());  
    }  
  
    @Override  
    public List<String> getRoleList(Object loginId, String loginType) {  
        UserInfo userInfo = (UserInfo) StpUtil.getSessionByLoginId(loginId).get((String) loginId);  
        if (userInfo.getUserRole() == UserRole.ADMIN) {  
            return List.of(UserRole.ADMIN.name());  
        }  
        return List.of(UserRole.CUSTOMER.name());  
    }  
}
```

## 统一认证设计
![[Pasted image 20241231112332.png|550]]
