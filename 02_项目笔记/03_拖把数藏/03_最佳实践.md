## 1. 基于Redisson滑动窗口实现验证码发送限流
基于Redisson的令牌桶，但是将令牌桶的请求数设置为1时，此时令牌桶就退化成滑动窗口。

## 2. 自定义 TypeHandler 实现隐私数据自动加解密 TODO

## 3. 基于ZSet实现排行榜功能
### 🔍需求分析
- 获取用户的邀请排名：根据用户积分从高到低进行排序。大概展示为：`用户ID-排名-积分`
- 获取我的排名：用户能查看自己在排行榜中的排名。
### 💾存储设计
- 基于需求分析，采用ZSet进行存储，能根据ZSet的对应方法实现上述功能。
- KEY为inviteRank，Member为用户ID，Score为积分，ZSet会默认按照积分进行升序排列。
### 🔌接口设计
#### 1. 获取排行榜
- 使用`ZREVRANGEBYSCORE`方法获取按照分数由高到低的排名。
```java
//按照分数从高到低，获取前N个用户的排名信息
public List<InviteRankInfo> getTopN(Integer topN) {
	// 传入起点与终点，获取前N个用户的排名。
    Collection<ScoredEntry<String>> rankInfos = inviteRank.entryRangeReversed(0, topN - 1);

    List<InviteRankInfo> inviteRankInfos = new ArrayList<>();

    if (rankInfos != null) {
        for (ScoredEntry<String> rankInfo : rankInfos) {
            InviteRankInfo inviteRankInfo = new InviteRankInfo();
            // 根据Member获取用户ID
            String userId = rankInfo.getValue();
            // 根据Member查询用户信息用于返回前端展示
            if (StringUtils.isNotBlank(userId)) {
                User user = findById(Long.valueOf(userId));
                if (user != null) {
	                // 昵称
                    inviteRankInfo.setNickName(user.getNickName());
                    // 邀请码
                    inviteRankInfo.setInviteCode(user.getInviteCode());
                    // 邀请人数，因为邀请一个人分数+100.
                    inviteRankInfo.setInviteCount(rankInfo.getScore().intValue() / 100);
                    // 返回topN用户信息集合给前端
                    inviteRankInfos.add(inviteRankInfo);
                }
            }
        }
    }

    return inviteRankInfos;
}
```
#### 2. 获取我的排名
- 使用`ZREVRANK`方法实现按照分数由高到低排序时，成员Member的排名。
```java
//获取指定用户的排名，按照分数从高到低
public Integer getInviteRank(String userId) {
    Integer rank = inviteRank.revRank(userId);
    if (rank != null) {
	    // 因此以0作为起点，所以需要+1
        return rank + 1;
    }
    return null;
}
```
#### 3. 更新排名
- 用户在注册时若填写了邀请码，则会增加对应邀请码的积分。对应使用ZINCRBY命令实现。
- 为了避免并发问题，使用Redisson对邀请人ID加锁。因为链路较短，执行较快，因此加锁而不用Lua脚本，也不会太影响用户体验。
```java
private void updateInviteRank(String inviterId) {
    // 如果邀请者ID为空，则直接返回，不进行操作
    if (inviterId == null) {
        return;
    }

    // 获取Redisson的锁对象
    RLock rLock = redissonClient.getLock(inviterId);
    // 对邀请者ID对应的锁进行加锁操作，避免并发更新
    rLock.lock();
    try {
        // 获取邀请者的当前排名分数
        Double score = inviteRank.getScore(inviterId);
        // 如果当前分数为空，则设置默认为0.0
        if (score == null) {
            score = 0.0;
        }
        // 将邀请者的排名分数增加100.0，并更新到排行榜中
        inviteRank.add(score + 100.0, inviterId);
    } finally {
        // 最终释放邀请者ID对应的锁
        rLock.unlock();
    }
}
```
### 🙋🏻‍♂️问题分析
#### 使用ZSet存储，没有持久化咋办？
- 一是排行榜数据不是特别重要，因此无需使用数据库持久化，可以使用Redis持久化实现；
- 二是若Redis宕机数据丢失了，可以定时到数据库查一次，利用`where invite_id = #{id}`就可以查询出该用户的邀请人数。
- 对于更新不频繁的排行榜数据，可以使用RDB持久化。将save配置参数设置为适当的值，以平衡数据安全性和性能；同时，可以手动执行BGSAVE或SAVE命令来创建数据集快照。
- 对于更新频繁的排行榜数据，可以使用AOF持久化，并设置`appendfsync`参数来控制AOF文件的同步频率。

## 4. 基于ElasticSearch实现藏品搜索 TODO

使用ES时，往往都是基于两个目的：
1. 使用搜索功能，需要倒排索引；
2. 使用宽表，需要多表Join
### 深分页优化
### ES和DB的动态切换
- 首先是CollectionService的接口，在Bean声明时使用接口进行声明；
- 在实现类中，定义CollectionEsService和CollectionDbService两个实现类，此时Bean声明应该会报错，因为Spring框架不知道具体要注入哪个Bean；
- 在CollectionDbService中添加注解`@ConditionalOnProperty()`，此时在配置文件实现对应配置，就可以实现动态切换。

```java
@Service  
@ConditionalOnProperty(name = "spring.elasticsearch.enable", havingValue = "false", matchIfMissing = true)  
public class CollectionDbService extends BaseCollectionService {
	...
}
```
```yml
[es.yml]
spring:
  elasticsearch:
    enable: ${nft.turbo.elasticsearch.enable}
    uris: http://${nft.turbo.elasticsearch.url}
    username: ${nft.turbo.elasticsearch.username}
    password: ${nft.turbo.elasticsearch.password}
```


