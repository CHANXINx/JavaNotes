# 1. 同步模式之保护性暂停:
## 定义:
Guarded Suspension,在一个线程内等待另一个线程的执行结果.
![[Pasted image 20241020204319.png|500]]
**重点:**
- 适用于单个结果的传递,若是有多个结果,适合用消息队列;
- 两个线程关联同一个GuardedObject;
- JDK中,`join`,`Future`的实现采用的就是此模式.

## 代码
```java
public class GuardedObject {  
    private Object response;  
    static final Object lock = new Object();  
  
    private Object get(){  
        synchronized (lock){  
            // 条件不满足则等待  
            while (response == null){  
                try {  
                    lock.wait(2000);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            return response;  
        }  
    }  
  
    private void complete(Object response){  
        synchronized (lock){  
            if (true){  // 条件满足，通知等待线程  
                this.response = response;  
                lock.notifyAll();  
            }  
        }  
  
    }  
}
```

## 保护性暂停的超时优化:
1. 需要添加等待时间,并且这个等待时间不能是固定的秒数,否则会在循环内不停`wait(time)`,这样最终等待时间肯定会超过传入的timeout.
2. 使用`passTime`来记录等待时间,并与传入的timeout进行比较,若大于,则停止等待.
3. 继续考虑"虚假唤醒"的情况: 例如`wait(2000)`等待2秒的途中被虚假唤醒,然后继续执行,此时`passtime = currenttime-begin`肯定不超过2秒! 之后又重新进入循环,此时`wait(2000)`还是等待2秒,这样等待时间就会超过timeout!
**总结:**
- 经历时间和wait()的等待时间,**都应该参数化**,而不应该是固定的值,以避免虚假唤醒和循环等待的情况.
```java hl:9,14,19
private Object get(long timeout){  
    synchronized (lock){  
        // 开始时间  
        long begin = System.currentTimeMillis();  
        long passTime = 0;  
        // 条件不满足则等待  
        while (response == null){  
            // 经历时间超过等待时间，退出  
            if (passTime >= timeout) {  
                break;  
            }  
            try {  
                // 等待时间参数化，以避免虚假唤醒  
                lock.wait(timeout - passTime);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            // 等待时间.  
            passTime = System.currentTimeMillis() - begin;  
        }  
        return response;  
    }  
}
```

## 多任务版GuardedObject:
![[Pasted image 20241020225411.png|500]]
如果需要在多个类之间使用`GuardedObject`对象,则多个类之间传递对象不太方便,因此设计解耦类Mailboxes,既能解耦"结果等待者"和"结果生成者",还能**支持多个任务管理**.
>**送信人和收信人是一一对应的.**

```java
class Mailboxes {  
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();  
    private static int id = 1;  
  
    // 产生唯一id    
    private static synchronized int generateId() {  
        return id++;  
    }  
	  
    public static GuardedObject getGuardedObject(int id) {
	    // 调用remove方法,既返回GuardedObject对象,同时清除对象,避免占用内存!
        return boxes.remove(id);  
    } 
     
	// 调用createGuardedObject方法的同时会将id自增!
    public static GuardedObject createGuardedObject() {  
        GuardedObject go = new GuardedObject(generateId());  
        boxes.put(go.getId(), go);  
        return go;  
    }  
  
    public static Set<Integer> getIds() {  
        return boxes.keySet();  
    }  
}
```

>**每个People,Postman对象都对应一个线程,所以继承Thread类.**
- People的作用是**收信**,所以需要调用`GuardedObject`的`get`方法来收信.
```java
class People extends Thread{
	@Override
	public void run() {
		// 收信
		GuardedObject guardedObject = Mailboxes.createGuardedObject();
		log.debug("开始收信 id:{}", guardedObject.getId());
		// 获取信,并设置等待时间
		Object mail = guardedObject.get(5000);
		log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
	}
}
```
- Postman的作用是**送信**,所以需要调用`GuardedObject`的`complete`方法来送信.
- 需要id,用来获取对应`GuardedObject`对象,并放入信`mail`(待传递的信息)
```java
class Postman extends Thread {
	private int id;
	private String mail;
	
	public Postman(int id, String mail) {
		this.id = id;
		this.mail = mail;
	}
	
	@Override
	public void run() {
		// 获取GuardedObject对象,用来放信
		GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
		log.debug("送信 id:{}, 内容:{}", id, mail);
		// 放入"信"
		guardedObject.complete(mail);
	}
}
```

**测试:**
```java
public static void main(String[] args) throws InterruptedException {
	for (int i = 0; i < 3; i++) {
		//创建3个收信人,也即3个box: new的同时内部的create方法对MailBoxs的id自增了.
		new People().start();
	}
	Sleeper.sleep(1);
	// 获取所有id->获取所有box-> 送信
	for (Integer id : Mailboxes.getIds()) {
		new Postman(id, "内容" + id).start();
	}
}
```
# 2. 异步模式之生产者/消费者:
## 定义:
- 不需要产生结果和消费结果的线程一一对应;
- 可以用来平衡生产和消费的线程资源;
- **生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据**
- 消息队列是**有容量限制**的，满时不会再加入数据，空时不会再消耗数据
- 生产的消息进入队列不会被立即消费,所以是**异步模式**
![[Pasted image 20241021123517.png]]

## 实现:
简单的消息队列实现,进程内的线程间通信.


```java
public class MessageQueueTest {  
    public static void main(String[] args) {  
        MessageQueue mq = new MessageQueue(2);  
  
        // 创建生产者线程  
        for (int i = 0; i < 3; i++) {  
            int id = i;  
            new Thread(() -> {  
                mq.put(new Message("消息",id));  
            },"生产者t"+String.valueOf(i)).start();  
        }  
        new Thread(() -> {  
            //mq.take();  
        },"消费者").start();  
    }  
  
}  
@Slf4j  
class MessageQueue{  
    // 消息队列集合  
    private LinkedList<Message> list = new LinkedList<>();  
    // 消息队列容量  
    private int capacity;  
  
    public MessageQueue(int capacity) {  
        this.capacity = capacity;  
    }  
  
    // 获取消息  
    public Message take(){  
        // 检查队列是否为空  
        while (list.isEmpty()){  
            //为空则等待  
            synchronized (list) {  
                try {  
                    log.info("队列为空,消费者等待中...");  
                    list.wait();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        }  
        // 获取队列中队首元素并移除  
        Message message = list.removeFirst();  
        log.info("获取消息成功...");  
        // 唤醒生产者的等待线程  
        list.notifyAll();  
        return message;  
    }  
  
    // 存入消息.  
    public void put(Message message){  
        synchronized (list){  
            // 检查队列是否已满  
            while (list.size() == capacity) {  
                try {  
                    log.info("队列已满,生产者等待中...");  
                    list.wait();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            list.addLast(message);  
            log.info("成功放入消息...");  
            // 唤醒消费者的等待线程  
            list.notifyAll();  
        }  
    }  
  
  
}  
  
// 消息类  
final class Message{  
    private Object value;  
    private int id;  
  
    public Message(Object value, int id) {  
        this.value = value;  
        this.id = id;  
    }  
  
    public Object getValue() {  
        return value;  
    }  
  
    public int getId() {  
        return id;  
    }  
  
    @Override  
    public String toString() {  
        return "Message{" +  
                "value=" + value +  
                ", id=" + id +  
                '}';  
    }  
}
```

# 同步模式之顺序控制
## 1. 固定运行顺序
>例如:**必须先打印2,后打印1**
### 1.1 利用wait,notify实现

**思路:**
- 利用`while(!thread2Exec)`判断线程2是否执行:
- 若线程2未执行,则利用`lock.wait()`释放锁,进入阻塞状态等待;
- 线程1释放锁后,线程2成功获取锁,打印"2",并将`thread2Exec`置为true,同时唤醒线程1,继续执行`wait()`后面的代码,即打印"1"
```java
public class OrderExec {  
    private static final Logger log = LoggerFactory.getLogger(OrderExec.class);  
    static boolean thread2Exec = false;  
    static Object lock = new Object();  
    public static void main(String[] args) {  
        Thread t1 = new Thread(() -> {  
            synchronized (lock){  
                while (!thread2Exec){  
                    try {  
                        //等待,直到被唤醒。  
                        lock.wait();  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
                log.info("1111111111!");  
            }  
        },"t1");  
  
        Thread t2 = new Thread(() -> {  
            synchronized (lock){  
                log.info("2222222222!");  
                thread2Exec = true;  
                //唤醒等待中的线程1  
                lock.notifyAll();  
            }  
        },"t2");  
  
        t1.start();  
        t2.start();  
  
    }  
}
```

### 1.2 利用park,unpark实现

**思路:**
- 利用`LockSupport.park()`阻塞`t1`线程;
- `t2`线程打印完"222!"后,调用`LockSupport.unpark()`方法来唤醒`t1`线程.
- t1线程被唤醒后,继续执行,即打印"111!"
```java
@Slf4j  
public class OrderExec2 {  
    static Object lock = new Object();  
    public static void main(String[] args){  
        Thread t1 = new Thread(() -> {  
                LockSupport.park();  
                log.info("111!");  
        },"t1");  
  
        Thread t2 = new Thread(() -> {  
  
                log.info("222!");  
                LockSupport.unpark(t1);  
        },"t2");  
  
        t1.start();  
        t2.start();  
    }  
}
```

## 2. 交替输出
>线程1输出"a"5次，线程2输出"b"5次,线程3输出"c"5次.
现在要求输出abcabcabcabcabc怎么实现?

### 2.1 使用wait,notify实现

**思路:**
- 定义了一个通用的`WaitNotify`类,其实例对象作为三个线程的锁! 并且,在`WaitNotify`类中定义一个print方法,供线程获取到锁后调用以进行打印.
- 针对于`print(String str, int waitFlag, int nextFlag)`方法的分析:
	- `str`用于传入当前线程需要打印的字符;
	- `waitFlag`用于定义当前线程需要等待的索引,即成员变量`flag==waitFlag`才执行打印逻辑;
	- `nextFlag`用于定义下一个需要打印的线程,即用于切换线程.

```java
public class AlterExec {  
    static WaitNotify wn = new WaitNotify(5, 1);  
  
    public static void main(String[] args) {  
        new Thread(() -> {  
            wn.print("a", 1, 2);  
        }).start();  
        new Thread(() -> {  
            wn.print("b", 2, 3);  
        }).start();  
        new Thread(() -> {  
            wn.print("c", 3, 1);  
        }).start();  
    }  
}  
  
class WaitNotify {  
    // 循环次数  
    private int loopNumber;  
    // 当前需要打印的线程  
    private int flag;  
  
    public WaitNotify(int loopNumber, int flag) {  
        this.loopNumber = loopNumber;  
        this.flag = flag;  
    }  
  
    /**  
     * @param str  
     * @param waitFlag 当前线程希望的 flag 值  
     * @param nextFlag 打印结束后变更的flag.  
     */    public void print(String str, int waitFlag, int nextFlag) {  
        for (int i = 0; i < loopNumber; i++) {  
            synchronized (this) {  
                // 等待flag变为waitFlag,轮到"我"打印了  
                while (flag != waitFlag) {  
                    try {  
                        this.wait();  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
                // 开始打印  
                System.out.print(str);  
                // 切换到其它线程打印  
                flag = nextFlag;  
                this.notifyAll();  
            }  
        }  
    }  
}
```

### 2.2 使用Lock条件变量实现
>**三个条件变量,一个打印完后指定唤醒另一个,不断循环.**

**思路:**
- 定义AwaitSignal类继承ReentrantLock类,**以便在循环中加锁**.
- `print`方法详解:
	- 先加锁,然后都进入阻塞队列中进行等待.被唤醒后,**执行"打印","唤醒下一个该打印的线程","解锁".**
	- 线程初始状态均被`await()`方法进行阻塞,所以额外定义一个`start(Condition first)`方法来唤醒线程,开始循环打印.
```java
public class AlterExec2 {  
  
    public static void main(String[] args) {  
        AwaitSignal as = new AwaitSignal(5);  
        Condition aWaitSet = as.newCondition();  
        Condition bWaitSet = as.newCondition();  
        Condition cWaitSet = as.newCondition();  
  
        new Thread(() -> {  
            as.print("a",aWaitSet,bWaitSet);  
        }).start();  
        new Thread(() -> {  
            as.print("b",bWaitSet,cWaitSet);  
        }).start();  
        new Thread(() -> {  
            as.print("c",cWaitSet,aWaitSet);  
        }).start();  
  
        as.start(aWaitSet);  
    }  
  
}  
  
class AwaitSignal extends ReentrantLock {  
  
    private int loopNumber;  
  
    public AwaitSignal(int loopNumber) {  
        this.loopNumber = loopNumber;  
    }  
  
    public void start(Condition first){  
	    // 必须先加锁,才能解锁.
        lock();  
        try {  
            first.signal();  
        } finally {  
            unlock();  
        }  
    }  
  
    public void print(String str, Condition curr, Condition next){  
        for (int i = 0; i < loopNumber; i++) {  
            lock();  
			try {  
				// 阻塞,等待唤醒  
				curr.await();  
				System.out.print(str);  
				// 唤醒下一个线程打印  
				next.signal();  
			} catch (InterruptedException e) {  
				e.printStackTrace();  
			} finally {  
				unlock();  
			} 
        }  
    }  
}
```
### 2.3 使用park,unpark实现

**思路:**
- 基本逻辑就是**利用unpark的指定唤醒某个线程**功能.
- 通过`park()`方法使线程阻塞并等待唤醒;被唤醒后执行打印逻辑;打印完后调用`unpark()`唤醒下一个线程进行打印.
```java
public class AlterExec3 {  
    static Thread t1;  
    static Thread t2;  
    static Thread t3;  
    public static void main(String[] args) {  
        ParkUnpark parkUnpark = new ParkUnpark(5);  
  
        t1 = new Thread(() -> {  
            parkUnpark.print("a",t2);  
        },"t1");  
        t2 = new Thread(() -> {  
            parkUnpark.print("b",t3);  
        },"t2");  
        t3 = new Thread(() -> {  
            parkUnpark.print("c",t1);  
        },"t3");  
        t1.start();  
        t2.start();  
        t3.start();  
        LockSupport.unpark(t1);  
    }  
}  
  
class ParkUnpark{  
    private int loopNumber;  
  
    public ParkUnpark(int loopNumber) {  
        this.loopNumber = loopNumber;  
    }  
  
    public void print(String str, Thread next){  
        for (int i = 0; i < loopNumber; i++) {  
            LockSupport.park();  
            System.out.print(str);  
            LockSupport.unpark(next);  
        }  
    }  
}
```