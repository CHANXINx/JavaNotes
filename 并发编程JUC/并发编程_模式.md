# 1. 同步模式之保护性暂停:
## 定义:
Guarded Suspension,在一个线程内等待另一个线程的执行结果.
![[Pasted image 20241020204319.png|500]]
**重点:**
- 适用于单个结果的传递,若是有多个结果,适合用消息队列;
- 两个线程关联同一个GuardedObject;
- JDK中,`join`,`Future`的实现采用的就是此模式.

## 代码
```java
public class GuardedObject {  
    private Object response;  
    static final Object lock = new Object();  
  
    private Object get(){  
        synchronized (lock){  
            // 条件不满足则等待  
            while (response == null){  
                try {  
                    lock.wait(2000);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            return response;  
        }  
    }  
  
    private void complete(Object response){  
        synchronized (lock){  
            if (true){  // 条件满足，通知等待线程  
                this.response = response;  
                lock.notifyAll();  
            }  
        }  
  
    }  
}
```

## 保护性暂停的超时优化:
1. 需要添加等待时间,并且这个等待时间不能是固定的秒数,否则会在循环内不停`wait(time)`,这样最终等待时间肯定会超过传入的timeout.
2. 使用`passTime`来记录等待时间,并与传入的timeout进行比较,若大于,则停止等待.
3. 继续考虑"虚假唤醒"的情况: 例如`wait(2000)`等待2秒的途中被虚假唤醒,然后继续执行,此时`passtime = currenttime-begin`肯定不超过2秒! 之后又重新进入循环,此时`wait(2000)`还是等待2秒,这样等待时间就会超过timeout!
**总结:**
- 经历时间和wait()的等待时间,**都应该参数化**,而不应该是固定的值,以避免虚假唤醒和循环等待的情况.
```java hl:9,14,19
private Object get(long timeout){  
    synchronized (lock){  
        // 开始时间  
        long begin = System.currentTimeMillis();  
        long passTime = 0;  
        // 条件不满足则等待  
        while (response == null){  
            // 经历时间超过等待时间，退出  
            if (passTime >= timeout) {  
                break;  
            }  
            try {  
                // 等待时间参数化，以避免虚假唤醒  
                lock.wait(timeout - passTime);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            // 等待时间.  
            passTime = System.currentTimeMillis() - begin;  
        }  
        return response;  
    }  
}
```

## 多任务版GuardedObject:
![[Pasted image 20241020225411.png|500]]
如果需要在多个类之间使用`GuardedObject`对象,则多个类之间传递对象不太方便,因此设计解耦类Mailboxes,既能解耦"结果等待者"和"结果生成者",还能**支持多个任务管理**.
>**送信人和收信人是一一对应的.**

```java
class Mailboxes {  
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();  
    private static int id = 1;  
  
    // 产生唯一id    
    private static synchronized int generateId() {  
        return id++;  
    }  
	  
    public static GuardedObject getGuardedObject(int id) {
	    // 调用remove方法,既返回GuardedObject对象,同时清除对象,避免占用内存!
        return boxes.remove(id);  
    } 
     
	// 调用createGuardedObject方法的同时会将id自增!
    public static GuardedObject createGuardedObject() {  
        GuardedObject go = new GuardedObject(generateId());  
        boxes.put(go.getId(), go);  
        return go;  
    }  
  
    public static Set<Integer> getIds() {  
        return boxes.keySet();  
    }  
}
```

>**每个People,Postman对象都对应一个线程,所以继承Thread类.**
- People的作用是**收信**,所以需要调用`GuardedObject`的`get`方法来收信.
```java
class People extends Thread{
	@Override
	public void run() {
		// 收信
		GuardedObject guardedObject = Mailboxes.createGuardedObject();
		log.debug("开始收信 id:{}", guardedObject.getId());
		// 获取信,并设置等待时间
		Object mail = guardedObject.get(5000);
		log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
	}
}
```
- Postman的作用是**送信**,所以需要调用`GuardedObject`的`complete`方法来送信.
- 需要id,用来获取对应`GuardedObject`对象,并放入信`mail`(待传递的信息)
```java
class Postman extends Thread {
	private int id;
	private String mail;
	
	public Postman(int id, String mail) {
		this.id = id;
		this.mail = mail;
	}
	
	@Override
	public void run() {
		// 获取GuardedObject对象,用来放信
		GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
		log.debug("送信 id:{}, 内容:{}", id, mail);
		// 放入"信"
		guardedObject.complete(mail);
	}
}
```

**测试:**
```java
public static void main(String[] args) throws InterruptedException {
	for (int i = 0; i < 3; i++) {
		//创建3个收信人,也即3个box: new的同时内部的create方法对MailBoxs的id自增了.
		new People().start();
	}
	Sleeper.sleep(1);
	// 获取所有id->获取所有box-> 送信
	for (Integer id : Mailboxes.getIds()) {
		new Postman(id, "内容" + id).start();
	}
}
```
# 2. 异步模式之生产者/消费者:

