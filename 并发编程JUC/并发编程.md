# 1. 进程与线程
## 1.1 进程与线程
### 进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- **进程就可以视为程序的一个实例。** 大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

### 线程:
- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- **==Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。==** 在 windows 中**进程是不活动的，只是作为线程的容器.**
### 二者对比:
- 进程基本上相互独立的，而**线程存在于进程内，是进程的一个子集**.
- 进程拥有共享的资源，如内存空间等，**供其内部的线程共享**(例如ThreadLocal就是实现共享的)
- 进程间通信较为复杂:
	- 同一台计算机的进程通信称为IPC(Inter-process communication).
	- 不同计算机之间的进程通信，需要**通过网络，并遵守共同的协议**，例如HTTP传输协议.
- 线程通信相对简单，因为它们**共享进程内的内存**，一个例子是**多个线程可以访问同一个共享变量**
- 线程更轻量，**线程上下文切换成本一般上要比进程上下文切换低**

## 1.2 并行与并发
单核 cpu 下，线程实际还是**串行执行**的.操作系统中存在**任务调度器**,将CPU的时间片分放给不同的程序使用,由于CPU的在线程间切换很快(最小为15ms),所以用户无法感受到切换,而是认为任务在并行.
### 并行:
是指在多核CPU下,系统同时开启多个线程,指的是同一时间动手做（doing）多件事情的能力.

### 并发:
并发指的是**线程轮流使用CPU**,是同一时间应对（dealing with）多件事情的能力.

# 2. Java线程

## 2.1 ==创建和运行线程==
### 方法一:直接使用Thread

```java
Thread thread1 = new Thread(){  
    @Override  
    public void run() {  
        log.info("Thread1 Running!");  
    }  
};  
thread1.setName("Thread1");  
thread1.start();  
log.info("Running!");
```
### 方法二:使用Runnable配合Thread(更灵活,更优!)

```Java
    Runnable runnable = new Runnable() {  
        @Override  
        public void run() {  
            log.info("Running");  
        }  
    };  
    Thread thread = new Thread(runnable);  
    thread.setName("MyThread");  
    thread.start();  
}
```
使用Lambda表达式简化:
```java hl:1
Runnable runnable = () -> log.info("Running");  
  
Thread thread = new Thread(runnable);  
thread.setName("MyThread");  
thread.start();
```

### 原理之 Thread 与 Runnable 的关系
>**本质还是调用了Thread类的run方法.**

```java
Thread类:
Thread(~){
	...
	this.target = target;
	...
}

run(){
	if (target != null){
		target.run();
	}
}
```
内部是**将Runnable对象赋值给了Thread的成员变量**,并在run()方法中调用成员变量的run()方法.

### 方法三:FutureTask配合Thread
>FutureTask配合Callable,可以用来处理**有返回结果**的参数.

在这里,==**get()方法会使主线程阻塞,等待"MyThread"线程执行结束返回结果==.**
```java
FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {  
    @Override  
    public Integer call() throws Exception {  
        log.info("Running");  
        return 3+3;  
    }  
});  
Thread thread = new Thread(futureTask,"MyThread");  
thread.start();  
Integer i = futureTask.get();  

log.info("Running");  
log.info("{}",i); // {}占位符.
```
## 2.2 查看进程线程的方法
>**pid即为进程id**
### Windows:
- `tasklist`:查看进程, 可通过`tasklist | findstr xx`来查看xx的进程
![[Pasted image 20241017195120.png]]
- `taskkill -pid xx`:杀死进程id为xx的进程
![[Pasted image 20241017195305.png]]

### Linux:
- `ps -ef | grep xx`:查看进程名为xx的进程信息.
- `kill xx`:杀死进程id为xx的进程.
- `top -H -p xx`:查看xx进程的所有**线程**!
### Java:
- `jps`:查看所有java的进程
![[Pasted image 20241017195912.png]]
- `jstack <pid>`:查看进程id为xx的所有线程的信息.

## ==3.3 线程运行原理==
### 栈与栈帧

### 线程上下文切换:
以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码
- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep、yield、wait、join、park、synchronized、lock `等方法

线程上下文切换后,操作系统需要保存当前线程状态(以便于待会恢复执行),Java中对应的就是"程序计数器"(Program Counter Register),作用是:记住下一条JVM指令的执行地址,使线程私有的.
- **状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等;**
- **线程上下文频繁发生会影响性能**(所以线程数最好不超越CPU核数)

## 3.4 常见方法
### start与run
- 调用run()方法,实质上只是执行了线程t1内部的run()方法. 可以看到,下面的输出中,实际上执行代码的**仍是主线程**.
```java
Thread t1 = new Thread("t1"){  
    @Override  
    public void run() {  
        log.info("running...");  
    }  
};  
t1.run();

OUTPUT:
>> [main] INFO TestStartAndRun - running...

```
- 所以,正确的执行命令应该是先调用`start()`启动新线程,再通过新线程间接执行内部`run()`方法.

### sleep与yield:
#### sleep:
- 调用`sleep(long millis)`,使**当前线程**休眠xx毫秒(在哪个线程中调用,就休眠哪个线程).
	- 此时线程会处于TIMED_WAITING状态.
- 可通过**调用interrupt方法**打断正在睡眠的线程,此时线程会抛出"`InterruptedException`" 异常.
- **睡眠结束后的线程未必会立刻得到执行**,此时还需等待CPU任务调度器分片.
- 建议使用**TimeUnit的sleep方法**,可读性更强.
	- `TimeUnit.SECONDS.sleep(10)`:休眠10秒; `TimeUnit.MINUTES.sleep(1)`:休眠1分钟.

#### yield:
- 调用 yield 会让当前线程**从Running进入Runnable就绪状态**,然后调度执行其它线程.
	- **区分就绪状态与阻塞状态:** 任务调度器可能会分时间片给就绪状态,但不可能分片给阻塞状态.

#### 线程优先级:
- 优先级有三种:`MIN_PRIORITY,MAX_PRIORITY,NORM_PRIORITY`
- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，**调度器可以忽略它**;
- **如果cpu比较忙,那么优先级高的线程会获得更多的时间片**,但cpu闲时 优先级几乎没作用

### join方法详解:
>**`join()`:等待线程运行结束**.
#### 为什么需要join方法:
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	> [main] INFO TestStartAndRun - 开始
	> [Thread-0] INFO TestStartAndRun - 开始
	> [main] INFO TestStartAndRun - 结果为0
	> [main] INFO TestStartAndRun - 结束
```
- 因为线程t1和main线程是并行的,所以main线程查找r的值时,此时r还未被t1线程赋值.

此时可以使用join方法,让**main线程等待t1线程执行结束再执行**.
	用sleep()其实也行,但不准确,因为不知道t1线程具体要执行多久!
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        t1.join();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	[main] INFO TestStartAndRun - 开始
	[Thread-0] INFO TestStartAndRun - 开始
	[main] INFO TestStartAndRun - 结果为10
	[main] INFO TestStartAndRun - 结束
```

#### join等待多个结果的分析:
```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
	});
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}

OUTPUT:(等待2秒)
	> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005
```
- 因为`t1.start()`与`t2.start()`都开启了线程,当`t1.join()`执行时,需要等待t1线程结束(1秒),然后再执行`t2.join()`,注意前面t1与t2是同时开启线程的,所以**只需再等待t2线程1秒**就可以,故最终结果为2秒!
- 若颠倒`t1.join()`与`t2.join()`,仍是2秒,因为等待线程2结束的过程中,线程1已经结束!所以实质上`t1.join()`并未生效,因为已经运行结束.

#### 有时效的join:
`join(long millis)`:若超过`millis`,线程t1仍未结束,则继续执行主线程,不再等待.

### interrupt方法详解:
#### 打断sleep,wait,join的线程:
- 打断sleep,wait,join的线程,**会清空打断状态**,即`isInterrupted()`的值为`false`.
	- 会通过异常的形式通知,即`InterruptedException`.
```bash
java.lang.InterruptedException: sleep interrupted
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
at java.lang.Thread.run(Thread.java:745)
21:18:10.374 [main] c.TestInterrupt - 打断状态: false
```

#### 打断正常运行的线程:
- 打断正常运行的线程,不会清空打断状态.
```
20:57:37.964 [t2] c.TestInterrupt - 打断状态: true
```
- 打断操作只是将`isInterrupted()`置为true,而不会真正打断线程执行!要实现打断线程执行,须在线程内部进行操作.
```java
	boolean interrupted = Thread.currentThread.isInterrupted();
	if (interrupted) break;
```

==**两阶段终止模式:**==
![[Pasted image 20241017235058.png|450]]
```java
public class TestTwoPhaseTermination {  
    public static void main(String[] args) throws InterruptedException {  
	    // 创建监视器对象
		TwoPhaseTermination tpt = new TwoPhaseTermination();  
		// 开始线程,即开始监视.
        tpt.start();  
		// 这期间会监视
        TimeUnit.SECONDS.sleep(2);  
        // 打断
        tpt.stop();  
    }  
  
}  
  
@Slf4j  
class TwoPhaseTermination {  
    private Thread monitor;  
  
    public void start(){  
        monitor = new Thread(() -> {  
	        // while(true)->持续监视
            while (true){  
                Thread currThread = Thread.currentThread();
                // 线程在执行期间被打断.  
                if (currThread.isInterrupted()){  
                    log.info("料理后事");  
                    break;  
                }  
                try {  
                    //睡眠2秒  
                    TimeUnit.SECONDS.sleep(2);  
                    log.info("执行监控记录");  
                } catch (InterruptedException e) {
	                // 线程在阻塞(睡眠时)被打断.  
                    e.printStackTrace();  
                    // 重新设置打断标记为true.  
                    currThread.interrupt();  
                }  
            }  
        });  
        monitor.start();  
    }  
  
    public void stop(){  
        monitor.interrupt();  
    }  
}

```
#### 打断park线程:
`LockSupport.park()`:使当前线程停下,与sleep等具有类似的功能.

`interrupt`打断park线程,不会清空打断状态.

如果此时isInterrupted的结果为true,则再调用`interrupt`,不会打断park线程.
	可通过调用`interrupted()`方法:打断线程的同时将状态设为false.

## 3.5 主线程与守护线程
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，**只要其它非守护线程运行结束了，==即使守护线程的代码没有执行完，也会强制结束==。**

常见的守护线程:
- 垃圾回收器线程;
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求.

## 3.6 线程的五种状态
![[Pasted image 20241018092041.png|450]]
- **初始状态:** 仅是在语言层面创建了线程对象,还未与操作系统线程关联.
- **可运行状态(就绪状态):** 线程已经被创建(已与操作系统线程关联),**可由CPU调度执行.**
- **运行状态:** 已获取CPU时间片,正在运行中的状态;
	- CPU时间片用完后,会继续转换为"可运行状态",导致线程上下文切换.
- **阻塞状态:** CPU不会分配时间片给"阻塞状态",但阻塞状态结束后,CPU会重新分配时间片.
	- 调用了阻塞API,如BIO读写文件.此时线程不会用到CPU,会**切换成"阻塞状态"**;
	- BIO运行结束后,操作系统会唤醒阻塞的线程,切换为"**可运行状态**";
- **终止状态:** 线程已执行完毕,生命周期结束,不会再切换为其它状态.


## 3.7 线程的六种状态
>由Java API层面:Thread.State进行描述的,
![[Pasted image 20241018092439.png|450]]
- **NEW:** 线程被创建,但还未调用`start()`方法;
- **RUNNABLE:** 分为"可运行状态","运行状态"和"阻塞状态",但三者都显示为`RUNNABLE`.
	- **可运行状态:** 等待CPU分配时间片.
	- **运行状态:** 线程正在运行中.
	- **阻塞状态**: 如BIO导致的线程阻塞.
- **BLOCKED:** 可能的情况:加锁,等待获取锁,此时处于BLOCKED状态
- **WAITING:** 调用了join()方法,等待其它线程运行结束.
- **TIMED_WAITING:** 调用了`join(millis)`,`Thread.sleep(millis)`等方法,等待其它线程运行结束,且**带等待时间**.
- **TERMINATED:** 线程代码已结束.

# 4. 共享模型之管程
## 4.1 共享带来的问题
```java
static int counter = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter++;
		}
	}, "t1");
	Thread t2 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter--;
		}
	}, "t2");
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	log.debug("{}",counter);
}
```
- 操作两个线程,分别执行自增和自减操作 => 最后结果大概率不是0.
- **根本原因:** 线程操作静态变量,不是原子性操作,而是先读取静态变量,自增,再重新存入静态变量中.
### 临界区Critical Section:
- 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区
```java
static int counter = 0;
static void increment()
// 临界区
{
counter++;
}
static void decrement()
// 临界区
{
counter--;
}
```
### 竞态条件Race Condition:
多个线程在临界区内执行，由于**代码的执行序列不同而导致结果无法预测**，称之为**发生了竞态条件**

## 4.2 synchronized解决方案
synchronized,即俗称的"对象锁",采用互斥的方式让同一时刻最多只有一个线程能持有"对象锁",其它线程想获取这个对象锁时会被阻塞住.

>**若线程获取了对象锁,而CPU分配的时间片用完了,此时会继续等待,直到再次获取时间片.**
### 语法:
- 不同线程之间要保证获取的是同一个对象锁,即**同一个对象**!
- 若线程1加锁,而线程2没加锁,也是失效的,因为线程2不会被阻塞,仍会继续操作静态变量count.
```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区代码;
}
```

```java
Thread t1 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count++;  
        }  
    }  
},"t1");  
  
Thread t2 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count--;  
        }  
    }  
},"t2");
```

### ==基于面向对象的加锁改进:==
- 把需要保护的共享变量放入一个类中,并使用类对象本身作为锁对象.
```java
class Room{  
    private int count = 0;  
  
    public void increment(){  
        synchronized (this){  
            count++;  
        }  
    }  
    public void decrement(){  
        synchronized (this){  
            count--;  
        }  
    }  
  
    public int getCount() {  
        synchronized (this) {  
            return count;  
        }  
    }  
}
```

## 4.3 方法上的synchronized

### 加在成员方法上:
加在方法上,相当于锁住了this对象,所以有如下改造:
```java
class Test{
	public synchronized void test() {
	
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
		
		}
	}
}
```

```java
public void increment(){  
    synchronized (this){  
        count++;  
    }  
}
```
可改造为:
```java
public synchronized void increment(){  
	count++;  
}
```
### 加在静态方法上:
加在静态方法上,相当于锁住的是类对象.
```java
class Test {  
    public synchronized static void test() {  
    }  
}  
等价于  
  
class Test {  
    public static void test() {  
        synchronized (Test.class) {  
        }  
    }
```

- 锁this对象和锁类对象是并行的.
- 类对象只有一个.

## 4.4 变量的线程安全分析
>**根本还是在于变量是否被共享.**
### 成员变量和静态变量的线程安全问题:
- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
	- 如果只有读操作，则线程安全
	- **如果有读写操作，则这段代码是临界区，需要考虑线程安全**


### 局部变量的线程安全问题:
- 局部变量是线程安全的
- 但局部变量引用的对象则未必
	- 如果该对象没有逃离方法的作用访问，它是线程安全的
	- 如果该对象逃离方法的作用范围，需要考虑线程安全

### 变量线程安全问题的具体分析:
#### **局部变量的线程安全:** 
```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用`test1()`方法时局部变量`i`,==**会在每个线程的栈帧内存中被创建多份**==,因此不存在共享.
操作的都是各自的私有变量i.
![[Pasted image 20241019191157.png|300]]

#### 成员变量的线程安全:
- 此处**会发生线程安全问题**,因为在main方法中,只new了一个`ThreadUnsafe`对象`test`,因此也只有一个`list`成员变量.当有多个线程调用`test`方法时,**操作的都是同一个对象的list成员变量.**
```java hl:2,21
class ThreadUnsafe {  
    ArrayList<String> list = new ArrayList<>();  
    public void method1(int loopNumber) {  
        for (int i = 0; i < loopNumber; i++) {  
            // { 临界区, 会产生竞态条件  
            method2();  
            method3();  
            // } 临界区  
        }  
    }  
    private void method2() {  
        list.add("1");  
    }  
    private void method3() {  
        list.remove(0);  
    }  
}
----

public static void main(String[] args) {  
    ThreadUnsafe test = new ThreadUnsafe();  
    for (int i = 0; i < THREAD_NUMBER; i++) {  
        new Thread(() -> {  
            test.method1(LOOP_NUMBER);  
        }, "Thread" + i).start();  
    }  
}

```

![[Pasted image 20241019191440.png|450]]



将`list`放入method1方法中,作为局部变量.此时,每个线程在调用`method1`时,都会创建自己的`list`对象.
>**局部变量是存储在线程的栈内存中，而每个线程都有自己独立的栈空间。**
```java hl:3
class ThreadSafe {  
    public final void method1(int loopNumber) {  
        ArrayList<String> list = new ArrayList<>();  
        for (int i = 0; i < loopNumber; i++) {  
            method2(list);  
            method3(list);  
        }  
    }  
    private void method2(ArrayList<String> list) {  
        list.add("1");  
    }  
    private void method3(ArrayList<String> list) {  
        list.remove(0);  
    }  
}


```
![[Pasted image 20241019193401.png|400]]

1) **将`method2`和`method3`的方法访问修饰符由private修改为public**:
	- **仍然是线程安全的**,因为`method1`的`list局部变量`是线程内独享的,也没对外暴露.所以即使此时`method2`和`method3`是public,有其他线程调用了,他们访问的也不可能是同一个`list`变量!
2) ==**为ThreadSafe类添加子类,子类重写method2和method3方法**:==
	- **会出现线程安全问题.** 在`method1`执行过程中,`method3`会创建新线程操作`list`变量.由于有多个线程对局部变量`list`进行操作,所以可能会发生先`remove`再`add`的操作.
```java
class ThreadSafeSubClass extends ThreadSafe{
	@Override
	public void method3(ArrayList<String> list) {
		new Thread(() -> {
			list.remove(0);
		}).start();
	}
}
```

**测试代码:**
- `method1`调用时,内部`method3`
```java
public class ThreadSafeTest {  
    public static void main(String[] args) {  
        ThreadSafeSubClass test = new ThreadSafeSubClass();  
        for (int i = 0; i < 2; i++) {  
            new Thread(() -> {  
                test.method1(10);  
            }).start();  
        }  
    }  
}
```
### 常见的线程安全类

>String,StringBuffer,JUC包等...

多个线程调用它们同一个实例的某个方法时，是线程安全的.

#### 线程安全类的方法组合:
线程安全类中的单个方法是原子性的,是线程安全的,**但组合不一定是线程安全的**,如下:
- 多个线程执行以下操作:
	- 线程1和线程2可能同时进行`get()`操作,然后都返回结果null,最终进行了2次put操作.
```java
if( table.get("key") == null) {
	table.put("key", value);
}
```
![[Pasted image 20241019194936.png]]

#### 不可变类的线程安全性:
如String类,Integer类,方法内部的增删改操作实质上都是**返回了一个新的对象**.
```java
public class Immutable{  
    private int value = 0;  
    public Immutable(int value){  
        this.value = value;  
    }  
    public int getValue(){  
        return this.value;  
    }  
    public Immutable add(int v){  
        return new Immutable(this.value + v);  
    }  
}
```
### 线程安全案例分析:

## 4.6 Monitor概念


## 4.7 wait/notify
### 4.7.1 wait/notify的原理

### 4.7.2 API介绍:
>**必须获取锁后 才能调用.**

`obj.wait()`: 让进入 object 监视器的线程到 waitSet 等待
	`obj.wait(long n)`:等待n毫秒后结束等待.
`obj.notify()`: 在 object 上正在 waitSet 等待的线程中随机挑一个唤醒
`obj.notifyAll()`: 让 object 上正在 waitSet 等待的线程全部唤醒

### 4.7.3 正确使用方法
- 使用while循环判断,避免"虚假唤醒".
	- **虚假唤醒:** 线程被唤醒,但是条件仍不成立.
```java
synchronized(lock) {
	while(条件不成立) {
		lock.wait();
	}
	// 干活
}
//另一个线程
synchronized(lock) {
	lock.notifyAll();
}
```
#### sleep()与wait()的区别:
1. sleep是Thread类的方法,wait是Object类的方法;
2. wait需要配合synchronized使用;
3. **sleep在睡眠期间不会释放对象锁,而wait会释放对象锁,进入waitSet等待;**
## 4.8 Join
### 4.8.1 原理
调用者轮询检查线程 alive 状态
```java
synchronized (t1) {
	// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束
	while (t1.isAlive()) {
	t1.wait(0);
	}
}
```

## 4.9 Park & Unpark
### 4.9.1 使用方法:
属于LockSupport类的方法:
`LockSupport.park()`:暂停当前线程:

`LockSupport.unpark(线程对象)`:恢复某个线程的运行.

### 4.9.2 要点:
- `wait，notify 和 notifyAll` 必须配合` Object Monitor`一起使用，而` park，unpark`不必;
- `park & unpark `可以先`unpark`. 即先unpark再park也可以唤醒线程;
- 被park的线程处于`WAITING`状态.
- unpark是以线程为单位进行唤醒的,可以明确指定;而notify只能随机唤醒.

### 4.9.3 原理:

每个线程都有一个Parker对象,由`_counter`,`_cond`和`_mutex`三部分组成.

>调用park方法,实质上就是检查`_counter`是否为0,并置0.
>调用unpark方法,实质上就是置`_counter`为1,并唤醒`_cond`中的线程.
#### 情况1:
**先调用park方法:**
1. 调用park方法,检查`_counter`,发现为0,则获取`_mutex`互斥锁;
2. 线程进入`_cond`条件变量阻塞;
3. 设置`_counter`为0.
**再调用unpark方法:**
1. 调用unpark方法,设置`_counter`为1;
2. 唤醒`_cond`条件变量中的阻塞线程,恢复运行;
3. 设置`_counter`为0

#### 情况2:
**先调用unpark方法:**
1. 调用unpark方法,设置_counter为1;
2. 此时调用park方法,检查`_counter`变量,发现为1,则无需阻塞,继续运行;
3. 设置`_counter`为0.

## 4.10 重新理解线程状态转换
![[Pasted image 20241021154238.png|450]]
### 情况1:NEW->RUNNABLE
调用`t.start()`方法,线程状态由NEW->RUNNABLE.

### 情况2:RUNNABLE<->WAITING
t线程调用了`synchronized(obj)`获取了对象锁:
- 调用`obj.wait()`方法,t线程会从`RUNNABLE->WAITING`;
- 调用`obj.notify()`,`obj.notifyAll()`,`t.Interrupt()`时,线程会被重新唤醒,竞争锁;
	- 竞争锁成功,t线程由`WAITING->RUNNABLE`
	- 竞争锁失败,t线程由`WAITING->BLOCKED`,进入阻塞状态.

### 情况3:RUNNABLE<->WAITING
- 当前线程调用了`t.join()`方法,当前线程由`RUNNABLE->WAITING`,即当前线程等待t线程运行结束.
- t线程运行结束后,或调用了当前线程的`Interrupt()`方法,当前线程由`WAITING->RUNNABLE`.

### 情况4:RUNNABLE<->WAITING
- 当前线程调用了`LockSupport.park()`方法,"可能"会让当前线程由`RUNNABLE->WAITING`
- 当前线程调用了`LockSupport.unpark(目标线程)`或调用了线程的`Interrupt()`方法,会由`WAITING->RUNNABLE`.
### 情况5:RUNNABLE<->TIMED_WAITING
t线程用`synchronized(obj)`获取了对象锁后
- 调用`obj.wait(long n)`方法,t线程由`RUNNABLE->TIMED_WAITING`
- t线程等待时间结束后,或被`notify(),notifyAll(),interrupt()`唤醒后:
	- 竞争锁成功,由`TIME_WAITING->RUNNABLE`
	- 竞争锁失败,由`TIMED_WAITING->BLOCKED`

### 情况6:RUNNABLE<->TIMED_WAITING
- 当前线程调用`t.join(long n)`方法时,当前线程会由`RUNNABLE->TIMED_WAITING`,等待线程t运行结束.
- t线程运行结束,或当前线程等待时间结束后,或当前线程调用`interrupt()`方法时,当前线程会有`TIMED_WAITING->RUNNABLE`

### 情况7:RUNNABLE<->TIMED_WAITING
- 当前线程调用`Thread.sleep(long n)`,会从`RUNNABLE->TIMED_WAITING`
- 睡眠时间结束后,会由`TIME_WAITING->RUNNABLE`

### 情况8:RUNNABLE<->TIMED_WAITING
- 当前线程调用`LockSupport.parkNanos(long nanos)`或`LockSupport.parkUntil(long millis)`时,当前线程会从`RUNNABLE->TIMED_WAITING`.
- 调用`LockSupport.unpark(目标线程)`或调用了线程的`interrupt()`,或是等待超时,会让目标线程从`TIMED_WAITING-> RUNNABLE`
### 情况9:RUNNABLE<->BLOCKED
- t线程用`synchronized(obj)`获取了对象锁时如果竞争失败,从`RUNNABLE->BLOCKED`
- 持`obj`锁线程的同步代码块执行完毕，会唤醒该对象上所有`BLOCKED`的线程**重新竞争**，竞争成功,则由`BLOCKED->RUNNABLE`;失败则继续`BLOCKED`.

### 情况10:RUNNABLE<->TERMINATED
当前线程所有代码运行完毕，进入`TERMINATED`

## 4.11 多把锁
运用更加细粒度的锁来增强程序的并发性.

只有一个对象锁`BigRoom`
```java
class BigRoom {  
    public void sleep() {  
        synchronized (this) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
    public void study() {  
        synchronized (this) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }
}
```
改进:
- 使用多个对象锁`studyRoom`和`bedRoom`来分别锁住不同业务操作.
```java
class BigRoom {  
    private final Object studyRoom = new Object();  
    private final Object bedRoom = new Object();  
  
    public void sleep() {  
        synchronized (bedRoom) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
  
    public void study() {  
        synchronized (studyRoom) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }  
}
```

## 4.12 活跃性

### 4.12.1 死锁
一个线程需要同时获取多把锁，这时就容易发生死锁.
`t1`线程获得A对象锁,接下来想获取B对象的锁; `t2`线程获得B对象锁,接下来想获取A对象的锁,此时就会发生死锁问题: 两个线程分别都想获取对方的锁,都进入阻塞状态,

#### 死锁定位:
1. **利用jps查看java进程:**
![[Pasted image 20241021164632.png]]
2. **利用jstack查看进程状态**:`jstack 8772`
![[Pasted image 20241021164857.png]]

### 4.12.2 活锁
活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束.
**可通过设置随机睡眠时间来解决.** 
```java
public class TestLiveLock {  
    static volatile int count = 10;  
    static final Object lock = new Object();  
  
    public static void main(String[] args) {  
        new Thread(() -> {  
// 期望减到 0 退出循环  
            while (count > 0) {  
                sleep(0.2);  
                count--;  
                log.debug("count: {}", count);  
            }  
        }, "t1").start();  
        new Thread(() -> {  
// 期望超过 20 退出循环  
            while (count < 20) {  
                sleep(0.2);  
                count++;  
                log.debug("count: {}", count);  
            }  
        }, "t2").start();  
    }  
}
```

### 4.12.3 饥饿
一个线程由于优先级太低，**始终得不到 CPU 调度执行**，也不能够结束.


## 4.13 ReentrantLock
>**可用于解决上述的活跃性问题**.

相对于synchronized,具备如下特点:
- **可中断**
- **可以设置超时时间**
- **可以设置为公平锁**
- **支持多个条件变量**
- **都支持可重入**

**基本语法:**
```java
// 获取锁
reentrantLock.lock();
try {
	// 临界区
} finally {
	// 释放锁
	reentrantLock.unlock();
}
```

### 4.13.1 可重入:
可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此**有权利再次获取这把锁**.(可理解为:**未解锁,继续加锁**)
如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住.

**示例:**
- method1已经获取了锁,内部调用method2,`method2`**再次获取锁**,依然能成功,这就是可重入
```java
static ReentrantLock lock = new ReentrantLock();  
public static void main(String[] args) {  
    method1();  
}  
public static void method1() {  
    lock.lock();  
    try {  
        log.debug("execute method1");  
        method2();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method2() {  
    lock.lock();  
    try {  
        log.debug("execute method2");  
        method3();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method3() {  
    lock.lock();  
    try {  
        log.debug("execute method3");  
    } finally {  
        lock.unlock();  
    }  
}
```

### 4.13.2 可打断
>**可用于避免死锁的发生**

等待过程中,可以用`interrupt()`方法打断. 此时需要`lockInterruptibly()`方法加锁.


**示例:**
- t1线程调用`lockInterruptibly()`尝试获取锁,主线程调用`lock()`也获取锁;
- 下面代码执行过程:
	1) 主线程调用`lock.lock()`获取锁,并成功获取;
	2) t1线程启动,内部调用`lock.lockInterruptibly()`也尝试获取锁,但是由于锁已被主线程获取,所以t1线程进入阻塞队列等待;
	3) 调用`t1.interrupt()`打断t1的等待过程;
	4) 成功打断,t1线程捕获`InterruptedException`异常,并return返回,结束等待.
```java
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    try {  
        lock.lockInterruptibly();  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
        log.debug("等锁的过程中被打断");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  

lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(1);  
    t1.interrupt();  
    log.debug("执行打断");  
} finally {  
    lock.unlock();  
}
```

### 4.13.3 锁超时

- 使用`trylock()`方法获取锁,即获取失败立即返回,不会进行等待.
- 使用`trylock(long n,TimeUnits.SECONDS)`方法获取锁, 获取锁失败后会进入阻塞队列等待n秒.
- `trylock()`方法也支持`interrupt()`打断!
**示例:**
```java hl:4-6
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    if (!lock.tryLock()) {  
        log.debug("获取立刻失败，返回");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  
lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(2);  
} finally {  
    lock.unlock();  
}
```

#### 优化哲学家问题:

**优化前获取筷子的逻辑:**
使用`synchronized()`获取筷子(锁),获取不到时就会一直等待; 此时另一个"哲学家"也可能在使用`synchronized()`获取筷子,导致两个哲学家互相等待对方持有的锁,导致死锁问题.
```java
@Override  
public void run () {  
    while (true) {  
        // 获得左手筷子  
        synchronized (left) {  
        // 获得右手筷子  
            synchronized (right) {  
                // 吃饭  
                eat();  
            }  
            // 放下右手筷子  
        }  
        // 放下左手筷子  
    }  
}
```

**优化后的获取筷子逻辑:**
- 使用`trylock()`获取筷子,获取不到则返回!
- 注意使用`finally`保证能释放锁.

执行过程:
- `while(true)`尝试一直获取筷子. 使用两个if判断逻辑: 获取了左筷子,继续尝试获取右筷子,若获取失败,则先释放左筷子,在下一个循环再重新尝试获取左右筷子.
```java
@Override  
public void run() {  
    while (true) {  
        // 尝试获得左手筷子  
        if (left.tryLock()) {  
            try {  
                // 尝试获得右手筷子  
                if (right.tryLock()) {  
                    try {  
                        eat();  
                    } finally {  //释放右筷子
                        right.unlock();  
                    }  
                }  
            } finally {  //释放左筷子
                left.unlock();  
            }  
        }  
    }  
}
```

### 4.13.4 公平锁
>**synchronized锁是不公平锁,因为线程进入阻塞队列等待后,争抢锁时并不按进入队列的先后顺序.**

ReentrantLock默认不公平,但是可通过传入参数来创建公平锁.

```java 
public ReentrantLock(boolean fair) {  
    sync = fair ? new FairSync() : new NonfairSync();  
}
```

### 4.13.5 条件变量

`synchronized`中也有条件变量,就是我们讲原理时那个`waitSet`休息室,当条件不满足时进入`waitSet`等待.

**ReentrantLock支持多个条件变量!** 可很好地避免虚假唤醒.
- `synchronized`是那些不满足条件的线程都在一间休息室等消息
- 而` ReentrantLock `支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

#### 使用要点:
- 使用`lock.newCondition()`创建Condition类的实例对象,即条件变量.
- 调用`await()`方法前需要获取锁.
- 调用`conditionObject.await()`释放锁,并使当前线程进入`conditionObject`进行等待;
- 使用`conditionObject.signal()`来唤醒内部的线程重新竞争lock锁.

```java
static ReentrantLock lock = new ReentrantLock();  
static Condition waitCigaretteQueue = lock.newCondition();  
static Condition waitbreakfastQueue = lock.newCondition();  
static volatile boolean hasCigrette = false;  
static volatile boolean hasBreakfast = false;  
public static void main(String[] args) {  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasCigrette) {  
                try {  
                    waitCigaretteQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的烟");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasBreakfast) {  
                try {  
                    waitbreakfastQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的早餐");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    sleep(1);  
    sendBreakfast();  
    sleep(1);  
    sendCigarette();  
}  
private static void sendCigarette() {  
    lock.lock();  
    try {  
        log.debug("送烟来了");  
        hasCigrette = true;  
        waitCigaretteQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}  
private static void sendBreakfast() {  
    lock.lock();  
    try {  
        log.debug("送早餐来了");  
        hasBreakfast = true;  
        waitbreakfastQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}
```

# 5. 共享模型之内存

## 5.1 Java内存模型
JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

JMM 体现在以下几个方面
- **原子性:** 保证指令不会受到线程上下文切换的影响
- **可见性:** 保证指令不会受 cpu 缓存的影响
- **有序性:** 保证指令不会受 cpu 指令并行优化的影响

## 5.2 可见性
>**一个线程修改了主存数据,对另一个内存不可见.**
### 5.2.1 退不出的循环

#### 问题:
- 即使在后面修改了run的值,也无法使循环退出.
- 若将此处的`sleep(1)`去掉,则循环还是会退出.
```java
static boolean run = true;
public static void main(String[] args) throws InterruptedException {
	Thread t = new Thread(()->{
		while(run){
		// ....
		}
	});
	t.start();
	
	sleep(1); 
	run = false; // 线程t不会如预想的停下来
}
```

#### 分析:
1. 初始状态,t线程从主内存中读取了run的值到工作内存中;
   ![[Pasted image 20241022144719.png|400]]
2. 循环中需要频繁读取run的值,所以**JIT编译器会将run的值缓存到工作内存的高速缓存中**,减少对主存的访问,提高效率;
   ![[Pasted image 20241022144824.png|400]]
3. 1秒后,main线程修改了run的值,并同步至主存. 但此时t线程只从工作内存中读取run的值,所以并不会退出循环.
   ![[Pasted image 20241022145258.png|400]]

#### 解决办法:
- 添加volatile关键字: 用来**修饰成员变量和静态成员变量**，他可以**避免线程从自己的工作缓存中查找变量的值**，**==必须到主存中获取它的值==**，线程操作 volatile 变量都是直接操作主存.
- 还可以使用synchronized关键字,既可以保证原子性,也可以保证可见性,但是操作"较重",性能较低.


## 5.3 有序性
>**JVM在不影响正确性的前提下,可以调整语句的执行顺序.**

### 5.3.1 问题:
- 输出结果可能为4,1,0. 其中**0为指令重排的结果**,即在JIT编译器运行时优化后,`actor2()`方法可能会变成:
  ```java
  public void actor2(I_Result r) {
	ready = true;
	num = 2;
}
  ```

```java
int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
	if(ready) {
		r.r1 = num + num;
	} else {
		r.r1 = 1;
	}
}

// 线程2 执行此方法
public void actor2(I_Result r) {
	num = 2;
	ready = true;
}
```

### 5.3.2 解决办法:
- 使用volatile修饰ready变量,可防止`ready = true`之前的代码被重排序.

## 5.4 volatile原理
volatile 的底层实现原理是**内存屏障**，Memory Barrier（Memory Fence）
- 对volatile变量的**写指令后会加入写屏障**
- 对volatile变量的**读指令前会加入读屏障**

### 5.4.1 可见性和有序性保证
- 写屏障保证在**该屏障之前的**，对共享变量的改动，都**同步到主存当中**,保证了可见性.
- 写屏障会确保指令重排时,**写屏障之前的代码不会重排在写屏障之后**.
```java
public void actor2(I_Result r) {
	num = 2;
	ready = true; // ready 是 volatile 赋值带写屏障
	// 写屏障
}
```

- 读屏障保证在该屏障之后，对共享变量的读取，**加载的是主存中最新数据**
- 读屏障会爆炸指令重排时,读屏障之后的代码不会排在读屏障之前.
```java
public void actor1(I_Result r) {
	// 读屏障
	// ready 是 volatile 读取值带读屏障
	if(ready) {
		r.r1 = num + num;
	} else {
		r.r1 = 1;
	}
}

```

**注意:**
- volatile只能保证有序性和可见性,**无法解决指令交错的问题**.

## 5.5 习题

**实现1:**
```java
// 问题1：为什么加 final 
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例  
public final class Singleton implements Serializable {  
    // 问题3：为什么设置为私有? 是否能防止反射创建新的实例?  
    private Singleton() {}  
    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?  
    private static final Singleton INSTANCE = new Singleton();  
    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由  
    public static Singleton getInstance() {  
        return INSTANCE;  
    }  
    public Object readResolve() {  
        return INSTANCE;  
    }  
}
```
问题1: 防止子类重写方法,导致单例被破坏.



问题5: 1)支持更好的泛型; 2)提供更好的封装性,内部可实现懒惰初始化.

实现2:使用枚举实现单例
```java
// 问题1：枚举单例是如何限制实例个数的
// 问题2：枚举单例在创建时是否有并发问题
// 问题3：枚举单例能否被反射破坏单例
// 问题4：枚举单例能否被反序列化破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做
enum Singleton {
	INSTANCE;
}
```

**问题1:** 
- 字节码:`public final static enum 类名(Singleton); INSTANCE`
**问题2:**
不存在并发问题,静态成员变量在类加载时创建.

问题3:
不能.

问题4:
可避免反序列化破坏.

问题5:
饿汉式,类加载时就创建对象.

问题6:
添加 构造方法.

实现5:
```java
public final class Singleton {  
    private Singleton() { }  
    // 问题1：属于懒汉式还是饿汉式  
    private static class LazyHolder {  
        static final Singleton INSTANCE = new Singleton();  
    }  
    // 问题2：在创建时是否有并发问题  
    public static Singleton getInstance() {  
        return LazyHolder.INSTANCE;  
    }  
}
```

**问题1:**
- 属于懒汉式,因为类加载是懒惰的.类只有在第一次被使用时才会执行类加载操作.


# 6. 共享模型之无锁
## 6.1 CAS与Volatile 
### 介绍与分析:
利用无锁方法实现扣款操作,保证线程安全.
```java hl:7
public void withdraw(Integer amount) {  
    while (true){  
        // 获取余额最新值  
        int prev = balance.get();  
        int next = prev - amount;  
        // 同步到主存  
        if (balance.compareAndSet(prev,next)) break;  
    }  
}
```

**compareAndSet,简称CAS,是原子性操作.**
- 底层是`lcok cmpxchg`指令,单核多核都能保证操作的原子性.
- CAS内部存储值的value使用volatile修饰,因此CAS过程中需要不断**获取主存中的最新值**,所以需要保证可见性.

执行步骤如下图,CAS操作会**在Set操作时获取主存中的最新值进行Compare**,若与CAS中的值不相等,则重新操作,直到CAS中的值与主存最新值相等.
![[Pasted image 20241022231756.png|450]]

### 为什么无锁效率高?
- 简单概括,无锁时线程一直在运行,不停歇;而synchronized会让线程发生上下文切换,成本较高!
- 但是无锁需要CPU的支持,若未成功获取CPU时间片,则仍会发生上下文切换.

### CAS的特点:
- CAS线程一直处于运行阶段,所以需要CPU支持,故适用于线程数少,CPU核数多的情况;
- CAS基于乐观锁思想.
	- synchronized基于悲观锁,上锁防止其它线程更改!
- CAS 体现的是无锁并发、无阻塞并发.
	- **无锁并发:** 不加锁,而是通过不断尝试获取,比较最新值来保证修改的正确性.
	- **无阻塞并发:** 不断尝试,尽量不发生上下文切换,与synchronized的阻塞不同.

## 6.2 原子整数

### AtomicInteger:
`new AtomicInteger(int value)`
- 构造方法,会将`AtomicInteger`类内部的`value`赋值. `private volatile int value;`

`i.getAndIncrement()`
- 相等于i++操作.

`i.increAndget()`
- 相当于++i操作

`i.getAndAdd(int value)`
- 返回i的值,并执行`i=i+value`操作.

`i.addAndGet(int value)`
- 先`i+=value`,再返回更新后的值.

`i.updateAndGet(IntUnaryOperator updateFunction)`
- IntUnaryOperator为函数式接口,可以使用lambda表达式,该函数用法如下:
```
// 表示将i的值*10
i.updateAndGet(x -> x * 10);
```
- `applyAsInt()`方法,传入value,返回计算后的值.
```java
实现:
public static int myUpdateAndGet(AtomicInteger i, IntUnaryOperator operator){  
    while (true){  
        int prev = i.get();  
        int next = operator.applyAsInt(prev);  
        if (i.compareAndSet(prev,next)){  
            return next;  
        }  
    }  
}
```

## 6.3 原子引用
>**AtomicReference,AtomicStampedReference,AtomicMarkableReference**
### ABA问题及解决:
**出现原因:**
- CAS只能感知到变量由A变B,而无法感知变量由A变成B,再变A的情况

**解决办法:**
- 添加版本号:`getStamp()`,并且让变量修改逻辑都**遵循相同的版本号变更规则**.

### AtomicStampedReference:
- 传入期望的版本号以及版本号更新操作.
- 可以看到,A-C的更新失败了,因为获取的版本号是0,而之后main线程进入了阻塞状态,此时t1和t2线程修改了变量,执行了`stamp+1`的版本号更新操作! 故在A->C的更新时,此时版本号已经是2,而传入的`expectedStamped`是0,故更新失败!
```java
@Slf4j  
public class StampedTest {  
    static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A",0);  
  
    public static void main(String[] args) throws InterruptedException {  
        log.info("main start...");  
        // 获取值 A        // 这个共享变量被它线程修改过？  
        String prev = ref.getReference();  
        // 获取版本号  
        int stamp = ref.getStamp();  
        log.info("{}",stamp);  
        other();  
        Thread.sleep(1000);  
        // 尝试改为 C,并增加版本号  
        log.info("{}",stamp);  
        log.info("change A->C {}", ref.compareAndSet(prev, "C",stamp,stamp+1));  
    }  
  
    private static void other() throws InterruptedException {  
        new Thread(() -> {  
            int stamp = ref.getStamp();  
            log.info("{}",stamp);  
            log.info("change A->B {}", ref.compareAndSet(ref.getReference(), "B",stamp,stamp+1));  
        }, "t1").start();  
        Thread.sleep(500);  
  
        new Thread(() -> {  
            int stamp = ref.getStamp();  
            log.info("{}",stamp);  
            log.info("change B->A {}", ref.compareAndSet(ref.getReference(), "A",stamp,stamp+1));  
        }, "t2").start();  
    }  
}
```

```bash 
[main] INFO test.chapter6.StampedTest - main start...
[main] INFO test.chapter6.StampedTest - 0
[t1] INFO test.chapter6.StampedTest - 0
[t1] INFO test.chapter6.StampedTest - change A->B true
[t2] INFO test.chapter6.StampedTest - 1
[t2] INFO test.chapter6.StampedTest - change B->A true
[main] INFO test.chapter6.StampedTest - 0
[main] INFO test.chapter6.StampedTest - change A->C false
```

### AtomicMarkableReference:
>相比于stamped的版本号,markable**只关心是否更改过**.

`compareAndSet(xx,xx,expectedMark,newMark)`:
- 比较传入的`expectedMark`和实际的mark是否相等,相等则更改并返回true.

## 6.4 原子数组
>**AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray**

方法与原子整数AtomicInteger

## 6.5 字段更新器
>**AtomicReferenceFieldUpdater,AtomicIntegerFieldUpdater,AtomicLongFieldUpdater**

利用字段更新器，可以**针对对象的某个域（Field）进行原子操作,只能配合volatile修饰的字段使用**，否则会出现异常.

**获取字段更新器实例:**
`AtomicIntegerFieldUpdater.newUpdater(Class clazz, String fieldName)`

```java
AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(FieldTest.class, "field");  
FieldTest test5 = new FieldTest();  
fieldUpdater.compareAndSet(test5, 0, 10);
```

## 6.6 原子累加器
>LongAdder,DoubleAdder

相较于使用原子整型进行自增操作,效率更高.

性能提升的原因很简单，就是在有竞争时，**设置多个累加单元**，`Therad-0`累加`Cell[0]`，而`Thread-1` 累加`Cell[1]`... 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。

### LongAdder的源码分析:
- transient代表不进行序列化.
```java
// 累加单元数组, 懒惰初始化
transient volatile Cell[] cells;

// 基础值, 如果没有竞争, 则用 cas 累加这个域
transient volatile long base;

// 在 cells 创建或扩容时, 置为 1, 表示加锁
transient volatile int cellsBusy;
```

#### 内部加锁原理:
- 通过标记位lock实现.
```java
LockCas lock = new LockCas();  
new Thread(() -> {  
    log.debug("begin...");  
    lock.lock();  
    try {  
        log.debug("lock...");  
        sleep(1);  
    } finally {  
        lock.unlock();  
    }  
}).start();  
new Thread(() -> {  
    log.debug("begin...");  
    lock.lock();  
    try {  
        log.debug("lock...");  
    } finally {  
        lock.unlock();  
    }  
}).start();
```

#### Cell类介绍:
```java
// 防止缓存行伪共享  
@sun.misc.Contended  
static final class Cell {  
	volatile long value;  
	Cell(long x) { value = x; }  
	// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值  
	final boolean cas(long prev, long next) {  
		return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);  
	}  
	// 省略不重要代码  
}
```
![[Pasted image 20241023161853.png|500]]
- CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率.
- 缓存的加入会造成**数据副本**的产生，即同一份数据会缓存在不同核心的缓存行中;
- CPU 要保证数据的一致性，如果某个CPU核心更改了数据，其它CPU核心对应的整个缓存行必须失效
![[Pasted image 20241023162424.png|500]]
- 因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。
	- Core-0要修改`Cell[0]`
	- Core-1要修改`Cell[1]`
- 无论谁修改成功，都会**导致对方 Core 的缓存行失效**，比如 `Core-0 中 Cell[0]=6000, Cell[1]=8000` 要累加`Cell[0]=6001, Cell[1]=8000`，这时会让 Core-1 的缓存行失效.
- **最终结果会导致效率降低!**

![[Pasted image 20241023162617.png|500]]
- `@sun.misc.Contended `用来解决这个问题，它的原理是在**使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行**，这样，不会造成对方缓存行的失效

#### add()方法源码分析:
 
```java
public void add(long x) {  
    Cell[] cs; long b, v; int m; Cell c;  
    if ((cs = cells) != null || !casBase(b = base, b + x)) {  
        int index = getProbe();  
        boolean uncontended = true;  
        if (cs == null || (m = cs.length - 1) < 0 ||  
            (c = cs[index & m]) == null ||  
            !(uncontended = c.cas(v = c.value, v + x)))  
            longAccumulate(x, null, uncontended, index);  
    }  
}
```
![[Pasted image 20241023164038.png]]

## 6.7 Unsafe
- Unsafe 对象提供了非常底层的，**操作内存、线程**的方法，Unsafe 对象不能直接调用，只能通过反射获得.

### 使用反射获取Unsafe对象:
```java
// 获取theUnsafe成员变量  
Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");  
// 设置可访问  
theUnsafe.setAccessible(true);  
// 获取unsafe对象  
Unsafe unsafe = (Unsafe)theUnsafe.get(null);
```


# 7. 共享模型之不可变

## 7.2 不可变类的设计
### 保护性拷贝
## 7.3 final的原理:
### 设置final变量的原理:

会在赋值语句之后加写屏障,避免在分配空间和实际赋值之间被其他线程读取!
```
0: aload_0
1: invokespecial #1     // Method java/lang/Object."<init>":()V
4: aload_0
5: bipush 20
7: putfield #2          // Field a:I
<-- 写屏障
10: return
```

### 获取final变量的原理
读取加了final变量,会将其**直接复制**到读取该变量的类的**方法栈**中.
若变量超出限制,则会复制到类的常量池栈中.


# 8. 共享模型之工具
## ==8.1 线程池== 

### 8.1.1 自定义线程池:
```java
public class MyThreadPool {  
    // 1. 任务队列  
    private BlockingQueue<Runnable> taskQueue;  
    // 2. 线程集合  
    private HashSet<Worker> workers = new HashSet<>();  
    // 3. 核心线程数  
    private int coreSize;  
    // 4. 获取任务的超时时间  
    private long timeout;  
    private TimeUnit unit;  
  
    public MyThreadPool(int coreSize, long timeout, TimeUnit unit,int queueCapacity) {  
        this.coreSize = coreSize;  
        this.timeout = timeout;  
        this.unit = unit;  
        this.taskQueue = new BlockingQueue<>(queueCapacity);  
    }  
  
    // 执行任务的方法:  
    public void execute(Runnable task){  
        synchronized (workers) {  // HashSet非线程安全，加锁  
            // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行  
            if (workers.size() < coreSize){  
                // 创建线程，传入Runnable对象  
                Worker worker = new Worker(task);  
                // 加入线程集合  
                workers.add(worker);  
                // 启动线程  
                worker.start();  
            }else {  
                // 如果任务数超过 coreSize 时，加入任务队列暂存  
                taskQueue.put(task);  
            }  
        }  
  
    }  
    // 线程类,用于执行线程池中的任务  
    class Worker extends Thread{  
        private Runnable task;  
  
        public Worker(Runnable task) {  
            this.task = task;  
        }  
  
        @Override  
        public void run() {  
            // 用于执行任务：  
            // 1）若task不为空，则直接执行；  
            //while (task != null || (task = taskQueue.take()) != null) {
            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {
                try {  
                    task.run();  
                } catch (Exception e){  
                    e.printStackTrace();  
                }finally {  
                    task = null;  
                }  
            }  
            // 2）若task执行完毕，则从队列中获取待执行的任务  
            synchronized (workers){  
                workers.remove(this);  
            }  
        }  
    }  
}
```

阻塞队列的实现:
```java
class BlockingQueue<T>{  
    private static final Logger log = LoggerFactory.getLogger(BlockingQueue.class);  
    // 1. 任务队列  
    private Deque<T> queue = new ArrayDeque<>();  
    // 2. 锁  
    private ReentrantLock lock = new ReentrantLock();  
    // 3. 生产者等待的条件变量  
    private Condition fullWaitSet = lock.newCondition();  
    // 4. 消费者等待的条件变量  
    private Condition emptyWaitSet = lock.newCondition();  
    // 5. 容量  
    private int capacity;  
  
    public BlockingQueue(int capacity) {  
        this.capacity = capacity;  
    }  
  
    // 6. 阻塞获取  
    public T take(){  
        // 加可重入锁.  
        lock.lock();  
        try {  
            while (queue.isEmpty()){  
                try {  
                    // 队列为空，则进行等待  
                    emptyWaitSet.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            // 获取队首元素  
            T t = queue.removeFirst();  
            emptyWaitSet.signal();  
            return t;  
  
        }finally {  
            //finally块中解锁  
            lock.unlock();  
        }  
    }  
  
    // 6.1 带超时的阻塞获取  
    public T poll(long timeout, TimeUnit unit){  
        // 加可重入锁.  
        lock.lock();  
        try {  
            long nanos = unit.toNanos(timeout);  
            while (queue.isEmpty()){  
                try {  
                    // 超时  
                    if (nanos <= 0){  
                        return null;  
                    }  
  
                    // 队列为空，则进行等待  
                    // awaitNanos会返回剩余时间  
                    nanos = emptyWaitSet.awaitNanos(nanos);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            // 获取队首元素  
            T t = queue.removeFirst();  
            emptyWaitSet.signal();  
            return t;  
  
        }finally {  
            //finally块中解锁  
            lock.unlock();   
        }  
    }  
  
    // 7. 阻塞添加  
    public void put(T element){  
        lock.lock();  
        try {  
            // 队列满了，进行等待  
            while (queue.size() == capacity){  
                try {  
                    fullWaitSet.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            // 等待结束，添加到队尾  
            queue.addLast(element);  
            emptyWaitSet.signal();  
        }finally {  
            lock.unlock();  
        }  
    }  
    // 8. 获取大小  
    public int size(){  
        lock.lock();  
        try{  
            return queue.size();  
        }finally {  
            lock.unlock();  
        }  
    }  
}
```

### 8.1.2 ThreadPoolExcutor
#### 1. 线程池状态
ThreadPoolExecutor 使用 int 的**高 3 位**来表示线程池状态，低 29 位表示线程数量
![[Pasted image 20241024225601.png]]

使用一个整数,而不是两个整数,是为了同时表示两类信息:线程池的运行状态和线程池中**线程的数量**，并且做到**高效的位运算**来**同时(保证了原子性)** 操作这两类信息。
通过二进制位的划分，能够用**位运算来快速判断和修改线程池的状态及线程数**。
```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));
// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
// 直接通过位或获取ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

#### 2. 构造方法
```
public ThreadPoolExecutor(int corePoolSize,
						int maximumPoolSize,
						long keepAliveTime,
						TimeUnit unit,
						BlockingQueue<Runnable> workQueue,
						ThreadFactory threadFactory,
						RejectedExecutionHandler handler)
```
- corePoolSize 核心线程数目 (最多保留的线程数)
- maximumPoolSize 最大线程数目
	- 最大-核心 = 救急线程的数量
- keepAliveTime 生存时间 - 针对救急线程
- unit 时间单位 - 针对救急线程
- workQueue 阻塞队列
- threadFactory 线程工厂 - 可以为线程创建时起个好名字
- handler 拒绝策略

**救急线程的作用**:在阻塞队列满了,核心线程也有在执行的任务时,线程池会创建MAX-CORE个数目的救急线程来执行额外任务. 并且任务执行完毕后,经过生存时间后,救急线程会被销毁,下次需要时再次创建.

**JDK实现的4种拒绝策略:**
1. AbortPolicy: 让调用者抛出 RejectedExecutionException 异常，这是默认策略.
2. CallerRunsPolicy: 让调用者运行任务
3. DiscardPolicy: 放弃本次任务
4. DiscardOldestPolicy: 放弃队列中最早的任务，本任务取而代之
#### 3. newFixedThreadPool
>**适用于任务量已知，相对耗时的任务**
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
	return new ThreadPoolExecutor(nThreads, nThreads,
								0L, TimeUnit.MILLISECONDS,
								new LinkedBlockingQueue<Runnable>());
}
```
- 核心线程数等于最大线程数,所以不会创建救急线程,故也无需生存时间.
- 阻塞队列未传入capacity,所以是无界的.

#### 4. newCachedThreadPool
>**整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程.适合任务数比较密集，但每个任务执行时间较短的情况**

```java
public static ExecutorService newCachedThreadPool() {
	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
								60L, TimeUnit.SECONDS,
								new SynchronousQueue<Runnable>());
}
```

- 核心线程数是0,最大是MAX,则创建出来的全部都是救急线程,且存活时间为60秒.
- SynchronousQueue为同步队列,特点是没有容量,取出后才能放入.

#### 5. newSingleThreadExecutor
>**希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放**

```java
public static ExecutorService newSingleThreadExecutor() {
	return new FinalizableDelegatedExecutorService // 装饰器模式.
		(new ThreadPoolExecutor(1, 1,
								0L, TimeUnit.MILLISECONDS,
								new LinkedBlockingQueue<Runnable>()));
}
```
- 仅有一个核心线程,且无救急线程,任务数多于1后,会进入无界队列排队.(串行执行任务)
- **如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作**
- `Executors.newSingleThreadExecutor()`线程数始终为1,不能修改.
	- FinalizableDelegatedExecutorService 应用的是装饰器模式，**只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法**
- Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改.
	- 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改

#### 6. 提交任务

`void execute(Runnable command)`:
- 执行任务.`execute` 方法提交的任务会占用线程池中的一个线程，并在该任务的所有逻辑（包括内部子任务的同步等待）完成后才会释放该线程

`<T> Future<T> submit(Callable<T> task)`:
- 提交任务task(会占用一个线程)用返回值Future获得任务执行结果,并通过`future.get()`可获取返回值.
- Callable接口也是函数式接口,可用lambda表达式.

```java
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
							throws InterruptedException;
```
- 提交 tasks 中所有任务
- 返回值为`List<Future<T>>`,可使用foreach遍历,并通过`future.get()`取值

```java
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
				throws InterruptedException, ExecutionException;
```
- 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间

#### 7. 关闭线程池

**shutdown**
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但**已提交任务会执行完**
- 此方法不会阻塞调用线程的执行

**shutdownNow**:
线程池状态变为 STOP
- 不会接收新任务
- 会将**队列中的任务返回**,可自行再执行.
- 并用 interrupt 的方式中断正在执行的任务


#### 8. 任务调度线程池
>**ScheduledExecutorService**

Timer也可以实现定时功能,不过缺点是任务都由同一个线程来调度,所以任务都是串行的,同一时间只能有一个任务在执行,并且后一个任务的执行会受前一个任务的延时影响;异常的话,后一个任务甚至不会执行!

使用**ScheduledExecutorService**代替Timer.

```java
ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);  
pool.schedule(() -> {  
    log.debug("start!");  
    try {  
        TimeUnit.SECONDS.sleep(1);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }  
},1, TimeUnit.SECONDS);  
  
pool.schedule(() -> {  
    log.debug("start2!");  
},1,TimeUnit.SECONDS);
```
- **任务1的延时/异常不会影响任务2的执行!**
##### 常用方法:
```
scheduleAtFixedRate(Runnable command,  
					  long initialDelay,  
						  long period,  
					  TimeUnit unit);
```
- 设置固定速率执行某个任务.
- **若任务执行时间大于间隔时间,则会等执行结束立即执行.**

```
scheduleWithFixedDelay(Runnable command,
					 long initialDelay,
					 long delay,
					 TimeUnit unit);
```
- 设置固定延时执行,即等任务1结束后才开始计算延时时间.


##### 定时执行任务:
>**使用`scheduleAtFixedRate()`方法**

```java
// 当前时间  
LocalDateTime now = LocalDateTime.now();  
// 周四的时间  
LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);  
System.out.println(time);  
// 健壮性保证: 保证获取的是之后的周四(而不是固定本周周四)  
if (now.isAfter(time)){  
    time = time.plusWeeks(1);  
}  
System.out.println(time);  
  
long initialDelays = Duration.between(now, time).toMillis();  
  
// 一周的间隔毫秒数  
long period = 7 * 24 * 3600 * 1000;  
ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);  
ScheduledFuture<?> future = pool.scheduleAtFixedRate(() -> {  
    log.debug("run At Thursday");  
}, initialDelays, period, TimeUnit.MILLISECONDS);
```
- 会在每周四的18:00执行一次!


#### 9. 正确处理异常:
1. 在方法块内使用try-catch主动捕获异常;
2. 使用Future对象获取返回的异常:(注意方法上要抛出异常)
```
ExecutorService pool2 = Executors.newFixedThreadPool(1);  
Future<Boolean> f = pool2.submit(() -> {  
    log.debug("task1");  
    int i = 1 / 0;  
    return true;  
});  
log.debug("result:{}", f.get());
```

#### 10. Tomcat线程池
![[Pasted image 20241026003132.png]]![[Pasted image 20241026003546.png]]
提交任务大于核心线程数,且小于最大线程数,此时会创建救急线程来执行任务.

### 8.1.3 Fork/Join
#### 概念
Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，**适用于能够进行任务拆分的cpu密集型运算**

Fork/Join 在分治的基础上加入了多线程，可以**把每个任务的分解和合并交给不同的线程来完成**，进一步提升了运算效率

Fork/Join 默认会创建与 cpu 核心数大小相同的线程池.

#### 使用方法:
>**1. 创建任务对象; 2. 创建线程池执行对象.**

##### 1. 创建任务对象
1) 创建MyTask类继承`RecursiveTask<>`类(带返回值)或`RecursiveAction`(不带返回值);
2) 实现compute()方法,在内部编辑具体的递归计算逻辑;
	- if(xx): 递归到底返回的逻辑
	- 拆分子任务;
	```java
	MyTask t1 = new MyTask(n-1);  
	t1.fork(); //调用线程执行子任务
	```
	- ` t1.join()`:获取返回值.

```java 
class MyTask extends RecursiveTask<Integer>{  
    private int n;  
  
    public MyTask(int n) {  
        this.n = n;  
    }  
  
    @Override  
    protected Integer compute() {  
        // 递归返回条件  
        if (n == 1) {  
            return 1;  
        }  
        // 递归:拆分子任务  
        MyTask t1 = new MyTask(n-1);  
        t1.fork();  
  
        Integer recursiveRes = t1.join();  
        return recursiveRes + n;  
    }  
}
```
##### 2. 创建线程池执行对象
- 创建`ForkJoinPool`对象,调用`invoke(Task<> task)`方法.
```java
@Slf4j  
public class ForkJoinTest {  
    public static void main(String[] args) {  
        ForkJoinPool pool = new ForkJoinPool();  
        Integer res = pool.invoke(new MyTask(5));  
        log.debug("res = {}",res);  
    }  
}  
 ```

##### 3. 拆分任务优化

## 8.2 JUC
### 8.2.1 AQS原理
#### 概述
全称是 AbstractQueuedSynchronizer,是**阻塞式锁**和相关的同步器工具的框架

**特点:**
- 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
	- 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
- 条件变量来实现等待、唤醒机制，**支持多个条件变量**，类似于 Monitor 的 WaitSet

#### 使用方法:

**获取锁:** `tryAcquire()`
```java
// 如果获取锁失败
if (!tryAcquire(arg)) {
// 入队, 可以选择阻塞当前线程 park unpark
}
```

**释放锁:** `tryRelease()`
```java
// 如果释放锁成功
if (tryRelease(arg)) {
// 让阻塞线程恢复运行
}
```

#### 实现不可重入锁
```java
mylock.lock();  
log.debug("locking..");  
mylock.lock();  
log.debug("locking..");
```
- 不可重入,只会打印一次"locking...",第二个`mylock.lock()`会被阻塞.

- 定义锁继承Lock类:
	1. 内部定义同步器类继承AQS抽象类,实现`tryAcquire()`,`tryRelease()`,`isHeldExclusively()`,`newCondition()`四个方法;
	2. MyLock类实现`lock`,`unlock`,`lockInterruptibly`,`newConditon`方法
```java
class MyLock implements Lock {  
  
    private MySync sync = new MySync();  
  
    class MySync extends AbstractQueuedSynchronizer{  
  
        @Override  
        protected boolean tryAcquire(int arg) {  
            if (compareAndSetState(0,1)){  
                //    加锁成功  
                setExclusiveOwnerThread(Thread.currentThread());  
            }  
            return false;  
        }  
  
        @Override  
        protected boolean tryRelease(int arg) {  
            //不需要使用CAS  
            // 注意顺序，避免指令重排  
            setExclusiveOwnerThread(null);  
            setState(0);  //  
            return true;  
        }  
  
        @Override  
        protected boolean isHeldExclusively() {  
            return getState() == 1;  
        }  
  
        public Condition newCondition(){  
            return new ConditionObject();  
        }  
    }  
    // 加锁，不成功则进入等待队列  
    @Override  
    public void lock(){  
        sync.acquire(1);  
    }  
  
    @Override  
    public void lockInterruptibly() throws InterruptedException {  
        sync.acquireInterruptibly(1);  
    }  
  
    @Override  
    public boolean tryLock() {  
        return sync.tryAcquire(1);  
    }  
  
    @Override  
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {  
        return sync.tryAcquireNanos(1,unit.toNanos(time));  
    }  
  
    @Override  
    public void unlock() {  
        sync.release(1);  
    }  
  
    @Override  
    public Condition newCondition() {  
        return sync.newCondition();  
    }  
}
```

### 8.2.2 ReentrantLock原理
#### 非公平锁实现原理

#### 可重入原理
```java hl:14
static final class NonfairSync extends Sync {  
    // ...  
// Sync 继承过来的方法, 方便阅读, 放在此处  
    final boolean nonfairTryAcquire(int acquires) {  
        final Thread current = Thread.currentThread();  
        int c = getState();  
        if (c == 0) {  
            if (compareAndSetState(0, acquires)) {  
                setExclusiveOwnerThread(current);  
                return true;  
            }  
        }  
		// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入  
        else if (current == getExclusiveOwnerThread()) {  
			// state++  
            int nextc = c + acquires;  
            if (nextc < 0) // overflow  
                throw new Error("Maximum lock count exceeded");  
            setState(nextc);  
            return true;  
        }  
        return false;  
    }  
    // Sync 继承过来的方法, 方便阅读, 放在此处  
    protected final boolean tryRelease(int releases) {  
// state--  
        int c = getState() - releases;  
        if (Thread.currentThread() != getExclusiveOwnerThread())  
            throw new IllegalMonitorStateException();  
        boolean free = false;  
// 支持锁重入, 只有 state 减为 0, 才释放成功  
        if (c == 0) {  
            free = true;  
            setExclusiveOwnerThread(null);  
        }  
        setState(c);  
        return free;  
    }  
}
```
- 锁重入,此时`getState()==1`且`getExclusivelyOwnerThread()`为线程本身,操作为将state累加(代表重入次数).
- **重复锁解锁:** 执行`state--`,
	- 只有state的值为0时,才`setExclusivelyOwnerThread = null`;
	- 若state不为0,则返回false,代表释放锁失败?
	- 

#### 可打断原理

##### 不可打断模式:
在此模式下，即使它被打断，**仍会驻留在 AQS 队列中**，一直要等到获得锁后方能得知自己被打断了
```java
	// Sync 继承自 AQSstatic final class NonfairSync extends Sync {  
    // ...  
    private final boolean parkAndCheckInterrupt() {  
	// 如果打断标记已经是 true, 则 park 会失效  
        LockSupport.park(this);  
	// interrupted 会清除打断标记  
        return Thread.interrupted();  
    }  
    final boolean acquireQueued(final Node node, int arg) {  
        boolean failed = true;  
        try {  
            boolean interrupted = false;  
            for (;;) {  
                final Node p = node.predecessor();  
                if (p == head && tryAcquire(arg)) {  
                    setHead(node);  
                    p.next = null;  
                    failed = false;  
// 还是需要获得锁后, 才能返回打断状态  
                    return interrupted;  
                }  
                if (  
					shouldParkAfterFailedAcquire(p, node) &&  
					parkAndCheckInterrupt()  
                ) {  
					// 如果是因为 interrupt 被唤醒, 返回打断状态为 true                   
					interrupted = true;  
                }  
            }  
        } finally {  
            if (failed)  
                cancelAcquire(node);  
        }  
    }  
    public final void acquire(int arg) {  
        if (  
                !tryAcquire(arg) &&  
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg)  
        ) {  
// 如果打断状态为 true            selfInterrupt();  
        }  
    }  
    static void selfInterrupt() {  
// 重新产生一次中断  
        Thread.currentThread().interrupt();  
    }  
}
```

#### 4' 公平锁原理

```java hl:7
// 与非公平锁主要区别在于 tryAcquire 方法的实现  
protected final boolean tryAcquire(int acquires) {  
    final Thread current = Thread.currentThread();  
    int c = getState();  
    if (c == 0) {  
// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争  
        if (!hasQueuedPredecessors() &&  
                compareAndSetState(0, acquires)) {  
            setExclusiveOwnerThread(current);  
            return true;  
        }  
    } else if (current == getExclusiveOwnerThread()) {  
        int nextc = c + acquires;  
        if (nextc < 0)  
            throw new Error("Maximum lock count exceeded");  
        setState(nextc);  
        return true;  
    }  
    return false;  
}
```
- 公平锁通过判断是否有前驱节点来避免竞争. 若有前驱节点,则不会执行加锁语句.'


#### 5' 条件变量实现原理
每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject

##### await 流程
1. 调用`addConditionWaiter()`: 创建新的节点Node,设置状态为-2(等待状态),关联Thread-0,并将节点加入等待队列的尾部;
   ![[Pasted image 20241027202103.png]]
2. 调用`fullyRelease()`: 释放同步器上的锁. 因为是可重入锁,所以需要release多次,然后唤醒(unpark)后继节点来竞争锁.
	- 释放完后,锁的持有线程为null. 
	   ![[Pasted image 20241027202323.png]]

##### signal流程:
Thread-1要唤醒Thread-0
![[Pasted image 20241027202744.png]]

1. `isHeldExclusively()`: 判断锁的持有者是不是该线程(Thread-1).
	- 若不是,则直接抛异常`IllegalMonitorStateException`
	- 若是,则调用`doSignal()`尝试唤醒队首元素;
2. `doSginal()`:通过将Node的前驱和后继节点都置为null,来取得等待队列中的第一个`Node(Thread-0)`; ![[Pasted image 20241027204050.png]]
3. `transferForSignal()`: 将Node加入AQS队列的尾部,将Thread-0的状态设为0,Thread-3的状态设为-1(Thread-0加入前的队列尾元素)
	- 可能转移失败,因为等待队列中的线程可能超时,放弃等待..
4. Thread-1释放锁,进入unlock流程.


### 8.2.3 读写锁
#### ReentrantReadWriteLock
当读操作远远高于写操作时,并且由于**读操作并不涉及数据的修改**,这时候**使用读写锁让`读-读`可以并发**，提高性能。 类似于数据库中的 `select ...from ... lock in share mode`
	但是`读-写`还是要互斥.

##### 示例:
```java hl:5-7
@Slf4j  
class DataContainer {  
    private Object data;  
    // 获取读写锁  
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();  
    private ReentrantReadWriteLock.ReadLock rLock = rwLock.readLock();  
    private ReentrantReadWriteLock.WriteLock wLock = rwLock.writeLock();  
  
    Object read(){  
        // 读取操作加读锁  
        log.debug("尝试获取读锁");  
        rLock.lock();  
        try {  
            log.debug("读取");  
            sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        } finally {  
            log.debug("读锁释放");  
            rLock.unlock();  
        }  
        return data;  
    }  
  
    void write(Object data){  
        log.debug("尝试获取写锁");  
        wLock.lock();  
        try {  
            log.debug("写入");  
            sleep(2000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        } finally {  
            log.debug("写锁释放");  
            wLock.unlock();  
        }  
    }  
}
```

##### 注意事项:
- 读写**不支持**条件变量;
- **重入时升级不支持**:即持有读锁的情况下去获取写锁，会导致获取写锁永久等待
	- 升级指的是读锁->写锁,降级反之.
- **重入时降级支持**：即持有写锁的情况下去获取读锁.

#### 读写锁应用-缓存:
>**缓存操作可能导致数据不一致问题,可通过读写锁来避免.**
##### 更新操作:
```java
public int update(){
	// 先更新数据库
	int update = dao.update(sql,args);
	// 再清除缓存
	map.clear();
	return update;
}
```

使用写锁进行保护:
```java
public int update(){
	wl.lock();
	try{
		// 先更新数据库
		int update = dao.update(sql,args);
		// 再清除缓存
		map.clear();
		return update;
	} finally {
		wl.unlock();
	}
}
```

##### 查询操作:
```java
public T queryOne(Class<T> beanClass, String sql, Object... params) {  
    SqlPair key = new SqlPair(sql, params);  
    // 先查询缓存
	T value = map.get(key);  
	// 若缓存存在，则直接返回缓存中的值
	if (value != null) {  
		return value;  
	}  
	// 缓存为空，查询数据库
	value = genericDao.queryOne(beanClass, sql, params);  
	// 放入缓存
	map.put(key, value);  
	return value;  
}
```

```java
public T queryOne(Class<T> beanClass, String sql, Object... params) {  
    SqlPair key = new SqlPair(sql, params);  
    // 加读锁,保护查询缓存操作,防止其它线程对缓存更改
    rl.lock();
	try {
		T value = map.get(key);  
		if (value != null) {  
			return value;  
		}  
	} finally {
		rl.unlock();
	}
	
	// 加写锁,保护更新缓存操作，防止其它线程对缓存读取和更改
	wl.lock();
	try {
		// 再次查询缓存，多个线程都查询数据库
		//(双重检查,因为某些线程已经查询到了缓存为空,故再次检查,避免多次查询数据库)
		T value = map.get(key);
		// 若缓存为空，则仍需查询数据库，并更新缓存
		if (value == null){
			value = genericDao.queryOne(beanClass, sql, params);  
			map.put(key, value);  
		} //缓存不为空，直接返回数据
		return value;  
	} finally {
		wl.unlock();
	}
}
```

#### 读写锁原理:
读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个.

##### t1 w.lock，t2 r.lock
1. t1加写锁:
	1. 获取锁的状态state,判断是否为0.(但是只能判断加了锁,无法判断是写还是读.)
	2. 若为0,则看CAS操作是否成功,若成功setState,则说明加锁成功,setOwner为当前线程.
		- `writerShouldBlock()`为判断加锁是否阻塞. 若为公平锁,这需要判断等待队列是否为空,若不为空则需要阻塞进行等待; 若为不公平锁,则直接进行竞争.
	3. 若不为0:
		1. 则判断是否加点是写锁/或者当前锁的持有者是否为当前线程,是的话则直接返回加锁失败;
		2. 判断锁的重入次数是否超过最大次数;
		3. `setState(c + acquires)`:可重入锁加锁.
	```java
	@ReservedStackAccess
        protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c); // 获取读锁部分
            if (c != 0) {
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }

	```
2. t2执行加读锁,这时进入读锁的`sync.acquireShared(1)`流程，首先会进入`tryAcquireShared` 流程。如果有写锁占据，那么`tryAcquireShared`返回`-1`表示失败.
	1. ` exclusiveCount(c)!=0&&getExclusiveOwnerThread() != current)`:已经加了写锁,且持有者不是当前线程,则加锁失败.(若加写锁且持有者为当前线程,则可重入,读写并行!)
	2. 判断锁的重入次数是否超过限制;
   ```java
   @ReservedStackAccess
        protected final int tryAcquireShared(int unused) {
            Thread current = Thread.currentThread();
            int c = getState();
            if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)
                return -1;
            int r = sharedCount(c);  // 获取读锁部分
            if (!readerShouldBlock() &&
                r < MAX_COUNT &&
                compareAndSetState(c, c + SHARED_UNIT)) {
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null ||
                        rh.tid != LockSupport.getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                return 1;
            }
            return fullTryAcquireShared(current);
        }
	```
3. 这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于**节点被设置为Node.SHARED 模式而非 `Node.EXCLUSIVE`模式**，注意此时 t2 仍处于活跃状态
   ![[Pasted image 20241027230553.png]]
4. t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁
5. 如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park
   **t2线程在后面等待.**
   ![[Pasted image 20241027231610.png]]

##### t3 r.lock，t4 w.lock
这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子:t3和t4线程在后面等待,且t2和t3的状态为-1.
![[Pasted image 20241027231530.png]]

##### 3' t1 w.unlock
写锁调用`sync.release(1)`方法,`release(1)`调用`tryRelease`方法
```java
public final boolean release(int arg) {  
    if (tryRelease(arg)) {  
        signalNext(head);  
        return true;  
    }  
    return false;  
}
```
1. tryRelease释放成功,则唤醒下一个线程来获取锁.(使用`unpark`唤醒)

```java
@ReservedStackAccess  
protected final boolean tryRelease(int releases) {  
    if (!isHeldExclusively())  
        throw new IllegalMonitorStateException();  
    int nextc = getState() - releases;  
    boolean free = exclusiveCount(nextc) == 0;  
    if (free)  
        setExclusiveOwnerThread(null);  
    setState(nextc);  
    return free;  
}
```
1. 判断锁的持有者是否为当前线程,不是的话则直接抛异常.
2. 锁的`state-1`,然后判断写锁部分是否为0,若为0,则写锁空闲,设置持有者为null;
	- 若`state-1`仍不为0,则只是减少了重入次数,锁仍被持有.
3. 最后返回释放锁是否成功: 只有写锁的state为0时才成功.



##### t2 r.unlock，t3 r.unlock
![[Pasted image 20241027233902.png]]
此时`state==2`,t2解锁会调用`sync.releaseShared(1)`,state的计数-1.
![[Pasted image 20241027234014.png]]
紧接着t3也会调用`sync.releaseShared(1)`让计数-1,此时计数为0,进入`doReleaseShared()`将头节点从-1改为0,并唤醒后驱节点.
![[Pasted image 20241027234129.png]]
t4线程被唤醒后,由于前面没有节点与其竞争,故`tryAcquire(1)`会成功,修改头节点,流程结束.
![[Pasted image 20241027234231.png]]


#### StampedLock
该类自 JDK 8 加入，是为了**进一步优化**读性能，它的特点是在**使用读锁、写锁时都必须配合【戳】使用**

**读锁使用:**
```java
long stamp = lock.readLock();
lock.unlockRead(stamp);
```

**写锁使用:**
```java
long stamp = lock.writeLock();
lock.unlockWrite(stamp);
```

**读锁的优化:乐观读:** StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 **戳校验**(`validate(stamp)`),如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。
	● 不支持可重入和条件变量
```java
long stamp = lock.tryOptimisticRead(); //此时并未加锁.
// 验戳
if(!lock.validate(stamp)){
	// 锁升级
}
```

##### 应用-使用StampedLock保护数据容器类
```java
@Slf4j  
class DataContainerStamped {  
    private int data;  
    private StampedLock lock = new StampedLock();  
  
    public DataContainerStamped(int data) {  
        this.data = data;  
    }  
  
    public int getData() {  
        return data;  
    }  
  
    public int read(){  
        long stamp = lock.tryOptimisticRead();  
        log.debug("乐观读锁:{}",stamp);  
        try {  
            TimeUnit.SECONDS.sleep(2);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        if (lock.validate(stamp)){  
            // 校验通过  
            log.debug("读取完成:{}",stamp);  
            return data;  
        }  
  
        log.debug("乐观读升级:{}",stamp);  
        stamp = lock.readLock();  
        try {  
            log.debug("读锁:{}",stamp);  
            TimeUnit.SECONDS.sleep(2);  
            log.debug("读取完成:{}",stamp);  
            return data;  
        } catch (InterruptedException e){  
            e.printStackTrace();  
        } finally {  
            log.debug("读锁解锁:{}",stamp);  
            lock.unlockRead(stamp);  
        }  
        return 0;  
    }  
  
    public void write(int newData){  
        long stamp = lock.writeLock();  
        log.debug("加写锁:{}",stamp);  
        try {  
            TimeUnit.SECONDS.sleep(2);  
            this.data = newData;  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        } finally {  
            log.debug("解写锁:{}",stamp);  
            lock.unlockWrite(stamp);  
        }  
    }  
}
```

```
09:19:13.300 [t1] DEBUG test.chapter8.DataContainerStamped - 乐观读锁:256
09:19:13.300 [t2] DEBUG test.chapter8.DataContainerStamped - 加写锁:384
09:19:15.309 [t2] DEBUG test.chapter8.DataContainerStamped - 解写锁:384
09:19:15.309 [t1] DEBUG test.chapter8.DataContainerStamped - 乐观读升级:256
09:19:15.309 [t2] DEBUG test.chapter8.StampedLockTest - data:5
09:19:15.309 [t1] DEBUG test.chapter8.DataContainerStamped - 读锁:513
09:19:17.313 [t1] DEBUG test.chapter8.DataContainerStamped - 读取完成:513
09:19:17.313 [t1] DEBUG test.chapter8.DataContainerStamped - 读锁解锁:513
09:19:17.313 [t1] DEBUG test.chapter8.StampedLockTest - data:5
```
乐观读时获取的stamp为256,此时写锁把stamp改为了384,所以乐观读会验戳失败.此时写锁持有锁,进行写操作. 等到写锁释放后,乐观读升级为读锁,进行读操作.

### 8.2.4 Semaphore
信号量，用来**限制能同时访问共享资源的线程上限**。
	● ReentrantLock等都是**独占**锁.

#### 使用方法:
**创建对象:**
`Semaphore semaphore = new Semaphore(int permits)`
- 创建上限为permits的信号量对象.

**加锁:**
`semaphore.acquire()`

**解锁:**
`semaphore.release()`

#### 应用:
- 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它**只适合限制单机线程数量**，并且**仅是限制线程数**，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）
- Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的

```java
public Pool(int poolSize){
	...
	// 让许可数与资源数一致
	this.semaphore = new Semaphore(poolsize);
	...
}

// 5. 借连接  
public Connection borrow() {// t1, t2, t3  
	// 获取许可  
    try {  
        semaphore.acquire(); // 没有许可的线程，在此阻塞等待  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }  
    for (int i = 0; i < poolSize; i++) {  
	// 获取空闲连接  
        if(states.get(i) == 0) {  
            if (states.compareAndSet(i, 0, 1)) {  
                log.debug("borrow {}", connections[i]);  
                return connections[i];  
            }  
        }  
    }  
	// 不会执行到这里  
    return null;  
}  
// 6. 归还连接  
public void free(Connection conn) {  
    for (int i = 0; i < poolSize; i++) {  
        if (connections[i] == conn) {  
            states.set(i, 0);  
            log.debug("free {}", conn);  
            semaphore.release();  
            break;  
        }  
    }  
}
```
#### 原理:
`new Semaphore(permits)`的原理就是`setState(3)`:
![[Pasted image 20241028100410.png]]
之后若有线程获取锁,则`state-1`直到`state==0`,此时后面的线程进入AQS队列阻塞等待(park).
![[Pasted image 20241028100530.png]]
当有线程释放连接后,`state+1`,并且会唤醒后面的线程来竞争锁,此时Thread-0竞争成功,则`state-1`又变回0,Thread-3获取`state==0`,又进入park状态,回到AQS队列中阻塞等待.
![[Pasted image 20241028101134.png]]
### 8.2.5 CountdownLatch
用来进行**线程同步协作**，等待所有线程完成倒计时。

#### 使用方法:
```java
@Slf4j  
public class CountDownLatchTest {  
    public static void main(String[] args) throws InterruptedException {  
        CountDownLatch latch = new CountDownLatch(3);  
  
        new Thread(() -> {  
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            log.debug("线程t1运行");  
            latch.countDown();  
        },"t1").start();  
        new Thread(() -> {  
            try {  
                Thread.sleep(1500);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            log.debug("线程t2运行");  
            latch.countDown();  
        },"t2").start();  
        new Thread(() -> {  
            try {  
                Thread.sleep(2000);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            log.debug("线程t3运行");  
            latch.countDown();  
        },"t3").start();  
  
        // 主线程等待countdown  
        log.debug("主线程等待");  
        latch.await();  
        log.debug("countdown为0，结束等待!");  
    }  
}
```

```
10:54:09.162 [main] DEBUG test.chapter8.CountDownLatchTest - 主线程等待
10:54:10.174 [t1] DEBUG test.chapter8.CountDownLatchTest - 线程t1运行
10:54:10.673 [t2] DEBUG test.chapter8.CountDownLatchTest - 线程t2运行
10:54:11.175 [t3] DEBUG test.chapter8.CountDownLatchTest - 线程t3运行
10:54:11.175 [main] DEBUG test.chapter8.CountDownLatchTest - countdown为0，结束等待!
```
- 只有在count计数减为0时,await()才会停止阻塞.
#### 应用-同步等待多线程准备完毕
```java
public static void main(String[] args) throws InterruptedException {  
    CountDownLatch latch = new CountDownLatch(10);  
    ExecutorService pool = Executors.newFixedThreadPool(10);  
    Random r = new Random();  
    String[] all = new String[10];  
  
    for (int i = 0; i < 10; i++) {  
        int k = i;  
        pool.submit(() -> {  
            for (int j = 0; j <= 100; j++) {  
                // 随机睡眠，模拟加载延迟  
                try {  
                    Thread.sleep(r.nextInt(100));  
                } catch (InterruptedException e) {  
                    throw new RuntimeException(e);  
                }  
                all[k] = j + "%";  
                //System.out.println(all[i]);  
                System.out.print("\r" + Arrays.toString(all));  
            }  
            latch.countDown();  
        });  
  
    }  
    latch.await();  
    System.out.println("\n游戏开始");  
}
```

### 8.2.6 CyclicBarrier
>**相当于可重用的CountDownLatch**,不过Barrier是累加.

循环栅栏，用来进行线程协作，**等待线程满足某个计数**。构造时设置『计数个数』,通过`barrier.await()`进行阻塞等待并使计数累加,当计数满足条件时,**队列中等待的线程同步执行**.
	● CountDownLatch的计数只能减,不能加,故不能重用. 每一次使用都需要创建新的   CountDownLatch对象.

#### 使用方法:
`CyclicBarrier barrier = new CyclicBarrier(3,()->{task})`
- 创建一个"计数个数为3"的Barrier对象,并可以在计数满足时执行task任务

`barrier.await()`
- 调用barrier阻塞等待,并使计数+1. (只有当计数到达3时,才同步运行)

### 8.2.7 线程安全集合类概述
![[Pasted image 20241028131605.png]]
#### J.U.C安全集合
- Blocking大部分实现基于锁,并提供用于阻塞的方法;
- CopyOnWrite容器修改开销相对较重,适用于读多写少的场景;
- **Concurrent 类型的容器:**
	- 内部使用CAS优化,可提供较高吞吐量;
	- 弱一致性:(高吞吐量带来缺点)
		- 遍历时弱一致性.
			- (利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的)
		- 求大小弱一致性，size 操作未必是 100% 准确
		- 读取弱一致性
### 8.2.8 ConcurrentHashMap

#### 使用:
`computeIfAbsent(key,)`


#### 原理:
##### HashMap并发死链:

##### 重要属性和内部类:
```java
// 默认为 0// 当初始化时, 为 -1// 当扩容时, 为 -(1 + 扩容线程数)  
// 当初始化或扩容完成后，为 下一次的扩容的阈值大小  
private transient volatile int sizeCtl;  

// 整个 ConcurrentHashMap 就是一个 Node[]
static class Node<K,V> implements Map.Entry<K,V> {}  

// hash 表  
transient volatile Node<K,V>[] table;  

// 扩容时的 新 hash 表  
private transient volatile Node<K,V>[] nextTable;  

// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点  
static final class ForwardingNode<K,V> extends Node<K,V> {}  

// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node
static final class ReservationNode<K,V> extends Node<K,V> {}  

// 作为 treebin 的头节点, 存储 root 和 first
static final class TreeBin<K,V> extends Node<K,V> {}  

// 作为 treebin 的节点, 存储 parent, left, right
static final class TreeNode<K,V> extends Node<K,V> {}
```
- treebin,是使用**红黑树结构**优化Map的链表结构,避免在链表过长时查找效率过低(`O(n)->O(logn)`)
	- 当**单个桶(数组槽位)中的链表长度超过阈值**(默认是8),且HashMap的总容量超过**最小数组容量阈值(默认为64)**,HashMap才会将链表转换为红黑树结构.
	- 当当红黑树中的节点数量减少到6或更少时,会将红黑树重新转换为链表,节省空间.

##### 构造器分析:
```java
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {  
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)  
        throw new IllegalArgumentException();  
    if (initialCapacity < concurrencyLevel) // Use at least as many bins  
        initialCapacity = concurrencyLevel; // as estimated threads  
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);  
	// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ...    
	int cap = (size >= (long)MAXIMUM_CAPACITY) ?  
		MAXIMUM_CAPACITY : tableSizeFor((int)size);  
    this.sizeCtl = cap;  
}
```
- 实现了**懒惰初始化**,构造器中只计算了table大小,只有真正使用时才会第一次创建. 
- `初始容量 = tableSizeFor[(用户传入的容量/负载因子 + 1)]`,其中tableSizeFor为将size变为2的n次方.

##### get()方法流程:
```java
public V get(Object key) {  
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;  
	// spread 方法能确保返回结果是正数  
    int h = spread(key.hashCode());  
    if ((tab = table) != null && (n = tab.length) > 0 &&  
		(e = tabAt(tab, (n - 1) & h)) != null) {  
		// 如果头结点已经是要查找的 key        
		if ((eh = e.hash) == h) {  
			if ((ek = e.key) == key || (ek != null && key.equals(ek)))  
				return e.val;  
		}  
		// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找  
        else if (eh < 0)  
            return (p = e.find(h, key)) != null ? p.val : null;  
		// 正常遍历链表, 用 equals 比较  
        while ((e = e.next) != null) {  
            if (e.hash == h &&  
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))  
                return e.val;  
        }  
    }  
    return null;  
}
```
- **计算哈希值**：通过 `spread` 方法计算键的哈希值 `h`，确保哈希值均匀分布。
- **快速定位桶位置**：
    - 使用 `(n - 1) & h` 定位键在哈希表 `table` 中对应的桶位置，获取首个节点 `e`。
    - `table` 是一个包含多个桶的数组，每个桶可能是链表或红黑树的头节点。
- **检查首个节点**：
    - 如果首节点 `e` 的哈希值和键匹配（即 `e.hash == h`），并且键值相等，则直接返回 `e.val`
    - 如果 `e.hash < 0`（例如 `-1` 表示树化节点），则调用 `find` 方法，在红黑树或其他结构中查找目标键并返回值。
- **遍历链表**：
    - 如果 `e` 不是目标节点且没有树化，则 `get` 方法会遍历桶中的链表节点，逐一比对键，直到找到匹配项并返回其值。
- **返回结果**：如果遍历结束仍未找到匹配的键，则返回 `null`。

##### put()方法流程分析:
##### initTable()流程分析:
```java
private final Node<K, V>[] initTable() {  
    Node<K, V>[] tab;  
    int sc;  
    while ((tab = table) == null || tab.length == 0) {  
        if ((sc = sizeCtl) < 0)  
            Thread.yield();  
		// 尝试将 sizeCtl 设置为 -1（表示初始化 table）  
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {  
			// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建  
            try {  
                if ((tab = table) == null || tab.length == 0) {  
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;  
                    Node<K, V>[] nt = (Node<K, V>[]) new Node<?, ?>[n];  
                    table = tab = nt;  
                    // 计算下次扩容时的阈值.
                    sc = n - (n >>> 2);  
                }  
            } finally {  
                sizeCtl = sc;  
            }  
            break;  
        }  
    }  
    return tab;  
}  
```
- 哈希表的懒惰初始化,在put方法中被调用.
- 使用CAS保证只有一个线程能创建哈希表.

##### size计算流程:
size 计算实际发生在 put，remove 改变集合元素的操作之中
- 没有竞争发生，向 baseCount 累加计数
- 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数
	- counterCells 初始有两个 cell
	- 如果计数竞争比较激烈，会创建新的 cell 来累加计数
- 最后的总数为`baseCount+counterCells`
```java hl:9
public int size() {  
    long n = sumCount();  
    return ((n < 0L) ? 0 :  
            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :  
                    (int)n);  
}  
final long sumCount() {  
    CounterCell[] as = counterCells; CounterCell a;  
	// 将 baseCount 计数与所有 cell 计数累加  
    long sum = baseCount;  
    if (as != null) {  
        for (int i = 0; i < as.length; ++i) {  
            if ((a = as[i]) != null)  
                sum += a.value;  
        }  
    }  
    return sum;  
}
```

##### 总结:
- 初始化，使用 cas 来保证并发安全，懒惰初始化 table
- 树化，当 table.length < 64 时，先尝试扩容，超过 64 时，并且 bin.length > 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头
- put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部
- get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索
- 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中
- size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可

#### ConcurrentHashMap-JDK7源码分析

##### 构造器分析:
维护了一个 segment 数组，每个 segment 对应一把锁
- **优点：** 如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的
- **缺点：** Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化
	- 会导致浪费内存,并且并发度高时,锁不够用.

#### LinkedBlockingQueue源码分析
##### 加锁分析:
>**使用了两把锁+dummy节点**

两把锁,使得同一时刻允许两个线程(生产者和消费者)同时执行
- 注意,消费者和消费者,生产者和生产者仍然串行(互斥).

**线程安全分析:**
- 节点总数大于2时(包括dummy节点在内),putLock锁住队尾,保证last节点的线程安全;takeLock锁住队头,保证head节点的安全. 两把锁保证了入队和出队没竞争.
- 节点总数=2时(dummy和正常节点),仍然是两把锁锁住两个对象,避免竞争.
	- 由于dummy节点的存在,所以此时不会两把锁锁住同一节点对象.
- 节点总数=1时(只有dummy节点),此时**take线程会被notEmpty条件阻塞**,避免了锁住同一节点.

##### put()方法源码分析:
```java
public void put(E e) throws InterruptedException {  
	// 不允许放入空指针
    if (e == null) throw new NullPointerException();  
    int c = -1;  
    Node<E> node = new Node<E>(e);  
    // 获取put锁
    final ReentrantLock putLock = this.putLock;  
	// count 用来维护元素计数(队列中元素个数)
    final AtomicInteger count = this.count;  
    // 加可打断锁
    putLock.lockInterruptibly();  
    try {  
		// 满了等待  
        while (count.get() == capacity) {  
			// 阻塞等待队列空出位置    
			notFull.await();  
        }  
		// 有空位, 入队且计数加一  
        enqueue(node);  
        // 将count赋值给c,并自增.
        c = count.getAndIncrement();  
		// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程 (避免不必要竞争) 
		// 由刚入队的线程唤醒其他put线程
        if (c + 1 < capacity)  // <代表入队后仍有空位.
            notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
	// c == 0 表示队列之前是空的，此时需要通知`take`线程可以消费
    if (c == 0)  
		// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争  
        signalNotEmpty();  
}
```

#### ArrayBlockingQueue与LinkedBlockingQueue的比较:
- Linked 支持有界，Array 强制有界
- Linked 实现是链表，Array 实现是数组
- Linked 是懒惰的，而 Array 需要提前初始化 Node 数组
- Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的
- Linked 两把锁，Array 一把锁

### 8.2.10 ConcurrentLinkedQueue
- 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行
- dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争
- 锁使用了CAS实现,因此有更高的性能.

### 8.2.11 CopyOnWriteArrayList
>**适合读多写少的场景**.

底层实现采用了"**写入时拷贝**"的思想，**增删改操作会将底层数组拷贝一份**,**更改操作在新数组上执行**，这时不影响其它线程的并发读，读写分离。 以新增为例：
- 读取操作不加锁.
```java
public boolean add(E e) {
		synchronized (lock) {
		// 获取旧的数组
		Object[] es = getArray();
		int len = es.length;
		// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）
		es = Arrays.copyOf(es, len + 1);
		// 添加新元素
		es[len] = e;
		// 替换旧的数组
		setArray(es);
		return true;
	}
}
```

存在弱一致性(Weak Consistency),即在并发环境下，读操作可能无法立即看到写操作（包括增、删、改）的最新数据.




# 9\` Synchronized进阶原理

## 9.1 轻量级锁
轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但**加锁的时间是错开的**（也就是没有竞争），那么可以使用轻量级锁来优化。

轻量级锁**对使用者是透明的**，即语法仍然是`synchronized`.

```java
static final Object obj = new Object();
public static void method1() {
	synchronized( obj ) {
		// 同步块 A
		method2();
	}
}
public static void method2() {
	synchronized( obj ) {
	// 同步块 B
	}
}
```
方法1加obj对象锁,在方法块内部调用method2,也加obj对象锁,

### 加锁流程:
1. 创建锁记录(Lock Record)对象,每个线程的栈帧中都包含一个锁记录的机构,内部可以存储锁定对象的Mark Word;
   ![[Pasted image 20241029145600.png]] 
2. 让锁记录中的Object Reference指向锁对象,并用CAS替换Object中的Mark Word,交换二者的MakWord值.
   ![[Pasted image 20241029145725.png]] 
3. CAS替换成功,则对象头中会存储锁记录地址和状态00,表示该线程已给对象加锁.
   ![[Pasted image 20241029151049.png]]
4. 若CAS失败,则可能为:
	- 若对象的MarkWord为00,代表已有其他线程加了轻量级锁,这时表明有竞争,进入**锁膨胀**过程.
	- 如果Thread-0再次加锁,则执行了synchronized**锁重入**,会新增一条锁记录,并且MarkWord为null,表明为锁重入.
	  ![[Pasted image 20241029151121.png]]
5. 当解锁时,若MarkWord为null,则直接删除锁记录; 若MarkWord不为null,则执行CAS操作将MarkWord恢复给对象头.
	- CAS成功,则解锁成功.
	- CAS失败,说明**轻量级锁进行了锁膨胀或已经升级为重量级锁**，进入重量级锁解锁流程.

## 9.2 锁膨胀
当Thread-1尝试为对象obj加上轻量级锁时,执行CAS交换MarkWord失败,则可能是Thread-0已为对象obj加了轻量级锁,则此时需要进行锁膨胀,**将轻量级锁升级为重量级锁**.

1. Thread-1向Obj对象加锁,执行CAS操作时,发现obj的MarkWord已为00,说明已有其他线程为对象obj加了轻量级锁;
   ![[Pasted image 20241029151856.png]]
2. Thread-1加锁失败,则会进入锁膨胀过程:
	1. 为Obj对象申请Monitor锁,让Obj指向重量级锁地址(LockRecord地址->Monitor地址);
	2. Thread-1进入Monitor的EntryList中阻塞等待.
	   ![[Pasted image 20241029152312.png]]
3. Thread-0执行解锁操作时,执行CAS操作恢复MarkWord的值会失败,然后进入Monitor的重量级解锁流程:
	1. 按照Monitor地址找到Monitor对象,**设置Owner为null**;
	2. **唤醒EntryList中的阻塞线程**进行锁竞争.

### 9.3 自旋优化
**重量级锁竞争**的时候，还可以使用**自旋来进行优化**，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞.

原理就是通过多次循环尝试获取锁,等待线程释放锁,避免上下文切换的发生.

**自旋重试成功示例:**
- 在自旋重试过程中,线程1释放锁,对象变成无锁状态.
![[Pasted image 20241029153410.png|550]]

**自旋重试失败示例:**
- 自旋过程结束,线程1仍未释放锁.
![[Pasted image 20241029153546.png|550]]
## 9.4 偏向锁:
轻量级锁在没有竞争时（就自己这个线程），**每次重入仍然需要执行 CAS 操作**。

Java 6 中引入了偏向锁来做进一步优化：第一次使用CAS将线程 ID 设置到对象的`Mark Word`头，**之后发现这个线程 ID 是自己的就表示没有竞争,不用重新CAS**。以后只要不发生竞争，这个对象就归该线程所有

**使用偏向锁对轻量锁的重入进行优化:**
1. 第一次加锁时,将ThreadID设置到对象的MarkWord头上
2. 后续锁重入时,若判断对象头上的ThreadID为自己,则无需进行CAS操作.
![[Pasted image 20241029154510.png]]

### 9.4.1 偏向状态 
偏向锁与轻量锁区分在于 1)biased_lock的状态为1; 2)偏向锁前54位存储的是线程ID
![[Pasted image 20241029155359.png]]一个对象创建时：
- 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即**最后 3 位为 101**，这时它的thread、epoch、age 都为 0
- 偏向锁是**默认是延迟的**，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数`-XX:BiasedLockingStartupDelay=0` 来禁用延迟
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即**最后 3 位为 001**，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值
- 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中,直到其它线程再对该对象加锁.

### 9.4.2 偏向锁的撤销
1. 若调用对象的hashCode,**则会导致偏向锁被撤销**.因为偏向锁的线程id占用前54位,而hashCode会占用31位,所以需要撤销偏向锁来获取空间存储hashCode.
	- 轻量级锁会在锁记录中记录 hashCode
	- 重量级锁会在 Monitor 中记录 hashCode
	- 轻量级锁和重量级锁不会撤销.

2. 其他线程使用偏向锁对象,也会**导致偏向锁升级为轻量级锁**. 可以看到,其他线程对对象加锁后,MarkWord后三位由`101 -> 000 -> 001`, 000即为轻量级锁.
   ```java
    [t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101
	[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101
	[t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000
	[t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
	```

3. 调用WaitNotify,也会导致撤销. 因为wait/notify只有重量级锁才有.

### 9.4.3 批量重偏向
如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会**重新偏向 T2**，重偏向会重置对象的 Thread ID

当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时**重新偏向至加锁线程**

### 9.4.4 批量撤销
当**撤销偏向锁超过 40 次**后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是**整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的**

## 9.5 锁消除
JIT即时编译器对代码进行优化.
