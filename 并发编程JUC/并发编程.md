# 1. 进程与线程
## 1.1 进程与线程
### 进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- **进程就可以视为程序的一个实例。** 大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

### 线程:
- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- **==Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。==** 在 windows 中**进程是不活动的，只是作为线程的容器.**
### 二者对比:
- 进程基本上相互独立的，而**线程存在于进程内，是进程的一个子集**.
- 进程拥有共享的资源，如内存空间等，**供其内部的线程共享**(例如ThreadLocal就是实现共享的)
- 进程间通信较为复杂:
	- 同一台计算机的进程通信称为IPC(Inter-process communication).
	- 不同计算机之间的进程通信，需要**通过网络，并遵守共同的协议**，例如HTTP传输协议.
- 线程通信相对简单，因为它们**共享进程内的内存**，一个例子是**多个线程可以访问同一个共享变量**
- 线程更轻量，**线程上下文切换成本一般上要比进程上下文切换低**

## 1.2 并行与并发
单核 cpu 下，线程实际还是**串行执行**的.操作系统中存在**任务调度器**,将CPU的时间片分放给不同的程序使用,由于CPU的在线程间切换很快(最小为15ms),所以用户无法感受到切换,而是认为任务在并行.
### 并行:
是指在多核CPU下,系统同时开启多个线程,指的是同一时间动手做（doing）多件事情的能力.

### 并发:
并发指的是**线程轮流使用CPU**,是同一时间应对（dealing with）多件事情的能力.

# 2. Java线程

## 2.1 ==创建和运行线程==
### 方法一:直接使用Thread

```java
Thread thread1 = new Thread(){  
    @Override  
    public void run() {  
        log.info("Thread1 Running!");  
    }  
};  
thread1.setName("Thread1");  
thread1.start();  
log.info("Running!");
```
### 方法二:使用Runnable配合Thread(更灵活,更优!)

```Java
    Runnable runnable = new Runnable() {  
        @Override  
        public void run() {  
            log.info("Running");  
        }  
    };  
    Thread thread = new Thread(runnable);  
    thread.setName("MyThread");  
    thread.start();  
}
```
使用Lambda表达式简化:
```java hl:1
Runnable runnable = () -> log.info("Running");  
  
Thread thread = new Thread(runnable);  
thread.setName("MyThread");  
thread.start();
```

### 原理之 Thread 与 Runnable 的关系
>**本质还是调用了Thread类的run方法.**

```java
Thread类:
Thread(~){
	...
	this.target = target;
	...
}

run(){
	if (target != null){
		target.run();
	}
}
```
内部是**将Runnable对象赋值给了Thread的成员变量**,并在run()方法中调用成员变量的run()方法.

### 方法三:FutureTask配合Thread
>FutureTask配合Callable,可以用来处理**有返回结果**的参数.

在这里,==**get()方法会使主线程阻塞,等待"MyThread"线程执行结束返回结果==.**
```java
FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {  
    @Override  
    public Integer call() throws Exception {  
        log.info("Running");  
        return 3+3;  
    }  
});  
Thread thread = new Thread(futureTask,"MyThread");  
thread.start();  
Integer i = futureTask.get();  

log.info("Running");  
log.info("{}",i); // {}占位符.
```
## 2.2 查看进程线程的方法
>**pid即为进程id**
### Windows:
- `tasklist`:查看进程, 可通过`tasklist | findstr xx`来查看xx的进程
![[Pasted image 20241017195120.png]]
- `taskkill -pid xx`:杀死进程id为xx的进程
![[Pasted image 20241017195305.png]]

### Linux:
- `ps -ef | grep xx`:查看进程名为xx的进程信息.
- `kill xx`:杀死进程id为xx的进程.
- `top -H -p xx`:查看xx进程的所有**线程**!
### Java:
- `jps`:查看所有java的进程
![[Pasted image 20241017195912.png]]
- `jstack <pid>`:查看进程id为xx的所有线程的信息.

## ==3.3 线程运行原理==
### 栈与栈帧

### 线程上下文切换:
以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码
- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep、yield、wait、join、park、synchronized、lock `等方法

线程上下文切换后,操作系统需要保存当前线程状态(以便于待会恢复执行),Java中对应的就是"程序计数器"(Program Counter Register),作用是:记住下一条JVM指令的执行地址,使线程私有的.
- **状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等;**
- **线程上下文频繁发生会影响性能**(所以线程数最好不超越CPU核数)

## 3.4 常见方法
### start与run
- 调用run()方法,实质上只是执行了线程t1内部的run()方法. 可以看到,下面的输出中,实际上执行代码的**仍是主线程**.
```java
Thread t1 = new Thread("t1"){  
    @Override  
    public void run() {  
        log.info("running...");  
    }  
};  
t1.run();

OUTPUT:
>> [main] INFO TestStartAndRun - running...

```
- 所以,正确的执行命令应该是先调用`start()`启动新线程,再通过新线程间接执行内部`run()`方法.

### sleep与yield:
#### sleep:
- 调用`sleep(long millis)`,使**当前线程**休眠xx毫秒(在哪个线程中调用,就休眠哪个线程).
	- 此时线程会处于TIMED_WAITING状态.
- 可通过**调用interrupt方法**打断正在睡眠的线程,此时线程会抛出"`InterruptedException`" 异常.
- **睡眠结束后的线程未必会立刻得到执行**,此时还需等待CPU任务调度器分片.
- 建议使用**TimeUnit的sleep方法**,可读性更强.
	- `TimeUnit.SECONDS.sleep(10)`:休眠10秒; `TimeUnit.MINUTES.sleep(1)`:休眠1分钟.

#### yield:
- 调用 yield 会让当前线程**从Running进入Runnable就绪状态**,然后调度执行其它线程.
	- **区分就绪状态与阻塞状态:** 任务调度器可能会分时间片给就绪状态,但不可能分片给阻塞状态.

#### 线程优先级:
- 优先级有三种:`MIN_PRIORITY,MAX_PRIORITY,NORM_PRIORITY`
- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，**调度器可以忽略它**;
- **如果cpu比较忙,那么优先级高的线程会获得更多的时间片**,但cpu闲时 优先级几乎没作用

### join方法详解:
>**`join()`:等待线程运行结束**.
#### 为什么需要join方法:
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	> [main] INFO TestStartAndRun - 开始
	> [Thread-0] INFO TestStartAndRun - 开始
	> [main] INFO TestStartAndRun - 结果为0
	> [main] INFO TestStartAndRun - 结束
```
- 因为线程t1和main线程是并行的,所以main线程查找r的值时,此时r还未被t1线程赋值.

此时可以使用join方法,让**main线程等待t1线程执行结束再执行**.
	用sleep()其实也行,但不准确,因为不知道t1线程具体要执行多久!
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        t1.join();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	[main] INFO TestStartAndRun - 开始
	[Thread-0] INFO TestStartAndRun - 开始
	[main] INFO TestStartAndRun - 结果为10
	[main] INFO TestStartAndRun - 结束
```

#### join等待多个结果的分析:
```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
	});
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}

OUTPUT:(等待2秒)
	> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005
```
- 因为`t1.start()`与`t2.start()`都开启了线程,当`t1.join()`执行时,需要等待t1线程结束(1秒),然后再执行`t2.join()`,注意前面t1与t2是同时开启线程的,所以**只需再等待t2线程1秒**就可以,故最终结果为2秒!
- 若颠倒`t1.join()`与`t2.join()`,仍是2秒,因为等待线程2结束的过程中,线程1已经结束!所以实质上`t1.join()`并未生效,因为已经运行结束.

#### 有时效的join:
`join(long millis)`:若超过`millis`,线程t1仍未结束,则继续执行主线程,不再等待.

### interrupt方法详解:
#### 打断sleep,wait,join的线程:
- 打断sleep,wait,join的线程,**会清空打断状态**,即`isInterrupted()`的值为`false`.
	- 会通过异常的形式通知,即`InterruptedException`.
```bash
java.lang.InterruptedException: sleep interrupted
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
at java.lang.Thread.run(Thread.java:745)
21:18:10.374 [main] c.TestInterrupt - 打断状态: false
```

#### 打断正常运行的线程:
- 打断正常运行的线程,不会清空打断状态.
```
20:57:37.964 [t2] c.TestInterrupt - 打断状态: true
```
- 打断操作只是将`isInterrupted()`置为true,而不会真正打断线程执行!要实现打断线程执行,须在线程内部进行操作.
```java
	boolean interrupted = Thread.currentThread.isInterrupted();
	if (interrupted) break;
```

==**两阶段终止模式:**==
![[Pasted image 20241017235058.png|450]]
```java
public class TestTwoPhaseTermination {  
    public static void main(String[] args) throws InterruptedException {  
	    // 创建监视器对象
		TwoPhaseTermination tpt = new TwoPhaseTermination();  
		// 开始线程,即开始监视.
        tpt.start();  
		// 这期间会监视
        TimeUnit.SECONDS.sleep(2);  
        // 打断
        tpt.stop();  
    }  
  
}  
  
@Slf4j  
class TwoPhaseTermination {  
    private Thread monitor;  
  
    public void start(){  
        monitor = new Thread(() -> {  
	        // while(true)->持续监视
            while (true){  
                Thread currThread = Thread.currentThread();
                // 线程在执行期间被打断.  
                if (currThread.isInterrupted()){  
                    log.info("料理后事");  
                    break;  
                }  
                try {  
                    //睡眠2秒  
                    TimeUnit.SECONDS.sleep(2);  
                    log.info("执行监控记录");  
                } catch (InterruptedException e) {
	                // 线程在阻塞(睡眠时)被打断.  
                    e.printStackTrace();  
                    // 重新设置打断标记为true.  
                    currThread.interrupt();  
                }  
            }  
        });  
        monitor.start();  
    }  
  
    public void stop(){  
        monitor.interrupt();  
    }  
}

```
#### 打断park线程:
`LockSupport.park()`:使当前线程停下,与sleep等具有类似的功能.

`interrupt`打断park线程,不会清空打断状态.

如果此时isInterrupted的结果为true,则再调用`interrupt`,不会打断park线程.
	可通过调用`interrupted()`方法:打断线程的同时将状态设为false.

## 3.5 主线程与守护线程
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，**只要其它非守护线程运行结束了，==即使守护线程的代码没有执行完，也会强制结束==。**

常见的守护线程:
- 垃圾回收器线程;
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求.

## 3.6 线程的五种状态
![[Pasted image 20241018092041.png|450]]
- **初始状态:** 仅是在语言层面创建了线程对象,还未与操作系统线程关联.
- **可运行状态(就绪状态):** 线程已经被创建(已与操作系统线程关联),**可由CPU调度执行.**
- **运行状态:** 已获取CPU时间片,正在运行中的状态;
	- CPU时间片用完后,会继续转换为"可运行状态",导致线程上下文切换.
- **阻塞状态:** CPU不会分配时间片给"阻塞状态",但阻塞状态结束后,CPU会重新分配时间片.
	- 调用了阻塞API,如BIO读写文件.此时线程不会用到CPU,会**切换成"阻塞状态"**;
	- BIO运行结束后,操作系统会唤醒阻塞的线程,切换为"**可运行状态**";
- **终止状态:** 线程已执行完毕,生命周期结束,不会再切换为其它状态.


## 3.7 线程的六种状态
>由Java API层面:Thread.State进行描述的,
![[Pasted image 20241018092439.png|450]]
- **NEW:** 线程被创建,但还未调用`start()`方法;
- **RUNNABLE:** 分为"可运行状态","运行状态"和"阻塞状态",但三者都显示为`RUNNABLE`.
	- **可运行状态:** 等待CPU分配时间片.
	- **运行状态:** 线程正在运行中.
	- **阻塞状态**: 如BIO导致的线程阻塞.
- **BLOCKED:** 可能的情况:加锁,等待获取锁,此时处于BLOCKED状态
- **WAITING:** 调用了join()方法,等待其它线程运行结束.
- **TIMED_WAITING:** 调用了`join(millis)`,`Thread.sleep(millis)`等方法,等待其它线程运行结束,且**带等待时间**.
- **TERMINATED:** 线程代码已结束.

# 4. 共享模型之管程
## 4.1 共享带来的问题
```java
static int counter = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter++;
		}
	}, "t1");
	Thread t2 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter--;
		}
	}, "t2");
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	log.debug("{}",counter);
}
```
- 操作两个线程,分别执行自增和自减操作 => 最后结果大概率不是0.
- **根本原因:** 线程操作静态变量,不是原子性操作,而是先读取静态变量,自增,再重新存入静态变量中.
### 临界区Critical Section:
- 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区
```java
static int counter = 0;
static void increment()
// 临界区
{
counter++;
}
static void decrement()
// 临界区
{
counter--;
}
```
### 竞态条件Race Condition:
多个线程在临界区内执行，由于**代码的执行序列不同而导致结果无法预测**，称之为**发生了竞态条件**

## 4.2 synchronized解决方案
synchronized,即俗称的"对象锁",采用互斥的方式让同一时刻最多只有一个线程能持有"对象锁",其它线程想获取这个对象锁时会被阻塞住.

>**若线程获取了对象锁,而CPU分配的时间片用完了,此时会继续等待,直到再次获取时间片.**
### 语法:
- 不同线程之间要保证获取的是同一个对象锁,即**同一个对象**!
- 若线程1加锁,而线程2没加锁,也是失效的,因为线程2不会被阻塞,仍会继续操作静态变量count.
```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区代码;
}
```

```java
Thread t1 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count++;  
        }  
    }  
},"t1");  
  
Thread t2 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count--;  
        }  
    }  
},"t2");
```

### ==基于面向对象的加锁改进:==
- 把需要保护的共享变量放入一个类中,并使用类对象本身作为锁对象.
```java
class Room{  
    private int count = 0;  
  
    public void increment(){  
        synchronized (this){  
            count++;  
        }  
    }  
    public void decrement(){  
        synchronized (this){  
            count--;  
        }  
    }  
  
    public int getCount() {  
        synchronized (this) {  
            return count;  
        }  
    }  
}
```

## 4.3 方法上的synchronized

### 加在成员方法上:
加在方法上,相当于锁住了this对象,所以有如下改造:
```java
class Test{
	public synchronized void test() {
	
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
		
		}
	}
}
```

```java
public void increment(){  
    synchronized (this){  
        count++;  
    }  
}
```
可改造为:
```java
public synchronized void increment(){  
	count++;  
}
```
### 加在静态方法上:
加在静态方法上,相当于锁住的是类对象.
```java
class Test {  
    public synchronized static void test() {  
    }  
}  
等价于  
  
class Test {  
    public static void test() {  
        synchronized (Test.class) {  
        }  
    }
```

- 锁this对象和锁类对象是并行的.
- 类对象只有一个.

## 4.4 变量的线程安全分析
>**根本还是在于变量是否被共享.**
### 成员变量和静态变量的线程安全问题:
- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
	- 如果只有读操作，则线程安全
	- **如果有读写操作，则这段代码是临界区，需要考虑线程安全**


### 局部变量的线程安全问题:
- 局部变量是线程安全的
- 但局部变量引用的对象则未必
	- 如果该对象没有逃离方法的作用访问，它是线程安全的
	- 如果该对象逃离方法的作用范围，需要考虑线程安全

### 变量线程安全问题的具体分析:
#### **局部变量的线程安全:** 
```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用`test1()`方法时局部变量`i`,==**会在每个线程的栈帧内存中被创建多份**==,因此不存在共享.
操作的都是各自的私有变量i.
![[Pasted image 20241019191157.png|300]]

#### 成员变量的线程安全:
- 此处**会发生线程安全问题**,因为在main方法中,只new了一个`ThreadUnsafe`对象`test`,因此也只有一个`list`成员变量.当有多个线程调用`test`方法时,**操作的都是同一个对象的list成员变量.**
```java hl:2,21
class ThreadUnsafe {  
    ArrayList<String> list = new ArrayList<>();  
    public void method1(int loopNumber) {  
        for (int i = 0; i < loopNumber; i++) {  
            // { 临界区, 会产生竞态条件  
            method2();  
            method3();  
            // } 临界区  
        }  
    }  
    private void method2() {  
        list.add("1");  
    }  
    private void method3() {  
        list.remove(0);  
    }  
}
----

public static void main(String[] args) {  
    ThreadUnsafe test = new ThreadUnsafe();  
    for (int i = 0; i < THREAD_NUMBER; i++) {  
        new Thread(() -> {  
            test.method1(LOOP_NUMBER);  
        }, "Thread" + i).start();  
    }  
}

```

![[Pasted image 20241019191440.png|450]]



将`list`放入method1方法中,作为局部变量.此时,每个线程在调用`method1`时,都会创建自己的`list`对象.
>**局部变量是存储在线程的栈内存中，而每个线程都有自己独立的栈空间。**
```java hl:3
class ThreadSafe {  
    public final void method1(int loopNumber) {  
        ArrayList<String> list = new ArrayList<>();  
        for (int i = 0; i < loopNumber; i++) {  
            method2(list);  
            method3(list);  
        }  
    }  
    private void method2(ArrayList<String> list) {  
        list.add("1");  
    }  
    private void method3(ArrayList<String> list) {  
        list.remove(0);  
    }  
}


```
![[Pasted image 20241019193401.png|400]]

1) **将`method2`和`method3`的方法访问修饰符由private修改为public**:
	- **仍然是线程安全的**,因为`method1`的`list局部变量`是线程内独享的,也没对外暴露.所以即使此时`method2`和`method3`是public,有其他线程调用了,他们访问的也不可能是同一个`list`变量!
2) ==**为ThreadSafe类添加子类,子类重写method2和method3方法**:==
	- **会出现线程安全问题.** 在`method1`执行过程中,`method3`会创建新线程操作`list`变量.由于有多个线程对局部变量`list`进行操作,所以可能会发生先`remove`再`add`的操作.
```java
class ThreadSafeSubClass extends ThreadSafe{
	@Override
	public void method3(ArrayList<String> list) {
		new Thread(() -> {
			list.remove(0);
		}).start();
	}
}
```

**测试代码:**
- `method1`调用时,内部`method3`
```java
public class ThreadSafeTest {  
    public static void main(String[] args) {  
        ThreadSafeSubClass test = new ThreadSafeSubClass();  
        for (int i = 0; i < 2; i++) {  
            new Thread(() -> {  
                test.method1(10);  
            }).start();  
        }  
    }  
}
```
### 常见的线程安全类

>String,StringBuffer,JUC包等...

多个线程调用它们同一个实例的某个方法时，是线程安全的.

#### 线程安全类的方法组合:
线程安全类中的单个方法是原子性的,是线程安全的,**但组合不一定是线程安全的**,如下:
- 多个线程执行以下操作:
	- 线程1和线程2可能同时进行`get()`操作,然后都返回结果null,最终进行了2次put操作.
```java
if( table.get("key") == null) {
	table.put("key", value);
}
```
![[Pasted image 20241019194936.png]]

#### 不可变类的线程安全性:
如String类,Integer类,方法内部的增删改操作实质上都是**返回了一个新的对象**.
```java
public class Immutable{  
    private int value = 0;  
    public Immutable(int value){  
        this.value = value;  
    }  
    public int getValue(){  
        return this.value;  
    }  
    public Immutable add(int v){  
        return new Immutable(this.value + v);  
    }  
}
```
### 线程安全案例分析:

## 4.6 Monitor概念


## 4.7 wait/notify
### 4.7.1 wait/notify的原理

### 4.7.2 API介绍:
>**必须获取锁后 才能调用.**

`obj.wait()`: 让进入 object 监视器的线程到 waitSet 等待
	`obj.wait(long n)`:等待n毫秒后结束等待.
`obj.notify()`: 在 object 上正在 waitSet 等待的线程中随机挑一个唤醒
`obj.notifyAll()`: 让 object 上正在 waitSet 等待的线程全部唤醒

### 4.7.3 正确使用方法
- 使用while循环判断,避免"虚假唤醒".
	- **虚假唤醒:** 线程被唤醒,但是条件仍不成立.
```java
synchronized(lock) {
	while(条件不成立) {
		lock.wait();
	}
	// 干活
}
//另一个线程
synchronized(lock) {
	lock.notifyAll();
}
```
#### sleep()与wait()的区别:
1. sleep是Thread类的方法,wait是Object类的方法;
2. wait需要配合synchronized使用;
3. **sleep在睡眠期间不会释放对象锁,而wait会释放对象锁,进入waitSet等待;**
## 4.8 Join
### 4.8.1 原理
调用者轮询检查线程 alive 状态
```java
synchronized (t1) {
	// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束
	while (t1.isAlive()) {
	t1.wait(0);
	}
}
```

## 4.9 Park & Unpark
### 4.9.1 使用方法:
属于LockSupport类的方法:
`LockSupport.park()`:暂停当前线程:

`LockSupport.unpark(线程对象)`:恢复某个线程的运行.

### 4.9.2 要点:
- `wait，notify 和 notifyAll` 必须配合` Object Monitor`一起使用，而` park，unpark`不必;
- `park & unpark `可以先`unpark`. 即先unpark再park也可以唤醒线程;
- 被park的线程处于`WAITING`状态.
- unpark是以线程为单位进行唤醒的,可以明确指定;而notify只能随机唤醒.

### 4.9.3 原理:

每个线程都有一个Parker对象,由`_counter`,`_cond`和`_mutex`三部分组成.

>调用park方法,实质上就是检查`_counter`是否为0,并置0.
>调用unpark方法,实质上就是置`_counter`为1,并唤醒`_cond`中的线程.
#### 情况1:
**先调用park方法:**
1. 调用park方法,检查`_counter`,发现为0,则获取`_mutex`互斥锁;
2. 线程进入`_cond`条件变量阻塞;
3. 设置`_counter`为0.
**再调用unpark方法:**
1. 调用unpark方法,设置`_counter`为1;
2. 唤醒`_cond`条件变量中的阻塞线程,恢复运行;
3. 设置`_counter`为0

#### 情况2:
**先调用unpark方法:**
1. 调用unpark方法,设置_counter为1;
2. 此时调用park方法,检查`_counter`变量,发现为1,则无需阻塞,继续运行;
3. 设置`_counter`为0.

## 4.10 重新理解线程状态转换
![[Pasted image 20241021154238.png|450]]
### 情况1:NEW->RUNNABLE
调用`t.start()`方法,线程状态由NEW->RUNNABLE.

### 情况2:RUNNABLE<->WAITING
t线程调用了`synchronized(obj)`获取了对象锁:
- 调用`obj.wait()`方法,t线程会从`RUNNABLE->WAITING`;
- 调用`obj.notify()`,`obj.notifyAll()`,`t.Interrupt()`时,线程会被重新唤醒,竞争锁;
	- 竞争锁成功,t线程由`WAITING->RUNNABLE`
	- 竞争锁失败,t线程由`WAITING->BLOCKED`,进入阻塞状态.

### 情况3:RUNNABLE<->WAITING
- 当前线程调用了`t.join()`方法,当前线程由`RUNNABLE->WAITING`,即当前线程等待t线程运行结束.
- t线程运行结束后,或调用了当前线程的`Interrupt()`方法,当前线程由`WAITING->RUNNABLE`.

### 情况4:RUNNABLE<->WAITING
- 当前线程调用了`LockSupport.park()`方法,"可能"会让当前线程由`RUNNABLE->WAITING`
- 当前线程调用了`LockSupport.unpark(目标线程)`或调用了线程的`Interrupt()`方法,会由`WAITING->RUNNABLE`.
### 情况5:RUNNABLE<->TIMED_WAITING
t线程用`synchronized(obj)`获取了对象锁后
- 调用`obj.wait(long n)`方法,t线程由`RUNNABLE->TIMED_WAITING`
- t线程等待时间结束后,或被`notify(),notifyAll(),interrupt()`唤醒后:
	- 竞争锁成功,由`TIME_WAITING->RUNNABLE`
	- 竞争锁失败,由`TIMED_WAITING->BLOCKED`

### 情况6:RUNNABLE<->TIMED_WAITING
- 当前线程调用`t.join(long n)`方法时,当前线程会由`RUNNABLE->TIMED_WAITING`,等待线程t运行结束.
- t线程运行结束,或当前线程等待时间结束后,或当前线程调用`interrupt()`方法时,当前线程会有`TIMED_WAITING->RUNNABLE`

### 情况7:RUNNABLE<->TIMED_WAITING
- 当前线程调用`Thread.sleep(long n)`,会从`RUNNABLE->TIMED_WAITING`
- 睡眠时间结束后,会由`TIME_WAITING->RUNNABLE`

### 情况8:RUNNABLE<->TIMED_WAITING
- 当前线程调用`LockSupport.parkNanos(long nanos)`或`LockSupport.parkUntil(long millis)`时,当前线程会从`RUNNABLE->TIMED_WAITING`.
- 调用`LockSupport.unpark(目标线程)`或调用了线程的`interrupt()`,或是等待超时,会让目标线程从`TIMED_WAITING-> RUNNABLE`
### 情况9:RUNNABLE<->BLOCKED
- t线程用`synchronized(obj)`获取了对象锁时如果竞争失败,从`RUNNABLE->BLOCKED`
- 持`obj`锁线程的同步代码块执行完毕，会唤醒该对象上所有`BLOCKED`的线程**重新竞争**，竞争成功,则由`BLOCKED->RUNNABLE`;失败则继续`BLOCKED`.

### 情况10:RUNNABLE<->TERMINATED
当前线程所有代码运行完毕，进入`TERMINATED`

## 4.11 多把锁
运用更加细粒度的锁来增强程序的并发性.

只有一个对象锁`BigRoom`
```java
class BigRoom {  
    public void sleep() {  
        synchronized (this) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
    public void study() {  
        synchronized (this) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }
}
```
改进:
- 使用多个对象锁`studyRoom`和`bedRoom`来分别锁住不同业务操作.
```java
class BigRoom {  
    private final Object studyRoom = new Object();  
    private final Object bedRoom = new Object();  
  
    public void sleep() {  
        synchronized (bedRoom) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
  
    public void study() {  
        synchronized (studyRoom) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }  
}
```

## 4.12 活跃性

### 4.12.1 死锁
一个线程需要同时获取多把锁，这时就容易发生死锁.
`t1`线程获得A对象锁,接下来想获取B对象的锁; `t2`线程获得B对象锁,接下来想获取A对象的锁,此时就会发生死锁问题: 两个线程分别都想获取对方的锁,都进入阻塞状态,

#### 死锁定位:
1. **利用jps查看java进程:**
![[Pasted image 20241021164632.png]]
2. **利用jstack查看进程状态**:`jstack 8772`
![[Pasted image 20241021164857.png]]

### 4.12.2 活锁
活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束.
**可通过设置随机睡眠时间来解决.** 
```java
public class TestLiveLock {  
    static volatile int count = 10;  
    static final Object lock = new Object();  
  
    public static void main(String[] args) {  
        new Thread(() -> {  
// 期望减到 0 退出循环  
            while (count > 0) {  
                sleep(0.2);  
                count--;  
                log.debug("count: {}", count);  
            }  
        }, "t1").start();  
        new Thread(() -> {  
// 期望超过 20 退出循环  
            while (count < 20) {  
                sleep(0.2);  
                count++;  
                log.debug("count: {}", count);  
            }  
        }, "t2").start();  
    }  
}
```

### 4.12.3 饥饿
一个线程由于优先级太低，**始终得不到 CPU 调度执行**，也不能够结束.


## 4.13 ReentrantLock
>**可用于解决上述的活跃性问题**.

相对于synchronized,具备如下特点:
- **可中断**
- **可以设置超时时间**
- **可以设置为公平锁**
- **支持多个条件变量**
- **都支持可重入**

**基本语法:**
```java
// 获取锁
reentrantLock.lock();
try {
	// 临界区
} finally {
	// 释放锁
	reentrantLock.unlock();
}
```

### 4.13.1 可重入:
可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此**有权利再次获取这把锁**.(可理解为:**未解锁,继续加锁**)
如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住.

**示例:**
- method1已经获取了锁,内部调用method2,`method2`**再次获取锁**,依然能成功,这就是可重入
```java
static ReentrantLock lock = new ReentrantLock();  
public static void main(String[] args) {  
    method1();  
}  
public static void method1() {  
    lock.lock();  
    try {  
        log.debug("execute method1");  
        method2();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method2() {  
    lock.lock();  
    try {  
        log.debug("execute method2");  
        method3();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method3() {  
    lock.lock();  
    try {  
        log.debug("execute method3");  
    } finally {  
        lock.unlock();  
    }  
}
```

### 4.13.2 可打断
>**可用于避免死锁的发生**

等待过程中,可以用`interrupt()`方法打断. 此时需要`lockInterruptibly()`方法加锁.


**示例:**
- t1线程调用`lockInterruptibly()`尝试获取锁,主线程调用`lock()`也获取锁;
- 下面代码执行过程:
	1) 主线程调用`lock.lock()`获取锁,并成功获取;
	2) t1线程启动,内部调用`lock.lockInterruptibly()`也尝试获取锁,但是由于锁已被主线程获取,所以t1线程进入阻塞队列等待;
	3) 调用`t1.interrupt()`打断t1的等待过程;
	4) 成功打断,t1线程捕获`InterruptedException`异常,并return返回,结束等待.
```java
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    try {  
        lock.lockInterruptibly();  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
        log.debug("等锁的过程中被打断");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  

lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(1);  
    t1.interrupt();  
    log.debug("执行打断");  
} finally {  
    lock.unlock();  
}
```

### 4.13.3 锁超时

- 使用`trylock()`方法获取锁,即获取失败立即返回,不会进行等待.
- 使用`trylock(long n,TimeUnits.SECONDS)`方法获取锁, 获取锁失败后会进入阻塞队列等待n秒.
- `trylock()`方法也支持`interrupt()`打断!
**示例:**
```java hl:4-6
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    if (!lock.tryLock()) {  
        log.debug("获取立刻失败，返回");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  
lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(2);  
} finally {  
    lock.unlock();  
}
```

#### 优化哲学家问题:

**优化前获取筷子的逻辑:**
使用`synchronized()`获取筷子(锁),获取不到时就会一直等待; 此时另一个"哲学家"也可能在使用`synchronized()`获取筷子,导致两个哲学家互相等待对方持有的锁,导致死锁问题.
```java
@Override  
public void run () {  
    while (true) {  
        // 获得左手筷子  
        synchronized (left) {  
        // 获得右手筷子  
            synchronized (right) {  
                // 吃饭  
                eat();  
            }  
            // 放下右手筷子  
        }  
        // 放下左手筷子  
    }  
}
```

**优化后的获取筷子逻辑:**
- 使用`trylock()`获取筷子,获取不到则返回!
- 注意使用`finally`保证能释放锁.

执行过程:
- `while(true)`尝试一直获取筷子. 使用两个if判断逻辑: 获取了左筷子,继续尝试获取右筷子,若获取失败,则先释放左筷子,在下一个循环再重新尝试获取左右筷子.
```java
@Override  
public void run() {  
    while (true) {  
        // 尝试获得左手筷子  
        if (left.tryLock()) {  
            try {  
                // 尝试获得右手筷子  
                if (right.tryLock()) {  
                    try {  
                        eat();  
                    } finally {  //释放右筷子
                        right.unlock();  
                    }  
                }  
            } finally {  //释放左筷子
                left.unlock();  
            }  
        }  
    }  
}
```

### 4.13.4 公平锁
>**synchronized锁是不公平锁,因为线程进入阻塞队列等待后,争抢锁时并不按进入队列的先后顺序.**

ReentrantLock默认不公平,但是可通过传入参数来创建公平锁.

```java 
public ReentrantLock(boolean fair) {  
    sync = fair ? new FairSync() : new NonfairSync();  
}
```

### 4.13.5 条件变量

`synchronized`中也有条件变量,就是我们讲原理时那个`waitSet`休息室,当条件不满足时进入`waitSet`等待.

**ReentrantLock支持多个条件变量!** 可很好地避免虚假唤醒.
- `synchronized`是那些不满足条件的线程都在一间休息室等消息
- 而` ReentrantLock `支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

#### 使用要点:
- 使用`lock.newCondition()`创建Condition类的实例对象,即条件变量.
- 调用`await()`方法前需要获取锁.
- 调用`conditionObject.await()`释放锁,并使当前线程进入`conditionObject`进行等待;
- 使用`conditionObject.signal()`来唤醒内部的线程重新竞争lock锁.

```java
static ReentrantLock lock = new ReentrantLock();  
static Condition waitCigaretteQueue = lock.newCondition();  
static Condition waitbreakfastQueue = lock.newCondition();  
static volatile boolean hasCigrette = false;  
static volatile boolean hasBreakfast = false;  
public static void main(String[] args) {  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasCigrette) {  
                try {  
                    waitCigaretteQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的烟");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasBreakfast) {  
                try {  
                    waitbreakfastQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的早餐");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    sleep(1);  
    sendBreakfast();  
    sleep(1);  
    sendCigarette();  
}  
private static void sendCigarette() {  
    lock.lock();  
    try {  
        log.debug("送烟来了");  
        hasCigrette = true;  
        waitCigaretteQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}  
private static void sendBreakfast() {  
    lock.lock();  
    try {  
        log.debug("送早餐来了");  
        hasBreakfast = true;  
        waitbreakfastQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}
```

# 5. 共享模型之内存

## 5.1 Java内存模型
JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

JMM 体现在以下几个方面
- **原子性:** 保证指令不会受到线程上下文切换的影响
- **可见性:** 保证指令不会受 cpu 缓存的影响
- **有序性:** 保证指令不会受 cpu 指令并行优化的影响

## 5.2 可见性
>**一个线程修改了主存数据,对另一个内存不可见.**
### 5.2.1 退不出的循环

#### 问题:
- 即使在后面修改了run的值,也无法使循环退出.
- 若将此处的`sleep(1)`去掉,则循环还是会退出.
```java
static boolean run = true;
public static void main(String[] args) throws InterruptedException {
	Thread t = new Thread(()->{
		while(run){
		// ....
		}
	});
	t.start();
	
	sleep(1); 
	run = false; // 线程t不会如预想的停下来
}
```

#### 分析:
1. 初始状态,t线程从主内存中读取了run的值到工作内存中;
   ![[Pasted image 20241022144719.png|400]]
2. 循环中需要频繁读取run的值,所以**JIT编译器会将run的值缓存到工作内存的高速缓存中**,减少对主存的访问,提高效率;
   ![[Pasted image 20241022144824.png|400]]
3. 1秒后,main线程修改了run的值,并同步至主存. 但此时t线程只从工作内存中读取run的值,所以并不会退出循环.
   ![[Pasted image 20241022145258.png|400]]

#### 解决办法:
- 添加volatile关键字: 用来**修饰成员变量和静态成员变量**，他可以**避免线程从自己的工作缓存中查找变量的值**，**==必须到主存中获取它的值==**，线程操作 volatile 变量都是直接操作主存.
- 还可以使用synchronized关键字,既可以保证原子性,也可以保证可见性,但是操作"较重",性能较低.


## 5.3 有序性
>**JVM在不影响正确性的前提下,可以调整语句的执行顺序.**

### 5.3.1 问题:
- 输出结果可能为4,1,0. 其中**0为指令重排的结果**,即在JIT编译器运行时优化后,`actor2()`方法可能会变成:
  ```java
  public void actor2(I_Result r) {
	ready = true;
	num = 2;
}
  ```

```java
int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
	if(ready) {
		r.r1 = num + num;
	} else {
		r.r1 = 1;
	}
}

// 线程2 执行此方法
public void actor2(I_Result r) {
	num = 2;
	ready = true;
}
```

### 5.3.2 解决办法:
- 使用volatile修饰ready变量,可防止`ready = true`之前的代码被重排序.

## 5.4 volatile原理
volatile 的底层实现原理是**内存屏障**，Memory Barrier（Memory Fence）
- 对volatile变量的**写指令后会加入写屏障**
- 对volatile变量的**读指令前会加入读屏障**

### 5.4.1 可见性和有序性保证
- 写屏障保证在**该屏障之前的**，对共享变量的改动，都**同步到主存当中**,保证了可见性.
- 写屏障会确保指令重排时,**写屏障之前的代码不会重排在写屏障之后**.
```java
public void actor2(I_Result r) {
	num = 2;
	ready = true; // ready 是 volatile 赋值带写屏障
	// 写屏障
}
```

- 读屏障保证在该屏障之后，对共享变量的读取，**加载的是主存中最新数据**
- 读屏障会爆炸指令重排时,读屏障之后的代码不会排在读屏障之前.
```java
public void actor1(I_Result r) {
	// 读屏障
	// ready 是 volatile 读取值带读屏障
	if(ready) {
		r.r1 = num + num;
	} else {
		r.r1 = 1;
	}
}

```

**注意:**
- volatile只能保证有序性和可见性,**无法解决指令交错的问题**.

## 5.5 习题

**实现1:**
```java
// 问题1：为什么加 final 
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例  
public final class Singleton implements Serializable {  
    // 问题3：为什么设置为私有? 是否能防止反射创建新的实例?  
    private Singleton() {}  
    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?  
    private static final Singleton INSTANCE = new Singleton();  
    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由  
    public static Singleton getInstance() {  
        return INSTANCE;  
    }  
    public Object readResolve() {  
        return INSTANCE;  
    }  
}
```
问题1: 防止子类重写方法,导致单例被破坏.



问题5: 1)支持更好的泛型; 2)提供更好的封装性,内部可实现懒惰初始化.

实现2:使用枚举实现单例
```java
// 问题1：枚举单例是如何限制实例个数的
// 问题2：枚举单例在创建时是否有并发问题
// 问题3：枚举单例能否被反射破坏单例
// 问题4：枚举单例能否被反序列化破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做
enum Singleton {
	INSTANCE;
}
```

**问题1:** 
- 字节码:`public final static enum 类名(Singleton); INSTANCE`
**问题2:**
不存在并发问题,静态成员变量在类加载时创建.

问题3:
不能.

问题4:
可避免反序列化破坏.

问题5:
饿汉式,类加载时就创建对象.

问题6:
添加 构造方法.

实现5:
```java
public final class Singleton {  
    private Singleton() { }  
    // 问题1：属于懒汉式还是饿汉式  
    private static class LazyHolder {  
        static final Singleton INSTANCE = new Singleton();  
    }  
    // 问题2：在创建时是否有并发问题  
    public static Singleton getInstance() {  
        return LazyHolder.INSTANCE;  
    }  
}
```

**问题1:**
- 属于懒汉式,因为类加载是懒惰的.类只有在第一次被使用时才会执行类加载操作.


# 6. 共享模型之无锁
## 6.1 CAS与Volatile 
### 介绍与分析:
利用无锁方法实现扣款操作,保证线程安全.
```java hl:7
public void withdraw(Integer amount) {  
    while (true){  
        // 获取余额最新值  
        int prev = balance.get();  
        int next = prev - amount;  
        // 同步到主存  
        if (balance.compareAndSet(prev,next)) break;  
    }  
}
```

**compareAndSet,简称CAS,是原子性操作.**
- 底层是`lcok cmpxchg`指令,单核多核都能保证操作的原子性.
- CAS内部存储值的value使用volatile修饰,因此CAS过程中需要不断**获取主存中的最新值**,所以需要保证可见性.

执行步骤如下图,CAS操作会**在Set操作时获取主存中的最新值进行Compare**,若与CAS中的值不相等,则重新操作,直到CAS中的值与主存最新值相等.
![[Pasted image 20241022231756.png|450]]

### 为什么无锁效率高?
- 简单概括,无锁时线程一直在运行,不停歇;而synchronized会让线程发生上下文切换,成本较高!
- 但是无锁需要CPU的支持,若未成功获取CPU时间片,则仍会发生上下文切换.

### CAS的特点:
- CAS线程一直处于运行阶段,所以需要CPU支持,故适用于线程数少,CPU核数多的情况;
- CAS基于乐观锁思想.
	- synchronized基于悲观锁,上锁防止其它线程更改!
- CAS 体现的是无锁并发、无阻塞并发.
	- **无锁并发:** 不加锁,而是通过不断尝试获取,比较最新值来保证修改的正确性.
	- **无阻塞并发:** 不断尝试,尽量不发生上下文切换,与synchronized的阻塞不同.

## 6.2 原子整数

### AtomicInteger:
`new AtomicInteger(int value)`
- 构造方法,会将`AtomicInteger`类内部的`value`赋值. `private volatile int value;`

`i.getAndIncrement()`
- 相等于i++操作.

`i.increAndget()`
- 相当于++i操作

`i.getAndAdd(int value)`
- 返回i的值,并执行`i=i+value`操作.

`i.addAndGet(int value)`
- 先`i+=value`,再返回更新后的值.

`i.updateAndGet(IntUnaryOperator updateFunction)`
- IntUnaryOperator为函数式接口,可以使用lambda表达式,该函数用法如下:
```
// 表示将i的值*10
i.updateAndGet(x -> x * 10);
```
- `applyAsInt()`方法,传入value,返回计算后的值.
```java
实现:
public static int myUpdateAndGet(AtomicInteger i, IntUnaryOperator operator){  
    while (true){  
        int prev = i.get();  
        int next = operator.applyAsInt(prev);  
        if (i.compareAndSet(prev,next)){  
            return next;  
        }  
    }  
}
```

## 6.3 原子引用
>**AtomicReference,AtomicStampedReference,AtomicMarkableReference**
### ABA问题及解决:
**出现原因:**
- CAS只能感知到变量由A变B,而无法感知变量由A变成B,再变A的情况

**解决办法:**
- 添加版本号:`getStamp()`,并且让变量修改逻辑都遵循相同的版本号变更规则.