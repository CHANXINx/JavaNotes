# 1. 进程与线程
## 1.1 进程与线程
### 进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- **进程就可以视为程序的一个实例。** 大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

### 线程:
- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- **==Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。==** 在 windows 中**进程是不活动的，只是作为线程的容器.**
### 二者对比:
- 进程基本上相互独立的，而**线程存在于进程内，是进程的一个子集**.
- 进程拥有共享的资源，如内存空间等，**供其内部的线程共享**(例如ThreadLocal就是实现共享的)
- 进程间通信较为复杂:
	- 同一台计算机的进程通信称为IPC(Inter-process communication).
	- 不同计算机之间的进程通信，需要**通过网络，并遵守共同的协议**，例如HTTP传输协议.
- 线程通信相对简单，因为它们**共享进程内的内存**，一个例子是**多个线程可以访问同一个共享变量**
- 线程更轻量，**线程上下文切换成本一般上要比进程上下文切换低**

## 1.2 并行与并发
单核 cpu 下，线程实际还是**串行执行**的.操作系统中存在**任务调度器**,将CPU的时间片分放给不同的程序使用,由于CPU的在线程间切换很快(最小为15ms),所以用户无法感受到切换,而是认为任务在并行.
### 并行:
是指在多核CPU下,系统同时开启多个线程,指的是同一时间动手做（doing）多件事情的能力.

### 并发:
并发指的是**线程轮流使用CPU**,是同一时间应对（dealing with）多件事情的能力.

# 2. Java线程

## 2.1 ==创建和运行线程==
### 方法一:直接使用Thread

```java
Thread thread1 = new Thread(){  
    @Override  
    public void run() {  
        log.info("Thread1 Running!");  
    }  
};  
thread1.setName("Thread1");  
thread1.start();  
log.info("Running!");
```
### 方法二:使用Runnable配合Thread(更灵活,更优!)

```Java
    Runnable runnable = new Runnable() {  
        @Override  
        public void run() {  
            log.info("Running");  
        }  
    };  
    Thread thread = new Thread(runnable);  
    thread.setName("MyThread");  
    thread.start();  
}
```
使用Lambda表达式简化:
```java hl:1
Runnable runnable = () -> log.info("Running");  
  
Thread thread = new Thread(runnable);  
thread.setName("MyThread");  
thread.start();
```

### 原理之 Thread 与 Runnable 的关系
>**本质还是调用了Thread类的run方法.**

```java
Thread类:
Thread(~){
	...
	this.target = target;
	...
}

run(){
	if (target != null){
		target.run();
	}
}
```
内部是**将Runnable对象赋值给了Thread的成员变量**,并在run()方法中调用成员变量的run()方法.

### 方法三:FutureTask配合Thread
>FutureTask配合Callable,可以用来处理**有返回结果**的参数.

在这里,==**get()方法会使主线程阻塞,等待"MyThread"线程执行结束返回结果==.**
```java
FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {  
    @Override  
    public Integer call() throws Exception {  
        log.info("Running");  
        return 3+3;  
    }  
});  
Thread thread = new Thread(futureTask,"MyThread");  
thread.start();  
Integer i = futureTask.get();  

log.info("Running");  
log.info("{}",i); // {}占位符.
```
## 2.2 查看进程线程的方法
>**pid即为进程id**
### Windows:
- `tasklist`:查看进程, 可通过`tasklist | findstr xx`来查看xx的进程
![[Pasted image 20241017195120.png]]
- `taskkill -pid xx`:杀死进程id为xx的进程
![[Pasted image 20241017195305.png]]

### Linux:
- `ps -ef | grep xx`:查看进程名为xx的进程信息.
- `kill xx`:杀死进程id为xx的进程.
- `top -H -p xx`:查看xx进程的所有**线程**!
### Java:
- `jps`:查看所有java的进程
![[Pasted image 20241017195912.png]]
- `jstack <pid>`:查看进程id为xx的所有线程的信息.

## ==3.3 线程运行原理==
### 栈与栈帧

### 线程上下文切换:
以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码
- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep、yield、wait、join、park、synchronized、lock `等方法

线程上下文切换后,操作系统需要保存当前线程状态(以便于待会恢复执行),Java中对应的就是"程序计数器"(Program Counter Register),作用是:记住下一条JVM指令的执行地址,使线程私有的.
- **状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等;**
- **线程上下文频繁发生会影响性能**(所以线程数最好不超越CPU核数)

## 3.4 常见方法
### start与run
- 调用run()方法,实质上只是执行了线程t1内部的run()方法. 可以看到,下面的输出中,实际上执行代码的**仍是主线程**.
```java
Thread t1 = new Thread("t1"){  
    @Override  
    public void run() {  
        log.info("running...");  
    }  
};  
t1.run();

OUTPUT:
>> [main] INFO TestStartAndRun - running...

```
- 所以,正确的执行命令应该是先调用`start()`启动新线程,再通过新线程间接执行内部`run()`方法.

### sleep与yield:
#### sleep:
- 调用`sleep(long millis)`,使**当前线程**休眠xx毫秒(在哪个线程中调用,就休眠哪个线程).
	- 此时线程会处于TIMED_WAITING状态.
- 可通过**调用interrupt方法**打断正在睡眠的线程,此时线程会抛出"`InterruptedException`" 异常.
- **睡眠结束后的线程未必会立刻得到执行**,此时还需等待CPU任务调度器分片.
- 建议使用**TimeUnit的sleep方法**,可读性更强.
	- `TimeUnit.SECONDS.sleep(10)`:休眠10秒; `TimeUnit.MINUTES.sleep(1)`:休眠1分钟.

#### yield:
- 调用 yield 会让当前线程**从Running进入Runnable就绪状态**,然后调度执行其它线程.
	- **区分就绪状态与阻塞状态:** 任务调度器可能会分时间片给就绪状态,但不可能分片给阻塞状态.

#### 线程优先级:
- 优先级有三种:`MIN_PRIORITY,MAX_PRIORITY,NORM_PRIORITY`
- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，**调度器可以忽略它**;
- **如果cpu比较忙,那么优先级高的线程会获得更多的时间片**,但cpu闲时 优先级几乎没作用

### join方法详解:
>**`join()`:等待线程运行结束**.
#### 为什么需要join方法:
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	> [main] INFO TestStartAndRun - 开始
	> [Thread-0] INFO TestStartAndRun - 开始
	> [main] INFO TestStartAndRun - 结果为0
	> [main] INFO TestStartAndRun - 结束
```
- 因为线程t1和main线程是并行的,所以main线程查找r的值时,此时r还未被t1线程赋值.

此时可以使用join方法,让**main线程等待t1线程执行结束再执行**.
	用sleep()其实也行,但不准确,因为不知道t1线程具体要执行多久!
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        t1.join();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	[main] INFO TestStartAndRun - 开始
	[Thread-0] INFO TestStartAndRun - 开始
	[main] INFO TestStartAndRun - 结果为10
	[main] INFO TestStartAndRun - 结束
```

#### join等待多个结果的分析:
```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
	});
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}

OUTPUT:(等待2秒)
	> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005
```
- 因为`t1.start()`与`t2.start()`都开启了线程,当`t1.join()`执行时,需要等待t1线程结束(1秒),然后再执行`t2.join()`,注意前面t1与t2是同时开启线程的,所以**只需再等待t2线程1秒**就可以,故最终结果为2秒!
- 若颠倒`t1.join()`与`t2.join()`,仍是2秒,因为等待线程2结束的过程中,线程1已经结束!所以实质上`t1.join()`并未生效,因为已经运行结束.

#### 有时效的join:
`join(long millis)`:若超过`millis`,线程t1仍未结束,则继续执行主线程,不再等待.

### interrupt方法详解:
#### 打断sleep,wait,join的线程:
- 打断sleep,wait,join的线程,**会清空打断状态**,即`isInterrupted()`的值为`false`.
	- 会通过异常的形式通知,即`InterruptedException`.
```bash
java.lang.InterruptedException: sleep interrupted
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
at java.lang.Thread.run(Thread.java:745)
21:18:10.374 [main] c.TestInterrupt - 打断状态: false
```

#### 打断正常运行的线程:
- 打断正常运行的线程,不会清空打断状态.
```
20:57:37.964 [t2] c.TestInterrupt - 打断状态: true
```
- 打断操作只是将`isInterrupted()`置为true,而不会真正打断线程执行!要实现打断线程执行,须在线程内部进行操作.
```java
	boolean interrupted = Thread.currentThread.isInterrupted();
	if (interrupted) break;
```

==**两阶段终止模式:**==
![[Pasted image 20241017235058.png|450]]
```java
import lombok.extern.slf4j.Slf4j;  
  
import java.util.concurrent.TimeUnit;  
  
public class TestTwoPhaseTermination {  
    public static void main(String[] args) throws InterruptedException {  
	    // 创建监视器对象
		TwoPhaseTermination tpt = new TwoPhaseTermination();  
		// 开始线程,即开始监视.
        tpt.start();  
		// 这期间会监视
        TimeUnit.SECONDS.sleep(2);  
        // 打断
        tpt.stop();  
    }  
  
}  
  
@Slf4j  
class TwoPhaseTermination {  
    private Thread monitor;  
  
    public void start(){  
        monitor = new Thread(() -> {  
	        // while(true)->持续监视
            while (true){  
                Thread currThread = Thread.currentThread();
                // 线程在执行期间被打断.  
                if (currThread.isInterrupted()){  
                    log.info("料理后事");  
                    break;  
                }  
                try {  
                    //睡眠2秒  
                    TimeUnit.SECONDS.sleep(2);  
                    log.info("执行监控记录");  
                } catch (InterruptedException e) {
	                // 线程在阻塞(睡眠时)被打断.  
                    e.printStackTrace();  
                    // 重新设置打断标记为true.  
                    currThread.interrupt();  
                }  
            }  
        });  
        monitor.start();  
    }  
  
    public void stop(){  
        monitor.interrupt();  
    }  
}

```
#### 打断park线程:
`LockSupport.park()`:使当前线程停下,与sleep等具有类似的功能.

`interrupt`打断park线程,不会清空打断状态.

如果此时isInterrupted的结果为true,则再调用`interrupt`,不会打断park线程.
	可通过调用`interrupted()`方法:打断线程的同时将状态设为false.

## 3.5 主线程与守护线程
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，**只要其它非守护线程运行结束了，==即使守护线程的代码没有执行完，也会强制结束==。**

常见的守护线程:
- 垃圾回收器线程;
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求.

## 3.6 线程的五种状态
![[Pasted image 20241018092041.png|450]]
- **初始状态:** 仅是在语言层面创建了线程对象,还未与操作系统线程关联.
- **可运行状态(就绪状态):** 线程已经被创建(已与操作系统线程关联),**可由CPU调度执行.**
- **运行状态:** 已获取CPU时间片,正在运行中的状态;
	- CPU时间片用完后,会继续转换为"可运行状态",导致线程上下文切换.
- **阻塞状态:** CPU不会分配时间片给"阻塞状态",但阻塞状态结束后,CPU会重新分配时间片.
	- 调用了阻塞API,如BIO读写文件.此时线程不会用到CPU,会**切换成"阻塞状态"**;
	- BIO运行结束后,操作系统会唤醒阻塞的线程,切换为"**可运行状态**";
- **终止状态:** 线程已执行完毕,生命周期结束,不会再切换为其它状态.


## 3.7 线程的六种状态
>由Java API层面:Thread.State进行描述的,
![[Pasted image 20241018092439.png|450]]
- **NEW:** 线程被创建,但还未调用`start()`方法;
- **RUNNABLE:** 分为"可运行状态","运行状态"和"阻塞状态",但三者都显示为`RUNNABLE`.
	- **可运行状态:** 等待CPU分配时间片.
	- **运行状态:** 线程正在运行中.
	- **阻塞状态**: 如BIO导致的线程阻塞.
- **BLOCKED:** 可能的情况:加锁,等待获取锁,此时处于BLOCKED状态
- **WAITING:** 调用了join()方法,等待其它线程运行结束.
- **TIMED_WAITING:** 调用了`join(millis)`,`Thread.sleep(millis)`等方法,等待其它线程运行结束,且**带等待时间**.
- **TERMINATED:** 线程代码已结束.

# 4. 共享模型之管程
## 4.1 共享带来的问题
```java
static int counter = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter++;
		}
	}, "t1");
	Thread t2 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter--;
		}
	}, "t2");
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	log.debug("{}",counter);
}
```
- 操作两个线程,分别执行自增和自减操作 => 最后结果大概率不是0.
- **根本原因:** 线程操作静态变量,不是原子性操作,而是先读取静态变量,自增,再重新存入静态变量中.
### 临界区Critical Section:
- 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区
```java
static int counter = 0;
static void increment()
// 临界区
{
counter++;
}
static void decrement()
// 临界区
{
counter--;
}
```
### 竞态条件Race Condition:
多个线程在临界区内执行，由于**代码的执行序列不同而导致结果无法预测**，称之为**发生了竞态条件**

## 4.2 synchronized解决方案
synchronized,即俗称的"对象锁",采用互斥的方式让同一时刻最多只有一个线程能持有"对象锁",其它线程想获取这个对象锁时会被阻塞住.

>**若线程获取了对象锁,而CPU分配的时间片用完了,此时会继续等待,直到再次获取时间片.**
### 语法:
- 不同线程之间要保证获取的是同一个对象锁,即**同一个对象**!
- 若线程1加锁,而线程2没加锁,也是失效的,因为线程2不会被阻塞,仍会继续操作静态变量count.
```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区代码;
}
```

```java
Thread t1 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count++;  
        }  
    }  
},"t1");  
  
Thread t2 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count--;  
        }  
    }  
},"t2");
```

### ==基于面向对象的加锁改进:==
- 把需要保护的共享变量放入一个类中,并使用类对象本身作为锁对象.
```java
class Room{  
    private int count = 0;  
  
    public void increment(){  
        synchronized (this){  
            count++;  
        }  
    }  
    public void decrement(){  
        synchronized (this){  
            count--;  
        }  
    }  
  
    public int getCount() {  
        synchronized (this) {  
            return count;  
        }  
    }  
}
```

## 4.3 方法上的synchronized

### 加在成员方法上:
加在方法上,相当于锁住了this对象,所以有如下改造:
```java
class Test{
	public synchronized void test() {
	
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
		
		}
	}
}
```

```java
public void increment(){  
    synchronized (this){  
        count++;  
    }  
}
```
可改造为:
```java
public synchronized void increment(){  
	count++;  
}
```
### 加在静态方法上:
加在静态方法上,相当于锁住的是类对象.
```java
class Test {  
    public synchronized static void test() {  
    }  
}  
等价于  
  
class Test {  
    public static void test() {  
        synchronized (Test.class) {  
        }  
    }
```

- 锁this对象和锁类对象是并行的.
- 类对象只有一个.

## 4.4 变量的线程安全分析
>**根本还是在于变量是否被共享.**
### 成员变量和静态变量的线程安全问题:
- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
	- 如果只有读操作，则线程安全
	- **如果有读写操作，则这段代码是临界区，需要考虑线程安全**


### 局部变量的线程安全问题:
- 局部变量是线程安全的
- 但局部变量引用的对象则未必
	- 如果该对象没有逃离方法的作用访问，它是线程安全的
	- 如果该对象逃离方法的作用范围，需要考虑线程安全

### 变量线程安全问题的具体分析:
#### **局部变量的线程安全:** 
```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用`test1()`方法时局部变量`i`,==**会在每个线程的栈帧内存中被创建多份**==,因此不存在共享.
操作的都是各自的私有变量i.
![[Pasted image 20241019191157.png|300]]

#### 成员变量的线程安全:
- 此处**会发生线程安全问题**,因为在main方法中,只new了一个`ThreadUnsafe`对象`test`,因此也只有一个`list`成员变量.当有多个线程调用`test`方法时,**操作的都是同一个对象的list成员变量.**
```java hl:2,21
class ThreadUnsafe {  
    ArrayList<String> list = new ArrayList<>();  
    public void method1(int loopNumber) {  
        for (int i = 0; i < loopNumber; i++) {  
            // { 临界区, 会产生竞态条件  
            method2();  
            method3();  
            // } 临界区  
        }  
    }  
    private void method2() {  
        list.add("1");  
    }  
    private void method3() {  
        list.remove(0);  
    }  
}
----

public static void main(String[] args) {  
    ThreadUnsafe test = new ThreadUnsafe();  
    for (int i = 0; i < THREAD_NUMBER; i++) {  
        new Thread(() -> {  
            test.method1(LOOP_NUMBER);  
        }, "Thread" + i).start();  
    }  
}

```

![[Pasted image 20241019191440.png|450]]



将`list`放入method1方法中,作为局部变量.此时,每个线程在调用`method1`时,都会创建自己的`list`对象.
>**局部变量是存储在线程的栈内存中，而每个线程都有自己独立的栈空间。**
```java hl:3
class ThreadSafe {  
    public final void method1(int loopNumber) {  
        ArrayList<String> list = new ArrayList<>();  
        for (int i = 0; i < loopNumber; i++) {  
            method2(list);  
            method3(list);  
        }  
    }  
    private void method2(ArrayList<String> list) {  
        list.add("1");  
    }  
    private void method3(ArrayList<String> list) {  
        list.remove(0);  
    }  
}
```
![[Pasted image 20241019193401.png|400]]

将**访问修饰符由private修改为public**,会发生线程安全问题:
1) **有其它线程调用 method2 和 method3:** 此时多个线程操作的都是method2
2) 
### 常见的线程安全类

>String,StringBuffer,JUC包等...

多个线程调用它们同一个实例的某个方法时，是线程安全的.

#### 线程安全类的方法组合:
线程安全类中的单个方法是原子性的,是线程安全的,**但组合不一定是线程安全的**,如下:
- 多个线程执行以下操作:
	- 线程1和线程2可能同时进行`get()`操作,然后都返回结果null,最终进行了2次put操作.
```java
if( table.get("key") == null) {
	table.put("key", value);
}
```
![[Pasted image 20241019194936.png]]

#### 不可变类的线程安全性:
如String类,Integer类,方法内部的增删改操作实质上都是**返回了一个新的对象**.
```java
public class Immutable{  
    private int value = 0;  
    public Immutable(int value){  
        this.value = value;  
    }  
    public int getValue(){  
        return this.value;  
    }  
    public Immutable add(int v){  
        return new Immutable(this.value + v);  
    }  
}
```
### 线程安全案例分析: