# 1. 进程与线程
## 1.1 进程与线程
### 进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- **进程就可以视为程序的一个实例。** 大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

### 线程:
- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- **==Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。==** 在 windows 中**进程是不活动的，只是作为线程的容器.**
### 二者对比:
- 进程基本上相互独立的，而**线程存在于进程内，是进程的一个子集**.
- 进程拥有共享的资源，如内存空间等，**供其内部的线程共享**(例如ThreadLocal就是实现共享的)
- 进程间通信较为复杂:
	- 同一台计算机的进程通信称为IPC(Inter-process communication).
	- 不同计算机之间的进程通信，需要**通过网络，并遵守共同的协议**，例如HTTP传输协议.
- 线程通信相对简单，因为它们**共享进程内的内存**，一个例子是**多个线程可以访问同一个共享变量**
- 线程更轻量，**线程上下文切换成本一般上要比进程上下文切换低**

## 1.2 并行与并发
单核 cpu 下，线程实际还是**串行执行**的.操作系统中存在**任务调度器**,将CPU的时间片分放给不同的程序使用,由于CPU的在线程间切换很快(最小为15ms),所以用户无法感受到切换,而是认为任务在并行.
### 并行:
是指在多核CPU下,系统同时开启多个线程,指的是同一时间动手做（doing）多件事情的能力.

### 并发:
并发指的是**线程轮流使用CPU**,是同一时间应对（dealing with）多件事情的能力.

# 2. Java线程

## 2.1 ==创建和运行线程==
### 方法一:直接使用Thread

```java
Thread thread1 = new Thread(){  
    @Override  
    public void run() {  
        log.info("Thread1 Running!");  
    }  
};  
thread1.setName("Thread1");  
thread1.start();  
log.info("Running!");
```
### 方法二:使用Runnable配合Thread(更灵活,更优!)

```Java
    Runnable runnable = new Runnable() {  
        @Override  
        public void run() {  
            log.info("Running");  
        }  
    };  
    Thread thread = new Thread(runnable);  
    thread.setName("MyThread");  
    thread.start();  
}
```
使用Lambda表达式简化:
```java hl:1
Runnable runnable = () -> log.info("Running");  
  
Thread thread = new Thread(runnable);  
thread.setName("MyThread");  
thread.start();
```

### 原理之 Thread 与 Runnable 的关系
>**本质还是调用了Thread类的run方法.**

```java
Thread类:
Thread(~){
	...
	this.target = target;
	...
}

run(){
	if (target != null){
		target.run();
	}
}
```
内部是**将Runnable对象赋值给了Thread的成员变量**,并在run()方法中调用成员变量的run()方法.

### 方法三:FutureTask配合Thread
>FutureTask配合Callable,可以用来处理**有返回结果**的参数.

在这里,==**get()方法会使主线程阻塞,等待"MyThread"线程执行结束返回结果==.**
```java
FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {  
    @Override  
    public Integer call() throws Exception {  
        log.info("Running");  
        return 3+3;  
    }  
});  
Thread thread = new Thread(futureTask,"MyThread");  
thread.start();  
Integer i = futureTask.get();  

log.info("Running");  
log.info("{}",i); // {}占位符.
```
## 2.2 查看进程线程的方法
>**pid即为进程id**
### Windows:
- `tasklist`:查看进程, 可通过`tasklist | findstr xx`来查看xx的进程
![[Pasted image 20241017195120.png]]
- `taskkill -pid xx`:杀死进程id为xx的进程
![[Pasted image 20241017195305.png]]

### Linux:
- `ps -ef | grep xx`:查看进程名为xx的进程信息.
- `kill xx`:杀死进程id为xx的进程.
- `top -H -p xx`:查看xx进程的所有**线程**!
### Java:
- `jps`:查看所有java的进程
![[Pasted image 20241017195912.png]]
- `jstack <pid>`:查看进程id为xx的所有线程的信息.

## ==3.3 线程运行原理==
### 栈与栈帧

### 线程上下文切换:
以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码
- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep、yield、wait、join、park、synchronized、lock `等方法

线程上下文切换后,操作系统需要保存当前线程状态(以便于待会恢复执行),Java中对应的就是"程序计数器"(Program Counter Register),作用是:记住下一条JVM指令的执行地址,使线程私有的.
- **状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等;**
- **线程上下文频繁发生会影响性能**(所以线程数最好不超越CPU核数)

## 3.4 常见方法
### start与run
- 调用run()方法,实质上只是执行了线程t1内部的run()方法. 可以看到,下面的输出中,实际上执行代码的**仍是主线程**.
```java
Thread t1 = new Thread("t1"){  
    @Override  
    public void run() {  
        log.info("running...");  
    }  
};  
t1.run();

OUTPUT:
>> [main] INFO TestStartAndRun - running...

```
- 所以,正确的执行命令应该是先调用`start()`启动新线程,再通过新线程间接执行内部`run()`方法.

### sleep与yield:
#### sleep:
- 调用`sleep(long millis)`,使**当前线程**休眠xx毫秒(在哪个线程中调用,就休眠哪个线程).
	- 此时线程会处于TIMED_WAITING状态.
- 可通过**调用interrupt方法**打断正在睡眠的线程,此时线程会抛出"`InterruptedException`" 异常.
- **睡眠结束后的线程未必会立刻得到执行**,此时还需等待CPU任务调度器分片.
- 建议使用**TimeUnit的sleep方法**,可读性更强.
	- `TimeUnit.SECONDS.sleep(10)`:休眠10秒; `TimeUnit.MINUTES.sleep(1)`:休眠1分钟.

#### yield:
- 调用 yield 会让当前线程**从Running进入Runnable就绪状态**,然后调度执行其它线程.
	- **区分就绪状态与阻塞状态:** 任务调度器可能会分时间片给就绪状态,但不可能分片给阻塞状态.

#### 线程优先级:
- 优先级有三种:`MIN_PRIORITY,MAX_PRIORITY,NORM_PRIORITY`
- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，**调度器可以忽略它**;
- **如果cpu比较忙,那么优先级高的线程会获得更多的时间片**,但cpu闲时 优先级几乎没作用

### join方法详解:
>**`join()`:等待线程运行结束**.
#### 为什么需要join方法:
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	> [main] INFO TestStartAndRun - 开始
	> [Thread-0] INFO TestStartAndRun - 开始
	> [main] INFO TestStartAndRun - 结果为0
	> [main] INFO TestStartAndRun - 结束
```
- 因为线程t1和main线程是并行的,所以main线程查找r的值时,此时r还未被t1线程赋值.

此时可以使用join方法,让**main线程等待t1线程执行结束再执行**.
	用sleep()其实也行,但不准确,因为不知道t1线程具体要执行多久!
```java
@Slf4j  
public class TestStartAndRun {  
    static int r = 0;  
    public static void main(String[] args) throws InterruptedException {  
        log.info("开始");  
        Thread t1 = new Thread(() -> {  
            log.info("开始");  
            try {  
                TimeUnit.SECONDS.sleep(1);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            r = 10;  
        });  
        t1.start();  
        t1.join();  
        log.info("结果为{}",r);  
        log.info("结束");  
    }  
}

OUTPUT:
	[main] INFO TestStartAndRun - 开始
	[Thread-0] INFO TestStartAndRun - 开始
	[main] INFO TestStartAndRun - 结果为10
	[main] INFO TestStartAndRun - 结束
```

#### join等待多个结果的分析:
```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
	});
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}

OUTPUT:(等待2秒)
	> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005
```
- 因为`t1.start()`与`t2.start()`都开启了线程,当`t1.join()`执行时,需要等待t1线程结束(1秒),然后再执行`t2.join()`,注意前面t1与t2是同时开启线程的,所以**只需再等待t2线程1秒**就可以,故最终结果为2秒!
- 若颠倒`t1.join()`与`t2.join()`,仍是2秒,因为等待线程2结束的过程中,线程1已经结束!所以实质上`t1.join()`并未生效,因为已经运行结束.

#### 有时效的join:
`join(long millis)`:若超过`millis`,线程t1仍未结束,则继续执行主线程,不再等待.

### interrupt方法详解:
#### 打断sleep,wait,join的线程:
- 打断sleep,wait,join的线程,**会清空打断状态**,即`isInterrupted()`的值为`false`.
	- 会通过异常的形式通知,即`InterruptedException`.
```bash
java.lang.InterruptedException: sleep interrupted
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
at java.lang.Thread.run(Thread.java:745)
21:18:10.374 [main] c.TestInterrupt - 打断状态: false
```

#### 打断正常运行的线程:
- 打断正常运行的线程,不会清空打断状态.
```
20:57:37.964 [t2] c.TestInterrupt - 打断状态: true
```
- 打断操作只是将`isInterrupted()`置为true,而不会真正打断线程执行!要实现打断线程执行,须在线程内部进行操作.
```java
	boolean interrupted = Thread.currentThread.isInterrupted();
	if (interrupted) break;
```

==**两阶段终止模式:**==
![[Pasted image 20241017235058.png|450]]
```java
import lombok.extern.slf4j.Slf4j;  
  
import java.util.concurrent.TimeUnit;  
  
public class TestTwoPhaseTermination {  
    public static void main(String[] args) throws InterruptedException {  
	    // 创建监视器对象
		TwoPhaseTermination tpt = new TwoPhaseTermination();  
		// 开始线程,即开始监视.
        tpt.start();  
		// 这期间会监视
        TimeUnit.SECONDS.sleep(2);  
        // 打断
        tpt.stop();  
    }  
  
}  
  
@Slf4j  
class TwoPhaseTermination {  
    private Thread monitor;  
  
    public void start(){  
        monitor = new Thread(() -> {  
	        // while(true)->持续监视
            while (true){  
                Thread currThread = Thread.currentThread();
                // 线程在执行期间被打断.  
                if (currThread.isInterrupted()){  
                    log.info("料理后事");  
                    break;  
                }  
                try {  
                    //睡眠2秒  
                    TimeUnit.SECONDS.sleep(2);  
                    log.info("执行监控记录");  
                } catch (InterruptedException e) {
	                // 线程在阻塞(睡眠时)被打断.  
                    e.printStackTrace();  
                    // 重新设置打断标记为true.  
                    currThread.interrupt();  
                }  
            }  
        });  
        monitor.start();  
    }  
  
    public void stop(){  
        monitor.interrupt();  
    }  
}

```
#### 打断park线程:
`LockSupport.park()`:使当前线程停下,与sleep等具有类似的功能.

`interrupt`打断park线程,不会清空打断状态.

如果此时isInterrupted的结果为true,则再调用`interrupt`,不会打断park线程.
	可通过调用`interrupted()`方法:打断线程的同时将状态设为false.

## 3.5 主线程与守护线程
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，**只要其它非守护线程运行结束了，==即使守护线程的代码没有执行完，也会强制结束==。**

常见的守护线程:
- 垃圾回收器线程;
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求.

## 3.6 线程的五种状态
![[Pasted image 20241018092041.png|450]]
- **初始状态:** 仅是在语言层面创建了线程对象,还未与操作系统线程关联.
- **可运行状态(就绪状态):** 线程已经被创建(已与操作系统线程关联),**可由CPU调度执行.**
- **运行状态:** 已获取CPU时间片,正在运行中的状态;
	- CPU时间片用完后,会继续转换为"可运行状态",导致线程上下文切换.
- **阻塞状态:** CPU不会分配时间片给"阻塞状态",但阻塞状态结束后,CPU会重新分配时间片.
	- 调用了阻塞API,如BIO读写文件.此时线程不会用到CPU,会**切换成"阻塞状态"**;
	- BIO运行结束后,操作系统会唤醒阻塞的线程,切换为"**可运行状态**";
- **终止状态:** 线程已执行完毕,生命周期结束,不会再切换为其它状态.


## 3.7 线程的六种状态
>由Java API层面:Thread.State进行描述的,
![[Pasted image 20241018092439.png|450]]
- **NEW:** 线程被创建,但还未调用`start()`方法;
- **RUNNABLE:** 分为"可运行状态","运行状态"和"阻塞状态",但三者都显示为`RUNNABLE`.
	- **可运行状态:** 等待CPU分配时间片.
	- **运行状态:** 线程正在运行中.
	- **阻塞状态**: 如BIO导致的线程阻塞.
- **BLOCKED:** 可能的情况:加锁,等待获取锁,此时处于BLOCKED状态
- **WAITING:** 调用了join()方法,等待其它线程运行结束.
- **TIMED_WAITING:** 调用了`join(millis)`,`Thread.sleep(millis)`等方法,等待其它线程运行结束,且**带等待时间**.
- **TERMINATED:** 线程代码已结束.

# 4. 共享模型之管程
## 4.1 共享带来的问题
```java
static int counter = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter++;
		}
	}, "t1");
	Thread t2 = new Thread(() -> {
		for (int i = 0; i < 5000; i++) {
			counter--;
		}
	}, "t2");
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	log.debug("{}",counter);
}
```
- 操作两个线程,分别执行自增和自减操作 => 最后结果大概率不是0.
- **根本原因:** 线程操作静态变量,不是原子性操作,而是先读取静态变量,自增,再重新存入静态变量中.
### 临界区Critical Section:
- 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区
```java
static int counter = 0;
static void increment()
// 临界区
{
counter++;
}
static void decrement()
// 临界区
{
counter--;
}
```
### 竞态条件Race Condition:
多个线程在临界区内执行，由于**代码的执行序列不同而导致结果无法预测**，称之为**发生了竞态条件**

## 4.2 synchronized解决方案
synchronized,即俗称的"对象锁",采用互斥的方式让同一时刻最多只有一个线程能持有"对象锁",其它线程想获取这个对象锁时会被阻塞住.

>**若线程获取了对象锁,而CPU分配的时间片用完了,此时会继续等待,直到再次获取时间片.**
### 语法:
- 不同线程之间要保证获取的是同一个对象锁,即**同一个对象**!
- 若线程1加锁,而线程2没加锁,也是失效的,因为线程2不会被阻塞,仍会继续操作静态变量count.
```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区代码;
}
```

```java
Thread t1 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count++;  
        }  
    }  
},"t1");  
  
Thread t2 = new Thread(() -> {  
    synchronized (lock) {  
        for (int i = 0; i < 5000; i++) {  
            count--;  
        }  
    }  
},"t2");
```

### ==基于面向对象的加锁改进:==
- 把需要保护的共享变量放入一个类中,并使用类对象本身作为锁对象.
```java
class Room{  
    private int count = 0;  
  
    public void increment(){  
        synchronized (this){  
            count++;  
        }  
    }  
    public void decrement(){  
        synchronized (this){  
            count--;  
        }  
    }  
  
    public int getCount() {  
        synchronized (this) {  
            return count;  
        }  
    }  
}
```

## 4.3 方法上的synchronized

### 加在成员方法上:
加在方法上,相当于锁住了this对象,所以有如下改造:
```java
class Test{
	public synchronized void test() {
	
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
		
		}
	}
}
```

```java
public void increment(){  
    synchronized (this){  
        count++;  
    }  
}
```
可改造为:
```java
public synchronized void increment(){  
	count++;  
}
```
### 加在静态方法上:
加在静态方法上,相当于锁住的是类对象.
```java
class Test {  
    public synchronized static void test() {  
    }  
}  
等价于  
  
class Test {  
    public static void test() {  
        synchronized (Test.class) {  
        }  
    }
```

- 锁this对象和锁类对象是并行的.
- 类对象只有一个.

## 4.4 变量的线程安全分析
>**根本还是在于变量是否被共享.**
### 成员变量和静态变量的线程安全问题:
- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
	- 如果只有读操作，则线程安全
	- **如果有读写操作，则这段代码是临界区，需要考虑线程安全**


### 局部变量的线程安全问题:
- 局部变量是线程安全的
- 但局部变量引用的对象则未必
	- 如果该对象没有逃离方法的作用访问，它是线程安全的
	- 如果该对象逃离方法的作用范围，需要考虑线程安全

### 变量线程安全问题的具体分析:
#### **局部变量的线程安全:** 
```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用`test1()`方法时局部变量`i`,==**会在每个线程的栈帧内存中被创建多份**==,因此不存在共享.
操作的都是各自的私有变量i.
![[Pasted image 20241019191157.png|300]]

#### 成员变量的线程安全:
- 此处**会发生线程安全问题**,因为在main方法中,只new了一个`ThreadUnsafe`对象`test`,因此也只有一个`list`成员变量.当有多个线程调用`test`方法时,**操作的都是同一个对象的list成员变量.**
```java hl:2,21
class ThreadUnsafe {  
    ArrayList<String> list = new ArrayList<>();  
    public void method1(int loopNumber) {  
        for (int i = 0; i < loopNumber; i++) {  
            // { 临界区, 会产生竞态条件  
            method2();  
            method3();  
            // } 临界区  
        }  
    }  
    private void method2() {  
        list.add("1");  
    }  
    private void method3() {  
        list.remove(0);  
    }  
}
----

public static void main(String[] args) {  
    ThreadUnsafe test = new ThreadUnsafe();  
    for (int i = 0; i < THREAD_NUMBER; i++) {  
        new Thread(() -> {  
            test.method1(LOOP_NUMBER);  
        }, "Thread" + i).start();  
    }  
}

```

![[Pasted image 20241019191440.png|450]]



将`list`放入method1方法中,作为局部变量.此时,每个线程在调用`method1`时,都会创建自己的`list`对象.
>**局部变量是存储在线程的栈内存中，而每个线程都有自己独立的栈空间。**
```java hl:3
class ThreadSafe {  
    public final void method1(int loopNumber) {  
        ArrayList<String> list = new ArrayList<>();  
        for (int i = 0; i < loopNumber; i++) {  
            method2(list);  
            method3(list);  
        }  
    }  
    private void method2(ArrayList<String> list) {  
        list.add("1");  
    }  
    private void method3(ArrayList<String> list) {  
        list.remove(0);  
    }  
}


```
![[Pasted image 20241019193401.png|400]]

1) **将`method2`和`method3`的方法访问修饰符由private修改为public**:
	- **仍然是线程安全的**,因为`method1`的`list局部变量`是线程内独享的,也没对外暴露.所以即使此时`method2`和`method3`是public,有其他线程调用了,他们访问的也不可能是同一个`list`变量!
2) ==**为ThreadSafe类添加子类,子类重写method2和method3方法**:==
	- **会出现线程安全问题.** 在`method1`执行过程中,`method3`会创建新线程操作`list`变量.由于有多个线程对局部变量`list`进行操作,所以可能会发生先`remove`再`add`的操作.
```java
class ThreadSafeSubClass extends ThreadSafe{
	@Override
	public void method3(ArrayList<String> list) {
		new Thread(() -> {
			list.remove(0);
		}).start();
	}
}
```

**测试代码:**
- `method1`调用时,内部`method3`
```java
public class ThreadSafeTest {  
    public static void main(String[] args) {  
        ThreadSafeSubClass test = new ThreadSafeSubClass();  
        for (int i = 0; i < 2; i++) {  
            new Thread(() -> {  
                test.method1(10);  
            }).start();  
        }  
    }  
}
```
### 常见的线程安全类

>String,StringBuffer,JUC包等...

多个线程调用它们同一个实例的某个方法时，是线程安全的.

#### 线程安全类的方法组合:
线程安全类中的单个方法是原子性的,是线程安全的,**但组合不一定是线程安全的**,如下:
- 多个线程执行以下操作:
	- 线程1和线程2可能同时进行`get()`操作,然后都返回结果null,最终进行了2次put操作.
```java
if( table.get("key") == null) {
	table.put("key", value);
}
```
![[Pasted image 20241019194936.png]]

#### 不可变类的线程安全性:
如String类,Integer类,方法内部的增删改操作实质上都是**返回了一个新的对象**.
```java
public class Immutable{  
    private int value = 0;  
    public Immutable(int value){  
        this.value = value;  
    }  
    public int getValue(){  
        return this.value;  
    }  
    public Immutable add(int v){  
        return new Immutable(this.value + v);  
    }  
}
```
### 线程安全案例分析:

## 4.6 Monitor概念


## 4.7 wait/notify
### 4.7.1 wait/notify的原理

### 4.7.2 API介绍:
>**必须获取锁后 才能调用.**

`obj.wait()`: 让进入 object 监视器的线程到 waitSet 等待
	`obj.wait(long n)`:等待n毫秒后结束等待.
`obj.notify()`: 在 object 上正在 waitSet 等待的线程中随机挑一个唤醒
`obj.notifyAll()`: 让 object 上正在 waitSet 等待的线程全部唤醒

### 4.7.3 正确使用方法
- 使用while循环判断,避免"虚假唤醒".
	- **虚假唤醒:** 线程被唤醒,但是条件仍不成立.
```java
synchronized(lock) {
	while(条件不成立) {
		lock.wait();
	}
	// 干活
}
//另一个线程
synchronized(lock) {
	lock.notifyAll();
}
```
#### sleep()与wait()的区别:
1. sleep是Thread类的方法,wait是Object类的方法;
2. wait需要配合synchronized使用;
3. **sleep在睡眠期间不会释放对象锁,而wait会释放对象锁,进入waitSet等待;**
## 4.8 Join
### 4.8.1 原理
调用者轮询检查线程 alive 状态
```java
synchronized (t1) {
	// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束
	while (t1.isAlive()) {
	t1.wait(0);
	}
}
```

## 4.9 Park & Unpark
### 4.9.1 使用方法:
属于LockSupport类的方法:
`LockSupport.park()`:暂停当前线程:

`LockSupport.unpark(线程对象)`:恢复某个线程的运行.

### 4.9.2 要点:
- `wait，notify 和 notifyAll` 必须配合` Object Monitor`一起使用，而` park，unpark`不必;
- `park & unpark `可以先`unpark`. 即先unpark再park也可以唤醒线程;
- 被park的线程处于`WAITING`状态.
- unpark是以线程为单位进行唤醒的,可以明确指定;而notify只能随机唤醒.

### 4.9.3 原理:

每个线程都有一个Parker对象,由`_counter`,`_cond`和`_mutex`三部分组成.

>调用park方法,实质上就是检查`_counter`是否为0,并置0.
>调用unpark方法,实质上就是置`_counter`为1,并唤醒`_cond`中的线程.
#### 情况1:
**先调用park方法:**
1. 调用park方法,检查`_counter`,发现为0,则获取`_mutex`互斥锁;
2. 线程进入`_cond`条件变量阻塞;
3. 设置`_counter`为0.
**再调用unpark方法:**
1. 调用unpark方法,设置`_counter`为1;
2. 唤醒`_cond`条件变量中的阻塞线程,恢复运行;
3. 设置`_counter`为0

#### 情况2:
**先调用unpark方法:**
1. 调用unpark方法,设置_counter为1;
2. 此时调用park方法,检查`_counter`变量,发现为1,则无需阻塞,继续运行;
3. 设置`_counter`为0.

## 4.10 重新理解线程状态转换
![[Pasted image 20241021154238.png|450]]
### 情况1:NEW->RUNNABLE
调用`t.start()`方法,线程状态由NEW->RUNNABLE.

### 情况2:RUNNABLE<->WAITING
t线程调用了`synchronized(obj)`获取了对象锁:
- 调用`obj.wait()`方法,t线程会从`RUNNABLE->WAITING`;
- 调用`obj.notify()`,`obj.notifyAll()`,`t.Interrupt()`时,线程会被重新唤醒,竞争锁;
	- 竞争锁成功,t线程由`WAITING->RUNNABLE`
	- 竞争锁失败,t线程由`WAITING->BLOCKED`,进入阻塞状态.

### 情况3:RUNNABLE<->WAITING
- 当前线程调用了`t.join()`方法,当前线程由`RUNNABLE->WAITING`,即当前线程等待t线程运行结束.
- t线程运行结束后,或调用了当前线程的`Interrupt()`方法,当前线程由`WAITING->RUNNABLE`.

### 情况4:RUNNABLE<->WAITING
- 当前线程调用了`LockSupport.park()`方法,"可能"会让当前线程由`RUNNABLE->WAITING`
- 当前线程调用了`LockSupport.unpark(目标线程)`或调用了线程的`Interrupt()`方法,会由`WAITING->RUNNABLE`.
### 情况5:RUNNABLE<->TIMED_WAITING
t线程用`synchronized(obj)`获取了对象锁后
- 调用`obj.wait(long n)`方法,t线程由`RUNNABLE->TIMED_WAITING`
- t线程等待时间结束后,或被`notify(),notifyAll(),interrupt()`唤醒后:
	- 竞争锁成功,由`TIME_WAITING->RUNNABLE`
	- 竞争锁失败,由`TIMED_WAITING->BLOCKED`

### 情况6:RUNNABLE<->TIMED_WAITING
- 当前线程调用`t.join(long n)`方法时,当前线程会由`RUNNABLE->TIMED_WAITING`,等待线程t运行结束.
- t线程运行结束,或当前线程等待时间结束后,或当前线程调用`interrupt()`方法时,当前线程会有`TIMED_WAITING->RUNNABLE`

### 情况7:RUNNABLE<->TIMED_WAITING
- 当前线程调用`Thread.sleep(long n)`,会从`RUNNABLE->TIMED_WAITING`
- 睡眠时间结束后,会由`TIME_WAITING->RUNNABLE`

### 情况8:RUNNABLE<->TIMED_WAITING
- 当前线程调用`LockSupport.parkNanos(long nanos)`或`LockSupport.parkUntil(long millis)`时,当前线程会从`RUNNABLE->TIMED_WAITING`.
- 调用`LockSupport.unpark(目标线程)`或调用了线程的`interrupt()`,或是等待超时,会让目标线程从`TIMED_WAITING-> RUNNABLE`
### 情况9:RUNNABLE<->BLOCKED
- t线程用`synchronized(obj)`获取了对象锁时如果竞争失败,从`RUNNABLE->BLOCKED`
- 持`obj`锁线程的同步代码块执行完毕，会唤醒该对象上所有`BLOCKED`的线程**重新竞争**，竞争成功,则由`BLOCKED->RUNNABLE`;失败则继续`BLOCKED`.

### 情况10:RUNNABLE<->TERMINATED
当前线程所有代码运行完毕，进入`TERMINATED`

## 4.11 多把锁
运用更加细粒度的锁来增强程序的并发性.

只有一个对象锁`BigRoom`
```java
class BigRoom {  
    public void sleep() {  
        synchronized (this) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
    public void study() {  
        synchronized (this) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }
}
```
改进:
- 使用多个对象锁`studyRoom`和`bedRoom`来分别锁住不同业务操作.
```java
class BigRoom {  
    private final Object studyRoom = new Object();  
    private final Object bedRoom = new Object();  
  
    public void sleep() {  
        synchronized (bedRoom) {  
            log.debug("sleeping 2 小时");  
            Sleeper.sleep(2);  
        }  
    }  
  
    public void study() {  
        synchronized (studyRoom) {  
            log.debug("study 1 小时");  
            Sleeper.sleep(1);  
        }  
    }  
}
```

## 4.12 活跃性

### 4.12.1 死锁
一个线程需要同时获取多把锁，这时就容易发生死锁.
`t1`线程获得A对象锁,接下来想获取B对象的锁; `t2`线程获得B对象锁,接下来想获取A对象的锁,此时就会发生死锁问题: 两个线程分别都想获取对方的锁,都进入阻塞状态,

#### 死锁定位:
1. **利用jps查看java进程:**
![[Pasted image 20241021164632.png]]
2. **利用jstack查看进程状态**:`jstack 8772`
![[Pasted image 20241021164857.png]]

### 4.12.2 活锁
活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束.
**可通过设置随机睡眠时间来解决.** 
```java
public class TestLiveLock {  
    static volatile int count = 10;  
    static final Object lock = new Object();  
  
    public static void main(String[] args) {  
        new Thread(() -> {  
// 期望减到 0 退出循环  
            while (count > 0) {  
                sleep(0.2);  
                count--;  
                log.debug("count: {}", count);  
            }  
        }, "t1").start();  
        new Thread(() -> {  
// 期望超过 20 退出循环  
            while (count < 20) {  
                sleep(0.2);  
                count++;  
                log.debug("count: {}", count);  
            }  
        }, "t2").start();  
    }  
}
```

### 4.12.3 饥饿
一个线程由于优先级太低，**始终得不到 CPU 调度执行**，也不能够结束.


## 4.13 ReentrantLock
>**可用于解决上述的活跃性问题**.

相对于synchronized,具备如下特点:
- **可中断**
- **可以设置超时时间**
- **可以设置为公平锁**
- **支持多个条件变量**
- **都支持可重入**

**基本语法:**
```java
// 获取锁
reentrantLock.lock();
try {
	// 临界区
} finally {
	// 释放锁
	reentrantLock.unlock();
}
```

### 4.13.1 可重入:
可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此**有权利再次获取这把锁**.(可理解为:**未解锁,继续加锁**)
如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住.

**示例:**
- method1已经获取了锁,内部调用method2,`method2`**再次获取锁**,依然能成功,这就是可重入
```java
static ReentrantLock lock = new ReentrantLock();  
public static void main(String[] args) {  
    method1();  
}  
public static void method1() {  
    lock.lock();  
    try {  
        log.debug("execute method1");  
        method2();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method2() {  
    lock.lock();  
    try {  
        log.debug("execute method2");  
        method3();  
    } finally {  
        lock.unlock();  
    }  
}  
public static void method3() {  
    lock.lock();  
    try {  
        log.debug("execute method3");  
    } finally {  
        lock.unlock();  
    }  
}
```

### 4.13.2 可打断
>**可用于避免死锁的发生**

等待过程中,可以用`interrupt()`方法打断. 此时需要`lockInterruptibly()`方法加锁.


**示例:**
- t1线程调用`lockInterruptibly()`尝试获取锁,主线程调用`lock()`也获取锁;
- 下面代码执行过程:
	1) 主线程调用`lock.lock()`获取锁,并成功获取;
	2) t1线程启动,内部调用`lock.lockInterruptibly()`也尝试获取锁,但是由于锁已被主线程获取,所以t1线程进入阻塞队列等待;
	3) 调用`t1.interrupt()`打断t1的等待过程;
	4) 成功打断,t1线程捕获`InterruptedException`异常,并return返回,结束等待.
```java
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    try {  
        lock.lockInterruptibly();  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
        log.debug("等锁的过程中被打断");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  

lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(1);  
    t1.interrupt();  
    log.debug("执行打断");  
} finally {  
    lock.unlock();  
}
```

### 4.13.3 锁超时

- 使用`trylock()`方法获取锁,即获取失败立即返回,不会进行等待.
- 使用`trylock(long n,TimeUnits.SECONDS)`方法获取锁, 获取锁失败后会进入阻塞队列等待n秒.
- `trylock()`方法也支持`interrupt()`打断!
**示例:**
```java hl:4-6
ReentrantLock lock = new ReentrantLock();  
Thread t1 = new Thread(() -> {  
    log.debug("启动...");  
    if (!lock.tryLock()) {  
        log.debug("获取立刻失败，返回");  
        return;  
    }  
    try {  
        log.debug("获得了锁");  
    } finally {  
        lock.unlock();  
    }  
}, "t1");  
lock.lock();  
log.debug("获得了锁");  
t1.start();  
try {  
    sleep(2);  
} finally {  
    lock.unlock();  
}
```

#### 优化哲学家问题:

**优化前获取筷子的逻辑:**
使用`synchronized()`获取筷子(锁),获取不到时就会一直等待; 此时另一个"哲学家"也可能在使用`synchronized()`获取筷子,导致两个哲学家互相等待对方持有的锁,导致死锁问题.
```java
@Override  
public void run () {  
    while (true) {  
        // 获得左手筷子  
        synchronized (left) {  
        // 获得右手筷子  
            synchronized (right) {  
                // 吃饭  
                eat();  
            }  
            // 放下右手筷子  
        }  
        // 放下左手筷子  
    }  
}
```

**优化后的获取筷子逻辑:**
- 使用`trylock()`获取筷子,获取不到则返回!
- 注意使用`finally`保证能释放锁.

执行过程:
- `while(true)`尝试一直获取筷子. 使用两个if判断逻辑: 获取了左筷子,继续尝试获取右筷子,若获取失败,则先释放左筷子,在下一个循环再重新尝试获取左右筷子.
```java
@Override  
public void run() {  
    while (true) {  
        // 尝试获得左手筷子  
        if (left.tryLock()) {  
            try {  
                // 尝试获得右手筷子  
                if (right.tryLock()) {  
                    try {  
                        eat();  
                    } finally {  //释放右筷子
                        right.unlock();  
                    }  
                }  
            } finally {  //释放左筷子
                left.unlock();  
            }  
        }  
    }  
}
```

### 4.13.4 公平锁
>**synchronized锁是不公平锁,因为线程进入阻塞队列等待后,争抢锁时并不按进入队列的先后顺序.**

ReentrantLock默认不公平,但是可通过传入参数来创建公平锁.

```java 
public ReentrantLock(boolean fair) {  
    sync = fair ? new FairSync() : new NonfairSync();  
}
```

### 4.13.5 条件变量

`synchronized`中也有条件变量,就是我们讲原理时那个`waitSet`休息室,当条件不满足时进入`waitSet`等待.

**ReentrantLock支持多个条件变量!** 可很好地避免虚假唤醒.
- `synchronized`是那些不满足条件的线程都在一间休息室等消息
- 而` ReentrantLock `支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

#### 使用要点:
- 使用`lock.newCondition()`创建Condition类的实例对象,即条件变量.
- 调用`await()`方法前需要获取锁.
- 调用`conditionObject.await()`释放锁,并使当前线程进入`conditionObject`进行等待;
- 使用`conditionObject.signal()`来唤醒内部的线程重新竞争lock锁.

```java
static ReentrantLock lock = new ReentrantLock();  
static Condition waitCigaretteQueue = lock.newCondition();  
static Condition waitbreakfastQueue = lock.newCondition();  
static volatile boolean hasCigrette = false;  
static volatile boolean hasBreakfast = false;  
public static void main(String[] args) {  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasCigrette) {  
                try {  
                    waitCigaretteQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的烟");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    new Thread(() -> {  
        try {  
            lock.lock();  
            while (!hasBreakfast) {  
                try {  
                    waitbreakfastQueue.await();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
            log.debug("等到了它的早餐");  
        } finally {  
            lock.unlock();  
        }  
    }).start();  
    sleep(1);  
    sendBreakfast();  
    sleep(1);  
    sendCigarette();  
}  
private static void sendCigarette() {  
    lock.lock();  
    try {  
        log.debug("送烟来了");  
        hasCigrette = true;  
        waitCigaretteQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}  
private static void sendBreakfast() {  
    lock.lock();  
    try {  
        log.debug("送早餐来了");  
        hasBreakfast = true;  
        waitbreakfastQueue.signal();  
    } finally {  
        lock.unlock();  
    }  
}
```


