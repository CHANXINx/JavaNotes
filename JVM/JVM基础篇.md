# 1. 初识JVM
## 1.1 JVM介绍
JVM(Java Virtual Machine),本质上是一个**运行在计算机上的程序**，他的职责是**运行Java字节码文件。**

**Java源代码执行流程:**
1. **编写**源代码文件`.java`;
2. 源代码文件经javac编译器**编译**获得Java字节码文件`.class`;
3. 使用Java虚拟机**加载并运行**Java字节码文件，此时会启动一个新的进程.
![[Pasted image 20241029203953.png]]

## 1.2 JVM的功能
>解释和运行; 内存管理; 即时编译.
### 1.2.1 解释和运行
JVM对字节码(class)文件中的指令，**实时的解释成机器码**，让计算机执行。

字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令**实时地解释成机器码**，机器码是计算机可以运行的指令。
- 实现了跨平台性.

### 1.2.2 内存管理
JVM:1)自动为对象,方法等分配内存,以及2)提供了自动的垃圾回收机制.

### 1.2.3 即时编译
JIT即时编译器对热点代码进行优化,提高执行效率.

若JVM在运行过程中发现某处代码是热点代码,JIT会优化这段代码并**将优化后的机器码保存在内存**中,下次调用时,JVM会将机器码**从内存中取出直接调用**,无需再进行解释,提高执行效率.


# 2. 字节码文件详解
## 2.1 Java虚拟机的组成

![[Pasted image 20241029204832.png]]
- 类加载子系统：核心组件类加载器，负责将**字节码文件中的内容加载到内存中**。
- 运行时数据区: JVM管理的内存,创建的对象,类信息等内容都存放于此.
- 执行引擎: 包含了即时编译器、解释器、垃圾回收器.
	- 执行引擎使用**解释器将字节码指令解释成机器码**
	- 使用**即时编译器优化性能**
	- 使用**垃圾回收器回收不再使用的对象**
- 本地接口: 调用本地使用C/C++编译好的方法,本地方法在Java中声明时，都会带上`native`关键字

## 2.2 字节码文件的组成
字节码文件总共可以分为以下几个部分：
- 基础信息：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息
- 常量池： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用
- 字段： 当前类或接口声明的字段信息
- 方法： 当前类或接口声明的方法信息，核心内容为方法的字节码指令
- 属性： 类的属性，比如源码的文件名、内部类的列表等

### 2.2.1 基础信息
#### 2.2.1.1 魔数
- 文件是无法通过文件扩展名来确定文件类型的，**文件扩展名可以随意修改不影响文件的内容**.
- 软件会使用**文件的头几个字节**（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。

故字节码文件(.class)也需要文件头来确定文件类型,称为魔数,值为`0xcafebabe`.

#### 2.2.1.2 主副版本号
主副版本号指的是**编译字节码文件时使用的JDK版本号**,主版本号用来标识大版本号,副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。

1.2之后的主版本号为 `主版本号-44`,例如主版本号52就是JDK8.

版本号的作用主要是**判断当前字节码的版本和运行时的JDK是否兼容**。例如低版本的JDK无法运行高版本的字节码文件.
- 解决办法:1)升级JDK(不推荐); 2)将第三方依赖的版本号降低以满足要求(推荐).

#### 2.2.1.3 其他基础信息
除了魔数,主副版本号,还包括访问标志(public),类和接口索引等.
![[Pasted image 20241029235223.png]]

### 2.2.2 常量池
常量池的作用：避免相同的内容重复定义,节省空间.

保存了字符串常量,类或接口名,字段名,主要在字节码指令中使用.

例如代码中定义了`String s1 = "Hello!!!";String s2 = "Hello!!!";`, 则可以看到常量池中只保存了一份字符串及其字面量. 
![[Pasted image 20241030000433.png]]![[Pasted image 20241030000517.png]]

字段或字节码指令中可以通过编号来快速找到字符串.
	● 字节码指令中通过编号引用到常量池的过程称之为**符号引用**.

**字节码指令中的引用:**
![[Pasted image 20241030000707.png]]
**字段中的引用:**
![[Pasted image 20241030000829.png]]
### 2.2.3 字段
当前类或接口声明的字段信息
![[Pasted image 20241029234821.png]]
- 当前类中有s1和s2两个字段
### 2.2.4 方法
字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容存放在方法的Code属性中。
![[Pasted image 20241029215421.png]]
![[Pasted image 20241029215357.png]]

**操作数栈**是用来存放**临时**数据的内容，是一个栈式的结构，先进后出。
**局部变量表(数组)** 是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。 

#### 示例:通过字节码分析方法的执行流程

```Java
int i = 0; 
i = i++;
```
问此时i的值是多少?

字节码:
```bash hl:4
0 iconst_0     :将常量0放到操作数栈中
1 istore_1     :将操作数栈中的队顶元素存放到局部变量表下标为1的位置
2 iload_1      :将下标为1的元素复制到操作数栈中.
3 iinc 1 by 1  :将局部变量表1号位置元素+1.(直接操作局部变量表元素!!)
6 istore_1     :将操作数栈中的值存放到下标为1的位置,仍是0!!
7 return
```
- 可以看到,i++首先把0取出放到操作数栈中,之后对i进行加1操作,此时局部变量表中的i变为1,最后再将操作数栈中的临时值0存入局部变量表中,覆盖了先前的+1操作,所以最后i=0.


```java
int i = 0;  
i = ++i;
```

```bash
0 iconst_0
1 istore_1
2 iinc 1 by 1
5 iload_1
6 istore_1
7 return
```
- 可以看到,区别在于这里是先自增(`0->1`),再加载到操作数栈中(`加载的是1`),所以最后执行store,存放的也是i=1.

### 2.2.5 属性
属性主要指的是**类的属性**，比如源码的文件名、内部类的列表等。
![[Pasted image 20241029232613.png]]
## 2.3 字节码常用工具
### 2.3.1 javap
javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。**适合在服务器上查看字节码文件内容。**

### 2.3.2 jclasslib
IDEA插件,可在代码编译后试试看到字节码文件内容.

### 2.3.3 Arthas
Arthas 是一款**线上监控诊断产品**，通过全局视角实时查看应用 **load、内存、gc、线程的状态信息**，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。

dump命令: 将字节码文件保存到本地.
jad命令: 将类的字节码文件进行**反编译成源代码**，用于确认服务器上的字节码文件是否是最新的.

## ==2.4 类的生命周期==
类的生命周期描述了一个类**加载、连接、初始化、使用、卸载**的整个过程.
	其中,初始化可进一步细分为验证,准备,解析三个阶段.
![[Pasted image 20241030091314.png]]
### 2.4.1 加载阶段

1. 加载(Loading)阶段第一步是类加载器**根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息**，程序员可以使用Java代码拓展的不同的渠道.
	1) 本地磁盘获取文件
	2) 运行时动态代理生成
	3) Applet技术通过网络获取字节码文件(已淘汰)
2. 类加载器加载完类后,JVM会**将字节码信息保存到方法区中**,方法区中生成一个InstanceKlass对象,保存类的所有信息,里边还包含实现特定功能.
   ![[Pasted image 20241030091755.png|450]]
3. Java虚拟机同时会在**堆上生成与方法区中数据类似的java.lang.Class对象**，作用是在Java代码中去**获取类的信息**以及存储静态字段的数据（JDK8及之后）
	- 例如反射,就是从堆区获取类的信息.
	- 方法区中的InstanceKlass对象是由C++编写的,无法访问. 所以在堆区中创建了使用java语言包装的对象供程序员使用.
	- 堆区中的方法,字段信息少于方法区,只保留了必要的,保证安全性的内容.
   ![[Pasted image 20241030092056.png|450]]

### 2.4.2 连接阶段
连接阶段分为三个子阶段:
- 验证: 验证内容是否满足《Java虚拟机规范》。
- 准备: 给**静态变量**赋初值。
- 解析: **将常量池中的符号引用替换成指向内存的直接引用**。

#### 2.4.2.1 验证
验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。主要包含四部分:

1. **文件格式验证.** 验证文件是否以0xCAFEBABE开头,验证主次版本号是否满足JVM版本要求.
2. **元信息验证.** 例如类必须有父类(父类索引不为空).
3. **验证程序执行指令的语义.** 检查方法内指令的跳转,避免出错.
4. **符号引用验证.** 例如是否访问了其他类中private的方法等.
![[Pasted image 20241030095756.png]]

#### 2.4.2.2 准备
准备阶段**为==静态==变量（static）分配内存并设置初值**，每一种基本数据类型和引用数据类型都有其初值。
	● 在初始化阶段才会将value赋为用户定义的值.

**基本引用类型和引用数据类型的初值:**
![[Pasted image 20241030095938.png]]

**注意:**
- 若变量**用`final`修饰,则在准备阶段就直接赋值**,因为在后续阶段不会发生值的变更.

#### 2.4.2.3 解析
解析阶段主要是**将常量池中的符号引用替换为直接引用**.
	● 符号引用就是在字节码文件中使用编号来访问常量池中的内容。
	● 直接引用不在使用编号，而是**使用内存中地址**进行访问具体的数据。
	![[Pasted image 20241030101432.png]]

### 2.4.3 初始化阶段
#### 2.4.3.1 介绍
初始化阶段会执行字节码文件中**clinit**（class init 类的初始化）方法的字节码指令，**包含了静态代码块中的代码，并为静态变量赋值**。

```java
public class ClinitTest {  
    public static int value = 1;  
    static {  
        value = 2;  
    }  
    
    public static void main(String[] args) {  
    }  
}
```

**clinit方法:**
```bash hl:2
0 iconst_1                               : 将常量1放入操作数栈.
1 putstatic #7 <ClinitTest.value : I>#   : 弹出操作数栈的值,为#7(编号7)的静态变量赋值.
4 iconst_2                               : 将常量2放入操作数栈.
5 putstatic #7 <ClinitTest.value : I>    : 为静态变量#7赋值.
8 return
```

#### 2.4.3.2 执行时刻:
1. 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化;
2. 调用Class.forName(String className)。
3. new一个该类的对象时
4. 执行Main方法的当前类

##### 小测:
```Java
public class Test1 {
    public static void main(String[] args) {
        System.out.println("A");
        new Test1();
        new Test1();
    }

    public Test1(){
        System.out.println("B");
    }

    {
        System.out.println("C");
    }

    static {
        System.out.println("D");
    }
}
```
执行结果: 
```bash
D	（静态代码块，类加载时执行一次）
A	（main 方法中的第一个输出）
C	（第一个对象初始化代码块）
B	（第一个对象构造方法）
C	（第二个对象初始化代码块）
B	（第二个对象构造方法）
```
	
D是静态代码块,类加载时就会初始化,所以首先执行;
A是main方法执行时打印;
C是初始化代码块,在new该类对象时会执行,所以`new Test1()`时会打印C;
B是构造方法,也是new对象时打印.
并且D是静态初始化,只会在类加载时执行一次.C是普通初始化,只要有对象创建就会执行.

#### 2.4.3.3 clinit不会执行的几种情况
1. 无静态代码块且无静态变量赋值语句.
2. 有静态变量的声明,但是没有赋值:`public static int i;`
3. 静态变量使用final修饰,则会在准备阶段进行初始化.

#### 2.4.3.4 带继承的情况:
- 直接访问父类的静态变量,不会触发子类的初始化;
- 初始化子类之前,会先初始化父类.

**示例:**
```Java
public class Demo01 {
    public static void main(String[] args) {
        new B02();
        System.out.println(B02.a);
    }
}

class A02{
    static int a = 0;
    static {
        a = 1;
    }
}

class B02 extends A02{
    static {
        a = 2;
    }
}
```
**输出为2**

创建BO2对象时,会先初始化父类A02,所以此时`a=1`,然后再执行子类初始化,此时`a=2`.

## 2.5 类加载器
### 2.5.1 什么是类加载器
类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的**字节码获取并加载到内存**这一部分。
![[Pasted image 20241030141117.png]]
类加载器会通过二进制流的方式**获取到字节码文件的内容**，接下来将获取到的数据**交给Java虚拟机**，虚拟机**会在方法区和堆上生成对应的对象保存字节码信息**。

### 2.5.2 类加载器的分类 
类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。
1. **虚拟机底层实现**：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是**保证Java程序运行中==基础类==被正确地加载**，比如java.lang.String，Java虚拟机需要确保其可靠性。
2. **JDK中默认提供或者自定义**：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。**所有Java中实现的类加载器都需要继承ClassLoader这个抽象类**

#### JDK8及之前的分类:
三大类加载器:
**1)BootstrapClassLoader; 2)ExtClassLoader; 3)AppClassLoader**
![[Pasted image 20241030141644.png]]
### 2.5.3 启动类加载器
- 启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。
- 默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。
- 使用getClassLoader获取类加载器时,**返回值是null**,因为是由C++编写,所以不适合获取.


#### 2.5.3.1 使用启动类加载器加载拓展类:
1. **方法1:** **放入jre/lib下进行扩展**. 不推荐,因为启动类加载器会校验jar包的文件名,所以扩展类可能会由于文件名不匹配而不被加载.
2. **方法2: 使用参数进行扩展.** 使用`-Xbootclasspath/a:jar包目录/jar包名` 进行扩展.
	**例如:**`-Xbootclasspath/a:E:\OneDrive\Java_Learn\JVM\classloader-test\target\classloader-test.jar`

### 2.5.4 扩展类加载器和应用程序类加载器
- 扩展类加载器和应用程序类加载器都是**JDK中提供的、使用Java编写**的类加载器。
- 它们的源码都位于sun.misc.Launcher中，是一个静态内部类。**继承自URLClassLoader**。具备**通过目录或者指定jar包将字节码文件加载到内存中**。
	- 继承关系如图:![[Pasted image 20241030145201.png]]

#### 2.5.4.1 扩展类加载器
扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。**默认加载Java安装目录/jre/lib/ext下的类文件。**

**通过扩展类加载器去加载用户jar包:**
- **放入/jre/lib/ext下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容。
- **使用参数进行扩展使用参数进行扩展**。推荐，使用`-Djava.ext.dirs=jar包目录` 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录
	- `-Djava.ext.dirs=jdk自带jar包目录;用户jar包目录`

#### 2.5.4.2 应用程序加载器
应用程序类加载器会加载**classpath下的类文件**，默认加载的是**项目中的类以及通过maven引入的第三方jar包中的类。**

## ==2.6 双亲委派机制==
>**解决一个类到底是由谁加载的问题.**

### 2.6.1 介绍
双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会**自底向上查找是否加载过，再由顶向下进行加载**。![[Pasted image 20241030152830.png]]
>因为启动类加载器不可获得,所以扩展类加载器的父类为null
### 2.6.2 双亲委派机制的作用:
1. **保证类加载的安全性**。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。
	- 因此String类会在自底向上的查找过程中被找到,所以不会被覆盖.
2. **避免重复加载**。双亲委派机制可以避免同一个类被多次加载。

### 2.6.3 如何指定加载类的类加载器？
1. **方式1:** 使用Class.forName方法，使用当前类的类加载器去加载指定的类。
2. **方式2:** 获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。

```java
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();  
System.out.println(classLoader);  
  
Class<?> aClass = classLoader.loadClass("com.chanxin.my.B");  
Object o = aClass.newInstance();
```
通过`getClassLoader()`方法获取类加载器;
使用`loadClass()`方法加载类.

### 2.6.4 打破双亲委派机制
**共三种方法:**
1. **自定义类加载器并且重写loadClass方法**。Tomcat通过这种方式实现应用之间类隔离.
2. **线程上下文类加载器**。利用上下文类加载器加载类，比如JDBC和JNDI等。
3. ~~**Osgi框架的类加载器**。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。~~

#### 2.6.4.1 自定义类加载器

##### ClassLoader的核心方法:
```Java
public Class<?> loadClass(String name)
类加载的入口，提供了双亲委派机制。内部会调用findClass   重要

protected Class<?> findClass(String name)
由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要

protected final Class<?> defineClass(String name, byte[] b, int off, int len)
做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中

protected final void resolveClass(Class<?> c)
执行类生命周期中的连接阶段
```
##### loadClass方法:


#### 2.6.4.2 线程上下文类加载器

#### 2.6.4.3 Osgi框架的类加载器

## 2.7 JDK9之后的类加载器
由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。
1. 启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。
   Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。
   启动类加载器**依然无法通过java代码获取**到，返回的仍然是null，保持了统一。

2. **扩展类加载器被替换成了平台类加载器**（Platform Class Loader）。
   平台类加载器遵循模块化方式加载字节码文件，所以**继承关系从URLClassLoader变成了BuiltinClassLoader**，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。