# 1. 栈上的数据存储
![[Pasted image 20241103133240.png]]
- long和double会占用局部变量表中的两个槽位。虽然对于64位虚拟机来说，有点浪费内存，但是能保证更好的通用性，避免了不同数据类型不同处理方式带来的时间开销。
- 数据在操作数栈中和局部变量表中占据相同的内存。
![[Pasted image 20241103133320.png]]
## 1.1 boolean类型数据类型保存方式
```java
        boolean a = false;
        if(a){
            System.out.println("a为true");
        }else{
            System.out.println("a为false");
        }

        if(a == true){
            System.out.println("a为true");
        }else{
            System.out.println("a为false");
        }
```
=>字节码为:
```bash hl:3-4,12-14
 0 iconst_0
 1 istore_1
 2 iload_1
 3 ifeq 17 (+14)
 6 getstatic #7 <java/lang/System.out : Ljava/io/PrintStream;>
 9 ldc #13 <a为true>
11 invokevirtual #15 <java/io/PrintStream.println : (Ljava/lang/String;)V>
14 goto 25 (+11)
17 getstatic #7 <java/lang/System.out : Ljava/io/PrintStream;>
20 ldc #21 <a为false>
22 invokevirtual #15 <java/io/PrintStream.println : (Ljava/lang/String;)V>
25 iload_1
26 iconst_1
27 if_icmpne 41 (+14)
30 getstatic #7 <java/lang/System.out : Ljava/io/PrintStream;>
33 ldc #13 <a为true>
35 invokevirtual #15 <java/io/PrintStream.println : (Ljava/lang/String;)V>
38 goto 49 (+11)
41 getstatic #7 <java/lang/System.out : Ljava/io/PrintStream;>
44 ldc #21 <a为false>
46 invokevirtual #15 <java/io/PrintStream.println : (Ljava/lang/String;)V>
49 return

```
- 可以看到，对boolean类型、byte类型等占用一个槽位的变量（除了folat），是**直接当成int类型来处理**，并且true对应1，false对应0.
- `if(a)`的比较逻辑为load局部变量表中的数据到操作数栈，使用ifeq判断是否为0，相等则跳1转到17行；
- `if(a==true)`的比较逻辑为load局部变量表中的数据到操作数栈，并且将true（常量1）放入操作数栈中，使用`if_icmpne`判断操作数栈顶部两个元素是否相等,不相等则跳转到41行。

若将字节码修改为
```java
 0 iconst_2
 1 istore_1
 2 iload_1
 3 ifeq 17 (+14)
```
即将boolean类型的元素a的值修改为2，则使用ifeq判断为false，会直接打印`a为true`；而使用`if_icmpne`判断，也是`2不等于1`，则会直接跳转到41行，打印`a为false`

## 栈中的数据要保存到堆上或者从堆中加载到栈上时怎么处理？
1. 堆中的数据加载到栈上，由于栈上的空间**大于或者等于**堆上的空间，所以直接处理但是需要注意下符号位。（**小空间到大空间，需要进行填充**）
	- **boolean、char为无符号，低位复制，高位补0.**
		- 堆上占用2个字节，而栈上一个槽位占用8/4个字节，所以需要进行补0.
		 ![[Pasted image 20241103140844.png]]
		 ![[Pasted image 20241103141203.png]]
	- **byte、short为有符号，低位复制，高位非负则补0，负则补1**
		- ![[Pasted image 20241103141241.png]]
		  ![[Pasted image 20241103141250.png]]
2. 栈中的数据要保存到堆上，byte(1字节)、char(2字节)、short(2字节)由于**堆上存储空间较小**，需要将高位去掉。**boolean比较特殊，只取低位的最后一位保存**。
	- 例如，堆上1个字节，而栈上4个字节，所以高位直接去掉。![[Pasted image 20241103142722.png]]
# 2. 对象在堆上的存储 
对象在堆中的**内存布局**，指的是**对象在堆中存放时的各个组成部分**，主要分为以下几个部分：![[Pasted image 20241103142925.png]]
## 2.1 标记字段
标记字段相对比较复杂。在不同的对象状态（有无锁、是否处于垃圾回收的标记中）下存放的内容是不同的，同时在64位（又分为是否开启指针压缩）、32位虚拟机中的布局都不同。
	**标记字段在64位虚拟机中占用8个字节。**
- 以64位开启指针压缩为例：![[Pasted image 20241103143455.png]]![[Pasted image 20241103145431.png]]

## 2.2 元数据的指针
在64位的Java虚拟机中，Klass Pointer以及对象数据中的对象引用都需要占用8个字节，为了减少这部分的内存使用量，64 位 Java 虚拟机使用指针压缩技术，**==将堆中原本8个字节的指针压缩成4个字节==**。![[Pasted image 20241103150949.png]]
### 2.2.1 指针压缩
指针压缩的思想是**将寻址的单位放大**，比如原来按1字节去寻址，现在可以按8字节寻址。如下图所示，原来按1去寻址，能拿到1字节开始的数据，现在按1去寻址，就**可以拿到8个字节开始的数据**。
![[Pasted image 20241103151443.png]]

**指针压缩存在的问题：**
1. 需要进行内存对齐，指的是**将对象的内存占用填充至8字节的倍数**，存在空间浪费。![[Pasted image 20241103151628.png]]
2. 寻址大小减小，最多只能支持$2^{35}$个字节。
	- 未开启指针压缩时，对象占用8个字节，共64位，所以寻址的大小为$2^{64}$位，共16EB。
	- 开启指针压缩后，每个对象只占用4个字节(32位)。但是每一个位会放大为原来的8倍，所以共占用$2^{3}\times2^{32}=2^{35}$，为32GB。
## 2.3 内存对齐
内存对齐指的是对象中会空出来几个字节，不做任何数据存储。
- int占用4个字节，long占用8个字节，String引用类型开启指针压缩后占用4个字节，一共16个字节。16+对象头12个字节一共是28个字节，不能被32整除，所以填充了4个字节。
  ![[Pasted image 20241103153743.png]]

- 内存对齐主要目的是为了解决并发情况下CPU缓存失效的问题。
	- 在未进行内存对齐时，此时若A写入数据，由于A和B在同一个缓存行，所以会导致A和B的缓存数据失效，导致B读取数据的效率大大降低！
	![[Pasted image 20241103154324.png]]
- 内存对齐解决了这个问题：**内存对齐之后，同一个缓存行中不会出现不同对象的属性**。在并发情况下，如果让A对象一个缓存行失效，是不会影响到B对象的缓存行的。![[Pasted image 20241103154447.png]]

### 2.3.1 字段重排列
- 内存对齐要求每个对象字节数是8的倍数，除了添加字节填充之外，还有字段的要求，即要求`偏移量能被SIZE整除`，这样更容易让一个字段在一整个缓存行中，提高读取缓存行的效率。
	- 例如id原本定义在age上方，但是由于字段重排，这里将id放在下方，使其编译量为16，正好是SIZE的2倍。![[Pasted image 20241103154947.png]]
- 并且，引用数据类型默认在基本数据类型下方，所以当无法通过重排满足要求时，会**在属性之间插入一块对齐区域来达到目的。**
	- String类型若在偏移量为28处，则无法被8整除，需要进行内存对齐，所以在age和String之间插入了一块对齐区域，用来保证String类型的偏移量为32，能被8整除。![[Pasted image 20241103155338.png]]
- **子类继承自父类的属性，并且子类中的父类属性的偏移量和父类是一致的。**

# 3. 方法调用的原理
方法调用的本质是通过执行相应的字节码指令，在栈上创建栈帧，并执行调用方法的字节码指令。

**方法调用的字节码指令：**
>通过调用invokew方法找到字节码指令并执行。
1. `invokestatic`:调用静态方法
2. `invokespecial`:调用对象的private、构造方法，以及使用super关键字调用父类实例的方法、构造方法，以及所使用接口的默认方法。
3. `invokevirtual`:调用对象的非private方法。
4. `invokeinterface`：调用接口对象方法。动态绑定，使用接口表找到方法的地址，进行调用。
5. `invokedynamic`：调用动态方法，主要用于lambda表达式。

Invoke指令执行时，需要找到方法区中instanceKlass中保存的方法相关的字节码信息。

## 3.1 静态绑定
1. 编译期间，invoke指令会携带一个参数符号引用，引用到常量池中的方法定义。方法定义中包含了`类名 + 方法名 + 返回值 + 参数`。 
   `0 invokestatic #7 <booleanTest.study : ()V>`：引用了常量池中编号为7的数据，对应内容为![[Pasted image 20241103194438.png]]
   其中，类名为`booleanTest`，方法名为`study()`，参数为`()`，返回值为`V`。
2. 在方法第一次调用时，这些符号引用就会被**替换成内存地址的直接引用**，这种方式称之为静态绑定。

静态绑定适用于处理**静态方法、私有方法、或者使用final修饰的方法**，因为这些方法不能被继承之后重写。

## 3.2 动态绑定
多态的方法调用字节码：
```java
Animal animal = new Cat();  
animal.eat();
```

```bash
 9 invokevirtual #10 <Animal.eat : ()V>
```
![[Pasted image 20241103195313.png]]

可以看到,方法引用实质上是引用的Animal抽象类的eat()方法，所以需要动态绑定找到Cat类的eat方法，从而实现多态！

动态绑定是基于**方法表**来完成的，invokevirtual使用了虚方法表（vtable），invokeinterface使用了接口方法表(itable)，整体思路类似。

### 3.2.1 虚方法表
- **每个类中都有一个虚方法表**，本质上它是一个数组，记录了方法的地址。
- 子类方法表中包含父类方法表中的所有方法；子类如果重写了父类方法，则使用自己类中方法的地址**进行替换**。
![[Pasted image 20241103200050.png]]
- 产生`invokevirtual`调用时，先根据对象头中的类型指针(Klass Pointer)找到方法区中InstanceClass对象，获得虚方法表。再根据虚方法表找到对应的方法，获得方法的地址，最后调用方法。![[Pasted image 20241103200209.png]]

# 4. 异常捕获的原理
异常捕获机制的实现，需要借助于编译时生成的**异常表**。

## 4.1 异常表
异常表在编译期生成，存放的是代码中异常的处理信息，包含了**异常捕获的生效范围**以及**异常发生后跳转到的字节码指令位置**。

- HandlerPC指的是捕获异常后跳转到的位置
  ![[Pasted image 20241103202820.png]]
	- `astore_1`是将操作数栈中的元素放到局部变量表的1号位置，即异常对象的地址。接着可通过异常对象的地址调用其内部的方法，例如`e.printStackTrace()`
	  ![[Pasted image 20241103202927.png]]
## 4.2 异常捕获
- 程序运行中触发异常时，Java 虚拟机会**从上至下遍历异常表中的所有条目**。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。
	- 匹配，则跳转到“Handler PC”中所指的字节码位置；
	- 若不存在匹配的异常，说明异常无法在当前方法中被捕获，则栈帧中弹出该方法，在上一层栈帧中进行异常捕获的查询
- 多个catch分支情况下，异常表**会从上往下遍历，先捕获RuntimeException**，如果捕获不了，再捕获Exception。

## 4.3 finally处理
1. finally中的字节码指令会插入到try和catch代码块字节码之后,保证在try和catch执行之后一定会执行finally中的代码。
   ![[Pasted image 20241103204027.png]]
2. 如果抛出的异常范围超过了Exception，比如Error或者Throwable，此时也要执行finally，所以异常表中**增加了两个条目**，覆盖了try和catch两段字节码指令的范围，any代表可以捕获所有种类的异常。![[Pasted image 20241103204133.png]]
	- 最后会将异常继续向外抛出。![[Pasted image 20241103204301.png|400]]

# 5. JIT即时编译器
JIT即时编译器会将执行频率高的字节码指令（热点代码）编译成机器码并**进行优化**，然后**保存在内存中**，将来执行时直接读取就可以运行在计算机硬件上了。

- 等级2和3都需要记录额外信息，所以性能会比等级1差，但是记录额外信息有助于C2的优化。
![[Pasted image 20241103204840.png]]
- C1和C2进行优化时，采用独立的线程进行个工作，内部会保存一个队列，队列中存放需要编译的任务。![[Pasted image 20241103205144.png]]

## 5.1 C1和C2的工作流程
1. 先由C1执行过程中收集所有运行中的信息，方法执行次数、循环执行次数、分支执行次数等等，然后等待**执行次数触发阈值**（分层即时编译由JVM动态计算）之后，进入C2即时编译器进行深层次的优化。![[Pasted image 20241103205231.png]]
2. 方法字节码执行数目过少，先收集信息，JVM判断C1和C2优化性能差不多，那之后**转为不收集信息，由C1直接进行优化**。

3. C1线程都在忙碌的情况下，直接由C2进行优化。

1. C2线程忙碌时，先由2层C1编译收集一些基础信息，多运行一会儿，然后再交由3层C1处理，由于3层C1处理效率不高，所以**尽量减少这一层停留时间**（C2忙碌着，一直收集也没有意义），最后C2线程不忙碌了再交由C2进行处理。

## 5.2 JIT优化手段
JIT的主要优化手段为**方法内联**和**逃逸分析**。

### 5.2.1 方法内联
方法内联（Method Inline）：**方法体中的字节码指令直接复制到调用方的字节码指令中，节省了创建栈帧的开销。**![[Pasted image 20241103205832.png]]
**方法内联优化的限制：**
1. 方法编译之后的字节码**指令总大小 < 35字节**，可以直接内联。（通过`-XX:MaxInlineSize=值` 控制）
2. 方法编译之后的字节码**指令总大小 < 325字节，并且是一个热方法**。
3. 方法编译生成的机器码不能大于1000字节。
4. 一个接口的实现必须小于3个，如果大于三个就不会发生内联。

### 5.2.2 逃逸分析
逃逸分析指的是如果JIT发现在方法内创建的对象**不会被外部引用**，那么就可以采用锁消除、标量替换等方式进行优化。

#### 5.2.2.1 锁消除
如果对象不会被外部引用，那么就不存在并发安全问题，则对象上的锁都不会执行，从而提高性能。（较少出现）

#### 5.2.2.2 标量替换
在Java虚拟机中，对象中的**基本数据类型称为标量**，引用的其他对象称为聚合量。标量替换指的是如果方法中的对象不会逃逸，那么**其中的标量就可以直接在栈上分配**，甚至于new对象的操作都会被省略。
![[Pasted image 20241103211519.png]]

## 5.3 总结
1. 尽量编写比较小的方法，避免字节码指令总大小过大，让方法内联可以生效。
2. 高频代码，如果内容过于复杂，可能导致字节码大小过大。可以自己实现核心功能，并且让字节码尽可能小。
3. 注意下接口的实现数量，尽量不要超过2个，否则会影响内联的处理。
4. 高频调用的方法中**创建对象临时使用**，尽量不要让对象逃逸。

# 6. 垃圾回收器
## 6.1 G1垃圾回收器

### 6.1.1 年轻代回收^
年轻代回收只扫描年轻代对象（Eden + Survivor），所以从GC Root到年轻代的对象或者年轻代对象引用了其他年轻代的对象都很容易扫描出来。 ![[Pasted image 20241104001010.png]]

### 6.1.2 混合回收^
- 多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值（默认45%）时会触发混合回收MixedGC。
- 混合回收会由年轻代回收之后或者大对象分配之后触发，混合回收会回收 `整个年轻代 + 部分老年代。`
- 老年代很多时候会有大量对象，要标记出所有存活对象耗时较长，所以整个标记过程要尽量能做到和用户线程**并行执行**，避免单线程阻塞用户线程。

**混合回收的步骤：**
1. **初始标记**，STW，采用**三色标记法**标记从GC Root可直达的对象。
2. **并发标记**，并发执行，对存活对象进行标记。
3. **最终标记**，STW，处理SATB相关的对象标记。
4. **清理**，STW，如果区域中没有任何存活对象就直接清理。
5. **转移**，将存活对象复制到别的区域。

#### 初始标记^
- 初始标记会**暂停所有用户线程**，只标记从GC Root可直达的对象，所以停顿时间不会太长。
- 采用三色标记法进行标记，三色标记法在原有双色标记（黑也就是1代表存活，白0代表可回收）**增加了一种灰色，采用队列的方式保存标记为灰色的对象。**
	- 黑色：存活，当前对象在GC Root引用链上，同时他引用的其他对象也都已经标记完成。
	- 灰色：待处理，当前对象在GC Root引用链上，他引用的其他对象还未标记完成。
	- 白色：可回收，不在GC Root引用链上。

#### 并发标记^
- 接下来进入并发标记阶段，继续进行未完成的标记任务。此阶段和用户线程并发执行。
- 从灰色队列中**获取尚未完成标记的对象B**。标记B关联的A和C对象，由于A和C对象并未引用其他对象，可以直接标记成黑色，而B也完成了所有引用对象的标记，也标记为黑色。
- 最后从队列获取C对象，标记为黑色，E也标记为黑色。所以剩余对象F就是白色，可回收。

**SATB**

## 6.2 ZGC原理
ZGC 是一种可扩展的低延迟垃圾回收器。ZGC 在垃圾回收过程中，STW的时间不会超过一毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。


### 6.2.1 ZGC执行流程
- 转移过程并发执行，避免了过长的STW时间。
   ![[Pasted image 20241104142304.png]]
#### G1转移时需要停顿的主要原因
转移完之后，需要将**A对对象的引用更改为新对象的引用**。但是在更改前，执行A.c.count = 2，此时更改的是转移前对象中的属性，如下：![[Pasted image 20241104142742.png]]
属性修改完成后，更改对象引用，此时A.c.count的值仍为1，这样就导致了并发安全问题。所以G1垃圾回收器需要停止用户线程的进行。![[Pasted image 20241104142839.png]]
#### ZGC的并发转移过程的解决方案
ZGC使用了**读屏障技术**来实现转移后用户对象的获取。通过在获取对象引用后插入判断语句“是否为转移后对象的引用”来避免属性的错误修改。若引用指向的非转移后对象，则会**先将引用指向转移后对象，再进行属性的赋值。**
![[Pasted image 20241104143255.png|400]]![[Pasted image 20241104143259.png|400]]
ZGC通过着色指针判断引用对象是转移前还是转移后的。
##### 着色指针
着色指针将原来的**8字节保存地址的指针拆分成了三部分**：![[Pasted image 20241104143953.png]]
1. 最低的44位，用于表示对象的地址，所以最多能表示16TB的内存空间。($2^{64}$->$2^{44}$)
2. **中间4位是颜色位，用于保存当前对象所属状态，每一位只能存放0或者1，并且同一时间只有其中一位是1。**
	- 终结位：只能通过终结器访问；
	- 重映射位：转移完以后，引用关系已完成变更。
	- M0和M1：标记可达对象。

访问对象引用时，使用的是对象的地址。在64位虚拟机中，8个字节可以表示接近无限的内存空间。所以一般内存中对象，高几位都是0没有使用。**着色指针就是利用了这多余的几位，存储了状态信息。**

应用程序使用的对象地址，只是虚拟内存，操作系统会将虚拟内存转换成物理内存。而ZGC通过操作系统更改了这层逻辑。**所以不管颜色位变成多少，指针指向的都是同一个对象。**![[Pasted image 20241104144346.png]]

##### ZGC的内存划分：
在ZGC中，与G1垃圾回收器一样将堆内存划分成很多个区域，这些内存区域被称之为Zpage。
Zpage分成三类大中小，**管控粒度比G1更细，这样更容易去控制停顿时间**。
- 小区域：2M，只能保存256KB内的对象。
- 中区域：32M，保存256KB – 4M的对象。
- 大区域：只保存一个大于4M的对象。

### 6.2.1 初始标记阶段
初始阶段会标记**GC Roots直接关联的对象**，对引用这些对象的指针上的**marked0位标记为1**：
- GC Roots直接关联对象为1,2,4，所以直接将M0标记为1.
  ![[Pasted image 20241104144631.png]]
### 6.2.2 并发标记阶段
遍历所有对象，标记可以到达的每一个对象是否存活，**用户线程使用读屏障，如果发现对象没有完成标记也会帮忙进行标记。**
- 遍历所有对象，发现5和8都可达，所以将5和8的M0标记为1.![[Pasted image 20241104144803.png]]
### 6.2.3 并发处理阶段
选择需要转移的Zpage，并创建**转移表**，用于记录转移前对象和转移后对象地址。
- 这里在第二和第三个Zpage处创建了转移映射表。
![[Pasted image 20241104145056.png]]
### 6.2.4 转移开始阶段
**转移GC Root直接关联的对象**，不转移的对象remapped值设置成1，避免重复进行判断。
- 1和5不需要转移，所以Remapped的值设置为1. 4需要转移，所以直接转移，并将转移前后地址放入转移映射表中。
  ![[Pasted image 20241104145213.png]]![[Pasted image 20241104145558.png]]
### 6.2.5 并发转移阶段
将**剩余对象转移到新的ZPage**中，转移之后将两个对象的地址记入转移映射表。
- 将5和8进行转移，并将转移后地址存入映射表中。![[Pasted image 20241104145637.png]]

- 此时，若用户访问了对象4，会通过读屏障，在用户线程访问4对象引用的5对象时，将4对5的引用重置，并将Remapped标记设为1.![[Pasted image 20241104150010.png]]![[Pasted image 20241104145838.png]]

最后，实质上还是并未完成所有的重映射工作，例如上述的5‘，这些重映射工作会放到下一轮的垃圾回收的标记阶段进行。
### 第二轮垃圾回收
![[Pasted image 20241104150054.png]]
#### 初始标记阶段：
第二次垃圾回收的初始标记阶段，沿着GC Root标记对象。第二次进行垃圾回收，使用M1和M0用来区分是第二次标记阶段还是第一次标记阶段。
![[Pasted image 20241104150500.png]]
如果M0为1，代表上一轮重映射还未完成，则通过映射表找到转移后的新对象，再进行标记。若Remapped为1，则只需要进行标记。![[Pasted image 20241104150812.png]]

## 6.3 ShenandoahGC原理
1. ShenandoahGC的区域定义与G1是一样的。
2. 没有着色指针，**通过修改对象头的设计来完成并发转移过程的实现**。
3. ShenandoahGC有两个版本，1.0版本存在于JDK8和JDK11中，后续的JDK版本中均使用2.0版本。

### 6.3.1 1.0版本
- 在原有的对象地址的基础上添加了8个字节作为前向指针。
- 转移前对象的前向指针指向转移后的对象，转移后对象的前向指针指向自身。![[Pasted image 20241104151957.png]]

**1.0版本的缺点：**
1. 对象内存大大增加，每个对象都需要增加8个字节的前向指针，基本上会占用5% - 10%的空间。
2. 读屏障中加入了复杂的指令，影响使用效率。

### 6.3.2 2.0版本
2.0版本优化了前向指针的位置，**仅转移阶段将其放入了Mark Word中。**
- 读取引用对象时，若发现指向的MarkWord中包含前向指针，则说明为转移前对象
![[Pasted image 20241104152256.png]]


### 6.3.3 执行流程
![[Pasted image 20241104152413.png]]

#### 并发问题
如果用户线程在帮忙转移时，ShenandoahGC线程也发现这个对象需要复制，那么就会去尝试写入前向指针，**使用了类似CAS的方式来实现，只有一个线程能成功修改，其他线程会放弃转移的操作。**