# HTTP篇
## 1. HTTP是什么？
- HyperText Transfer Protocol，超文本传输协议。HTTP是一个在两者之间传输文字、链接、音频、视频、图片等超文本数据的约定和规范。
- 两者之间可以是服务器和浏览器、也可以是服务器和服务器。
## 2. HTTP的常见状态码有哪些？
![[Pasted image 20241226134318.png|500]]
- **1xx，提示信息，是协议处理中的一种中间状态。**
- **2xx，表示服务器成功处理客户端请求。**【正确处理】
	- 200，表示一切正常。若请求为非HEAD请求，则返回的响应头中会带有响应体body；
	- 204 No Content，成功状态码，但是响应头中没有body数据；
	- 206 Partial Content，应用于HTTP分块下载或断点续传，表示响应返回的body数据中只是**资源的一部分**。
- **3xx，表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，即重定向。**【重定向】
	- 301 Moved Permanently，表示永久重定向，说明**请求的资源已不存在**，需要使用新的URL再次访问；
	- 302 Found，表示临时重定向，说明资源仍在，只是**暂时**需要用另一个URL来访问。
	- ⭐304 Not Modified，不具有跳转含义，**表示资源未修改**，重定向已存在的缓存文件，也称**缓存重定向**。也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- **4xx，表示客户端发送的报文有误，服务器无法处理！**【客户端的错误】
	- 400 Bad Request，笼统的错误；
	- 403 Forbidden，**表示服务器禁止访问资源**，并不是客户端请求出错；
	- ⭐404 Not Found，表示请求资源在服务器不存在或未找到；
- **5xx，表示请求正确，但是服务器内部处理发生了错误，属于服务端的错误码。**【服务端的错误】
	- 500 Internal Server Error，笼统错误码；
	- 501 Not Implemented，表示所请求的功能暂不支持；
	- 502 Bad GateWay，服务器作为网关或代理返回的错误码，说明请求后端服务器时发生了错误；
	- 503 Service Unavailable，表示服务器很忙，暂时无法响应客户端。
	- ⭐504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。
## 3. HTTP常见字段有哪些？
- Host：www.A.com，用于将请求发往服务器的不同网站；
- Content-Length字段：服务器返回数据时，表明本次回应的数据长度；
- Connection字段：用于客户端要求服务器使用「HTTP长连接」机制，以便其他请求复用；
- Content-Type字段：用于服务器回应时，告诉客户端本次数据的格式；
	- Accept字段：用于客户端发送时，声明可以接收的数据格式。
- Content-Encoding字段：表示服务器返回数据所使用的压缩格式。
	- Accept-Encoding字段：表明客户端所能接受的压缩格式。
## 4. GET和POST的区别
- GET请求一般用于从服务器获取指定资源。
	- GET方法是安全、幂等、可被缓存的。
- POST请求是根据请求负荷对指定资源做出处理。
	- POST请求是不安全、非幂等、不可缓存的。

GET请求也可以携带body，理论上任何请求都可以携带body。只不过遵循RFC规范，GET请求是获取资源，一般不需要用到Body。
## 5. HTTP缓存有哪些实现方式？ TODO
有**强制缓存和协商缓存**两种实现方式。

## 6. HTTP/1.1、HTTP/2、HTTP/3 演变

#### HTTP/1.1：
- 使用长连接的方式改善了HTTP/1.0短连接造成的性能开销；
- 支持**管道网络传输【解决了请求的队头阻塞问题】**，第一个请求发出去后，不必等待响应就可发送第二个请求，可减少整体的响应时间；

**性能瓶颈：**
- 请求头、响应头未经压缩就发送，首部信息越多延迟越大；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器按请求顺序响应，若服务器响应慢，会导致客户端一直请求不到数据，造成队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务端只能被动响应。
#### HTTP/2：
##### HTTP/2的优化：
- **基于HTTPS协议**，安全性提高；
- **头部压缩**：若发送多个请求的头部是一样或近似的，则会**消除重复部分**；
	- HPACK算法：客户端和服务器同时维护头信息表，所有字段都存入该表，生成索引号，以后只发送索引不发送字段，提高响应速度，减少资源浪费；
- **二进制格式**：区别于HTTP/1.1的纯文本形式，采用二进制格式，头信息和数据体都用二进制形式，称为**头信息帧和数据帧**。无需再将明文转换为二进制，而是直接解析二进制报文，提高数据传输效率。
  ![[Pasted image 20241226145208.png|340]]
- **并发传输**：HTTP/2引入Stream概念，**多条Stream可复用一条TCP连接【解决了响应的队头阻塞问题】**，每个Stream可包含一个或多个Message（对应HTTP/1请求或响应），由HTTP头部和包体构成。
	- Message包含一条或多条Frame，Frame是HTTP/2的最小单位，以二进制压缩格式存放HTTP/1中的内容。
	  ![[Pasted image 20241226193110.png|300]]
	- 接收端可以根据StreamID将Steam有序拼接成HTTP消息，因此HTTP可以乱序发送，共享一条TCP连接。
	  ![[Pasted image 20241226193147.png|400]]
- **服务器推送**：服务端可以主动向客户端发送消息。
	- 例如：HTTP/1.1中，客户端从服务器获取了HTML文件，可能还需要再发送请求获取CSS文件才能渲染页面；而在HTTP/2中，客户端获取HTML文件后，服务端可以主动发送CSS文件，减少通信次数。
	  ![[Pasted image 20241226193624.png|400]]

##### HTTP/2的缺陷：
- **解决了HTTP的队头阻塞，但依然存在TCP层的队头阻塞问题**。HTTP/2基于**TCP协议**传输数据。由于TCP协议是字节流协议，因此必须保证收到的字节数据是完整且连续的，才会将缓冲区的数据返回给HTTP应用。因此，假设发送端发送了多个Packet，构成一条TCP数据，但此时某个Packet丢失了，则内核中的TCP数据就不是完整且连续的了，此时就无法从缓冲区中获取数据，而必须等待丢失的Packet进行重传。
  ![[Pasted image 20241226194400.png|450]]
#### HTTP/3：
##### HTTP/3的优化：
1. 通过把HTTP下层的TCP协议改成UDP协议，优化了丢包造成的TCP层的队头阻塞问题。UDP发送不管顺序、也不管丢包，因此不是可靠传输。但是HTTP/3通过**基于UDP的QUIC协议**实现了类似TCP的可靠传输。
	   ![[Pasted image 20241226195418.png|500]]
	-  QUIC协议的特点：1）无队头阻塞；2）更快的连接建立；3）连接迁移。
		1. **无队头阻塞**：在同一条连接上并发传输多个Stream，一个Stream可认为是一条HTTP请求。
			- 可靠性传输：某个Stream丢包时，只会阻塞该流，其它流不会受到影响。
			  ![[Pasted image 20241226195932.png|450]]
		2. **更快的连接建立**：
		3. **连接迁移**：
## 7. HTTP/1.1如何优化？
- **避免发送HTTP请求**：缓存；
- **需要发送时，减少请求次数**：1）减少重定向次数；2）合并请求；3）延迟发送请求；
- **减少服务器的HTTP响应的数据大小**：1）无损压缩；2）有损压缩。
#### 避免发送HTTP请求
- 通过**缓存技术**。客户端会把第一次请求以及响应的数据保存在本地磁盘上，将请求的URL作为KEY，响应的数据作为VALUE。后续发生相同请求，都会先读缓存。
- 服务端发送HTTP响应时，会估算过期时间并放到响应头部，这样客户端发现资源过期后，就会重新发送网络请求。
	- 客户端重新发送请求时，会在请求的Etag头部带上响应的摘要，用于唯一标识响应资源。当服务器收到请求后，会将本地资源的摘要与Etag中的摘要进行比较：若相同，则返回的响应中不会携带资源，仅返回304状态码，用于告诉客户端缓存仍有效；若不同，则会返回最新的资源。
![[Pasted image 20241226203259.png|450]]
#### 减少HTTP请求次数
##### 减少重定向请求次数
- 将**重定向工作交给代理服务器完成**，减少HTTP请求次数。
  ![[Pasted image 20241226204402.png]]
##### 合并请求
- 将多个访问小文件的请求合并成一个大请求，虽然传输的总资源一致，但是减少次数，也就意味着减少了重复发送的HTTP头部。
##### 延迟发送请求
- 网页中会包含很多HTTP的URL，避免一次性获取。只有当用户滑动网页需要浏览时，才发送请求获取资源，从而减少第一时间的请求次数。
#### 减少HTTP响应的数据大小
##### 无损压缩
- 压缩代码：去掉多余的换行符、空格等利于程序员阅读的符号；
- 无损压缩：对原始资源建立统计模型，将常出现的数据用较短的二进制比特序列表示；将不常出现的数据用较长的二进制比特序列表示。
##### 有损压缩
- 将PNG图片压缩成WebP格式；
- 压缩视频：通过将静态画面部分使用增量数据来表示后续的帧，从而减少很多数据。
## 8. ⭐HTTPS和HTTP的区别是什么？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手过程**，才可进入加密报文传输。【HTTP三次握手，HTTPS四次握手】
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
## 9. HTTPS RSA握手过程解析
#### TLS握手过程【基于RSA算法】
HTTPS在HTTP和TCP层之间加入了**TLS协议**，通过信息加密、校验机制和安全证书三方面来保证信息安全。
![[Pasted image 20241227094257.png|300]]

在HTTP通信前，需要先进行TLS握手：
- 图中 每一个框都是一个记录，记录是TLS收发数据的基本单位，类似于TCP里的segment。多个记录可以组合成一个TCP包发送，所以通常经过「**四个信息**」就可以完成TLS握手，也就是需要**两个RTT时延**。
- HTTPS是应用层协议，所以需要先完成TCP连接，然后再进行TLS握手后，才能建立可靠安全的连接。
![[Pasted image 20241227094410.png|400]]
- TLS第一次握手：【Client→Server】
	- `Client Hello`，携带TLS版本号、密码套件以及生成的随机数。其中随机数会被保留，作为生成对称加密密钥的材料之一。
- TLS第二次握手：【Server→Client】
	- `Server Hello`：服务端确认TLS版本、选择一个合适的密码套件并返回服务端生成的随机数。
		- 密码套件：由「**密钥交换算法+签名算法+对称加密算法+摘要算法**」组成。
	- `Certificate`：发送数字证书，证明服务器身份。
	- `ServerHelloDone`：告知信息已发送完毕。
- TLS第三次握手：【Client→Server】
	- `ClientKeyExchange`：验证证书，生成随机数并使用服务器的RSA公钥加密后发送给服务端；服务端收到密钥后，用RSA私钥解密，得到客户端发送的随机数。
		- 至此，双方已共享三个随机数：`Server Random`、`Client Random`和`pre-master`。双方根据随机数生成会话密钥（对称密钥），用于对后续HTTP请求/响应的数据加解密。
	- `Change Cipher Spec`：根据随机数生成完会话密钥后，会发送此消息告诉客户端开始使用加密方式发送消息。
	- `Finished`：客户端会把之前所有发送的数据做摘要，再用会话密钥加密后发送，让服务器做验证，以保证加密通信可用、未被篡改。
- TLS第四次握手：【Server→Client】
	- `Change Cipher Spec`：根据随机数做加密，并以加密方式发送信息。
	- `Finished`：确认加密通信可用且未被篡改。
- 完成四次握手后，开始传输应用数据。
**RSA算法的缺点：**
1. 不支持前向保密。若私钥泄露，则还会导致过去所有的密文被破译。
#### 基于DH算法的TSL握手过程：


## 10. 有了HTTP协议，为什么还要有RPC协议？
- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式【远程过程调用】**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员**能像调用本地方法那样去调用远端的服务方法**。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议【基于UDP协议也行】**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## 11. 有了HTTP协议，为什么还要有WebSocket？
- HTTP协议是半双工的，对于需要双向通信，尤其是服务器主动向客户端推送数据的场景不友好；而WebSocket是全双工的，支持建立连接后服务器与客户端的双向通信。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。【本质还是客户端主动请求服务端数据】
	- **【定时轮询】**：基于HTTP协议可以实现**伪推送**模式，就是前端在用户无感知的情况下不断向后端发送请求，服务器收到请求后向客户端返回数据。但是会有延迟，因为前端请求可能是每1~2秒发送。【定时轮询】
	- **【长轮询】**：将HTTP请求的超时时间延长，例如由3秒延长至30秒，此时只要服务器收到了用户的扫码请求，就立刻返回数据给客户端。若超时，则立马再发送请求，建立长轮询。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
## 12. HTTP报文有哪些部分？
分为请求报文和响应报文。
# IP

## 1. IPV4和IPV6的区别是什么？
## 2. JWT令牌和传统方式有什么区别？
1. **无状态性**：JWT是无状态的令牌，不需要在服务器端存储会话信息。相反，**JWT令牌中包含了所有必要的信息**，如用户身份、权限等。这使得JWT在分布式系统中更加适用，可以方便地进行扩展和跨域访问。
2. **安全性**：JWT使用密钥对令牌进行签名，确保令牌的完整性和真实性。只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比传统的基于会话和Cookie的验证更加安全，有效防止了CSRF（跨站请求伪造）等攻击。
3. **跨域支持**：JWT令牌可以在不同域之间传递，适用于跨域访问的场景。通过在请求的头部或参数中携带JWT令牌，可以实现无需Cookie的跨域身份验证。
## 3. JWT 令牌都有哪些字段？
JWT令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为JSON格式，使用**Base64编码进行序列化**，而**签名部分是对头部、载荷和密钥进行签名后的结果**。

## 4. JWT 令牌为什么能解决集群部署？
**JWT令牌通过在令牌中包含所有必要的身份验证和会话信息**，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。当用户进行登录认证后，服务器将生成一个JWT令牌并返回给客户端。客户端在后续的请求中携带该令牌，**服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息**，而无需访问共享的会话存储。
## 5. jwt的缺点是什么？
派发后无法撤销。
解决办法：在Redis中存储黑名单列表，配合布隆过滤器过滤黑名单用户。
## 6. JWT令牌详解:
### 出现背景:
互联网服务离不开用户认证。一般流程是下面这样:
> 1、用户向服务器发送用户名和密码。
> 2、服务器验证通过后，在**当前对话（session）里面保存相关数据**，比如用户角色、登录时间等等。
> 3、服务器向用户返回一个session_id，**写入用户的Cookie。**
> 4、用户随后的每一次请求,都会**通过 Cookie将session_id 传回服务器**。
> 5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。
### JWT令牌原理:
JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户.

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器**完全只靠这个对象认定用户身份**。为了防止用户篡改数据，服务器在生成这个对象的时候，会**加上签名**（详见后文）。

**服务器就不保存任何 session 数据了，也就是说，服务器变成==无状态==了，从而比较容易实现扩展。**
### JWT的数据结构:
JWT由三个部分组成:`头部(Header).负载(Payload).签名(Signature)`,三者之间通过`.`隔开.
#### Header:
Header 部分是一个JSON对象，描述JWT的元数据,样例如下:
```JavaScript
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`表示签名算法,默认为`HMAC SHA256`(写成HS256);
- `typ`表示token类型,JWT令牌统一写成JWT.
#### Payload:
Payload部分也是一个JSON对象，用来存放实际需要传递的数据.JWT规定了7个官方字段:
- iss (issuer)：签发人
- **exp (expiration time)：过期时间**
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号
除了官方字段，你还可以在这个部分**定义私有字段**，下面就是一个例子:
```JavaScript
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
**JWT 默认是不加密**的，任何人都可以读到，所以不要把秘密信息放在这个部分。

#### Signature:
Signature部分是对前两部分的签名,防止数据篡改.

首先，需要**指定一个密钥（secret）**。这个**密钥只有服务器才知道，不能泄露给用户**。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。
>即`签名=HS257(Header.Payload,secret)`
```JavaScript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
计算出签名后,**将Header,Payload与Signature之间用`.`进行拼接**就得到了Token,就可以返回给用户了.
即对Header和Payload使用Base64URL算法生成JSON字符串,然后加上密钥,三者使用`.`进行拼接,获得最终的token.

### JWT的使用方式:
客户端收到服务器返回的 JWT，**可以储存在 Cookie 里面，也可以储存在 localStorage。**

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript 
> Authorization: Bearer <token>
 ```

另一种做法是,跨域的时候,JWT就放在POST请求的数据体里面。

### JWT的几个特点:
1. JWT**默认是不加密**，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次.
2. JWT不加密的情况下，不能将秘密数据写入JWT。
3. JWT不仅可以用于认证，也可以**用于交换信息**。有效使用JWT，可以**降低服务器查询数据库的次数。**
4. JWT的最大缺点是，由于服务器不保存 session 状态，因此**无法在使用过程中废止某个 token**，或者更改token的权限。也就是说，一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
5. JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，**JWT的有效期应该设置得比较短**。对于一些比较重要的权限，使用时应该再次对用户进行认证。
6. 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。

![[Pasted image 20241011012123.png]]

## 7. WebSocket详解
### 出现背景:
根本原因在于HTTP协议的缺点,通信只能由客户端发起. 例如,如果想了解当天的天气,只能是由客户端想服务端发起查询请求,服务端返回查询结果. 而无法做到服务端向客户端主动推送消息.

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用**轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息**。最典型的场景就是聊天室。

轮询的效率很低,并且浪费资源,因为客户端和服务端必须不停连接,或者HTTP连接始终打开.

### 简介:
WebSocket的最大特点就是，**服务器可以主动向客户端推送信息,客户端也可以主动向服务器发送信息**，是真正的双向通信，属于服务器推送技术的一种。

WebSocket的其他特点:
1. 建立**在 TCP 协议**之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL.

### WebSocket出现之前的即时通讯方式:
1. **定期轮询:**
	- **客户端按照某个时间间隔不断地向服务端发送请求**，请求服务端的最新数据然后更新客户端显示。这种方式实际上**浪费了大量流量并且对服务端造成了很大压力**。
2. **SSE(Server-Sent Event,服务器推送事件):**
	- SSE是一种允许服务端向客户端推送新数据的HTML5技术.