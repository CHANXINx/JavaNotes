
# 08 | 事务的隔离


# 12 | MySQL为什么会“抖”一下?
为了保证读写效率，MySQL不是每一次写数据都会更新到磁盘中，而是先记录在内存中的redo log中。此时，磁盘中的数据和内存中的数据并不一致，称为脏页。在某些时刻，系统会停止所有更新操作，根据redo log中记录的日志信息，更新磁盘中的操作，称为刷脏页。


### 场景一：redo log写满
redo log是有内存限制的，当记录日志过多时，此时write position接近于checkpoint，剩余空间不足了，此时需要进行一次刷脏页操作，将redo log中的checkpoint向前推进，以留出空间继续写。

此时对性能影响最大，因为在刷脏页过程中，整个系统不再接受更新。

redo log的大小是可以设置的，若设置的太小，则更新记录会很快占满内存，导致系统需要停止所有更新，进行刷脏页，更新checkpoint，导致磁盘压力很小(因为每次写入的数据都很少，低于磁盘IOPS)，数据库间歇性地性能下降。
### 场景二：内存满了
此时是内存满了，当需要淘汰的是脏页时，就会触发先将脏页刷(flush)到磁盘中。

缓冲池中的内存页存在三种情况：1）未使用的内存页；2）使用了且是干净的；3）使用了且是脏页。当要读入的数据不在内存页中时，就必须到缓冲池申请一个内存页，当是情况1时，就直接申请；当是情况2时，就直接释放并复用；当是情况3时，就需要先刷脏页到磁盘中，变成干净页后才能复用。

### 场景三：
此时是MySQL判断此时是属于“空闲时刻”，就会触发刷脏页。

### 场景四：
此时MySQL正常关闭，需要先将内存中的脏页都刷到磁盘中才能关闭。下次MySQL启动时，直接从磁盘中读取数据。

## InnoDB的刷脏页策略
InnoDB的刷脏页能力与系统磁盘的IO能力息息相关，建议通过设置参数`innodb_io_capacity`为磁盘的IOPS。磁盘的IOPS可通过fio工具进行测试，测试语句为：
```bash
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```

InnoDB刷脏页时，还会有连坐机制：
假设某个查询需要的数据内存中没有，此时就可能需要淘汰内存页、刷脏页，此时若旁边的数据页也是脏页，则会将此邻居也一同刷掉。若连带脏页的邻居也是脏页，则也会一并刷掉，直到旁边的数据页是干净页。

## 总结
利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。
- 写Redo log，只需要进行将更新记录写入日志这一个磁盘操作即可，是顺序写；而如果需要更新磁盘中的具体数据，就需要进行随机写，因为要涉及到**磁盘寻址**操作。

# 13 | 表数据删除一半，为什么表文件大小不变?
InnoDB表包含两部分：表结构定义和表数据。在MySQL8.0以后，已经支持将表结构定义放到系统数据表中。**系统数据表，主要用于存储MySQL的系统数据，比如：数据字典、undo log(默认)等文件**

## 参数 innodb_file_per_table
>**控制表数据是否存放到共享空间中.**

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：
- 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
- 这个参数设置为ON表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。

建议设置为ON，一个表单独存储在一个.ibd表文件中，在需要删除表时就会将该文件删除，直接释放空间；而若将表数据存储在共享空间中，此时即使drop table，空间也不会回收。

## 数据删除流程


# 14 | count(\*)为什么这么慢，如何解决?

## count(\*)的实现方式
不同引擎的实现方式不同：
- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\*)的时候会直接返回这个数，效率很高；
- 而 InnoDB 引擎就麻烦了，它执行 count(\*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数，因此效率很低！

InnoDB采用此方法计算行数的原因是MVCC，解释如下：
![[Pasted image 20241111230420.png]]
InnoDB的默认事务隔离级别为可重复读，因此会在select count(\*) from t时创建read view,所以会话A返回的行数为10000；而会话B此时在查询前又插入了一条数据，由于当前读，所以会创建一个新视图，包含会话C插入的数据，所以会话B最后返回的是10002；而会话C此时看不到会话B插入的数据，只能看到自己插入的数据，所以返回的是10001；

InnoDB对此进行了优化，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键，所以普通索引树会比主键索引树小很多，因此MySQL优化器会选择最小的树进行遍历。

## 解决办法:
### 方法一:使用缓存计数
使用Redis保存表的总行数，此时读写速度都很快。但是缓存系统可能丢失更新，导致数据不准确！
假设插入了新数据，但是Redis还没有来得及计数就异常重启了，此时就可能导致计数操作丢失。解决办法是在重启后进行一次count(\*)全表扫描获取真实行数。

**使用缓存计数最大的问题在于不精确。**

考虑以下2种情况：
	1. 此时数据已经插入，但是Redis还未更新。
	![[Pasted image 20241111232726.png|450]]
	2. 此时数据已经插入，但是Redis技术还未更新。
	   ![[Pasted image 20241111233019.png|450]]

把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因，是**这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。**
### 方法二:在数据库保存计数
将计数直接放在数据库单独的一张计数表C中进行存储。

可以通过**添加事务来保证在数据插入前对其他线程不可见**。这里将更新计数表C放在插入数据后，是因为更新计数表涉及到同一行数据的操作，会加行锁；而插入数据是对不同行的操作，不会加行锁，因此先更新计数表能尽可能的减少阻塞。
![[Pasted image 20241112001927.png|450]]

## 不同count语句的差别:
count语句性能分析原则：
- server 层要什么就给什么；
- InnoDB 只给必要的值；
- 现在的优化器只优化了 count(\*) 的语义为“取行数”，其他“显而易见”的优化并没有做。

**count(主键id)**：InnoDB 引擎会遍历整张表，**把每一行的 id 值都取出来**，返回给server 层。server 层拿到 id 后，判断是不可能为空的(主键不能为null)，就按行累加。

**count(1)**：InnoDB 引擎遍历整张表，**但不取值**。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

>count(1) 执行得要比 count(主键 id) 快。**因为从引擎返回id给server层会涉及到解析数据行，以及拷贝字段值的操作。**

**count(字段)**：
1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，**还要把值取出来再判断一下**，不是 null 才累加。

**count(\*)**：并不会将所有字段取出，MySQL对此进行了优化，不会取值。count(\*)肯定不是null，直接按行累加。

所以，执行效率上，**count(字段)<count(主键 id)<count(1)≈count(\*)**

