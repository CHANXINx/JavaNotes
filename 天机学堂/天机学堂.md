# Day01:
## 1. 天机学堂介绍:
### 项目亮点:
![[Pasted image 20240912131056.png]]

## 2. 项目环境搭建:
### 2.1 导入虚拟机
**部署常用开发组件:**
修改host,直接访问域名即可映射到对应ip地址.访问域名时**自动访问80端口**,**nginx监听了80端口**,并进行反向代理.
![[Pasted image 20240912132332.png]]

## 3.阅读源码:
![[Pasted image 20240915093116.png]]
### 删除订单失效BUG分析:
#### 错误分析:
查看前端发送请求为
![[Pasted image 20240915095341.png]]
查看nginx的配置文件,发现api.tianji.com会被反向代理到![[Pasted image 20240915095955.png]]
即http://192.168.150.101:10010/ts/orders/~.再查看gateway路由,发现以ts开头的请求都被路由到了trade-service服务中,即lb://trade-service/orders/~.
![[Pasted image 20240915100222.png]]
#### 代码开发:
##### **调试方法:**
**方法一(远程调试):**
1. 新建启动项"Remote JVM DEBUG",配置Configuration;同时Jenkins中配置部署脚本,并运行,此时虚拟机中的tj-trade应多出一个5005端口,即远程调试的端口!![[Pasted image 20240915153653.png]]
==**方法二(本地调试):**==
1. 在启动trade-service时配置`-active profile: local`,此时在nacos就会新增一个trade-service服务,并且ip地址为`192.168.150.1`. 此时我们在nacos中将虚拟机中的trade-service下线,当用户访问trade-service服务时,就会走本地的trade服务,而不是虚拟机中的!!![[Pasted image 20240915154402.png]]
##### **bug修复:**
1. 经debug分析,发现是在判断用户id是否相等时出现问题,id为Long型,在进行比较时,是比较其地址.包装类提前将-128~127之间的Long包装类提前创建出来,共享使用,故当Long值在-128~127时,可以使用`==/!=`进行判断;当在这之外,则需要使用equals来判断!!!

##### **分支管理:**
- 避免直接使用lesson-init提交bug代码,新建`hotfix-delete-order-error`分支,提交代码;随后进行测试,再切换到lesson-init分支,并将hotfix分支`merge into lesson-init`分支!

# Day02:
**开发业务流程:**
![[Pasted image 20240915173012.png]]
## 我的课表:
需要强调的一点是，开发中最重要的环节其实是前两步：
- 原型分析、接口设计
- 数据库设计
那为什么要先设计接口呢？原因有两点：
- 第一：目前企业开发的模式往往是前后端分离，前后端并行开发。**前端开发需要调用后端接口**，**后端需要开发接口返回数据给前端**，要想并行开发，就必须有一套接口标准，前后端基于接口完成开发。
- 第二：设计接口的过程就是分析业务的过程，弄清楚了业务的细节，更有助于我们设计数据库结构，开发接口功能。
### 接口设计: 
#### 分析业务流程:
![[Pasted image 20240915191155.png]]

#### 接口统计:
根据业务流程,梳理可能需要开发的接口:
1) **加入课表:** 用户支付完成后,需要将已购买的课程加入课表. 支付完成后,交易服务会基于MQ通知(支付完成与加入课表无需同步进行)的方式,通知学习服务来执行加入课表的动作.
   ->**接口1:** 支付或报名课程后,监听到MQ通知,将课程加入课表.
2) **查询课表:** 课程加入课表后,用户可以在个人中心中查看课程.
   ->**接口2:** 分页查询我的课表.
3) **删除课程:** 课程学完后(或过期,退款等),用户可以选择将课程删除.
   ->**接口3:** 删除指定课程.
   ->**接口4:** 退款后,监听到MQ通知,删除指定课程.
4) **查询学习进度:** 用户可以查看最近的学习进度
   ->**接口5:** 查询最近正在学习的课程.
   ->**接口6:** 查询学习计划的进度.
   ![[Pasted image 20240915192307.png|600]]
5) **查询指定课程的学习状态:** 用户可以在课程中心查看指定课程的学习状态以及学习进度.
   ->**接口7:** 根据id查询指定课程的学习状态.![[Pasted image 20240915192558.png]]
6) **内部访问接口:** 除了页面原型中看到的接口以外,其它微服务也对`tj-learning`服务有数据需求,并且也定义了一些需要我们实现的Feign接口.在天机学堂的项目中,所有Feign接口都定义在了`tj-api`模块下，`learning`服务的接口定义在`com.tianji.api.client.learning`模块下:
   ->**接口8:** **统计某课程的报名人数**:后台管理的某些地方需要知道课程的报名人数
   ->**接口9:** **校验**当前用户是否报名了指定课程:用户学习课程的前提是报名了课程,某些业务中需要做校验![[Pasted image 20240915192742.png]]
**接口总结:**

| **编号** | **接口简述**                   | **请求方式** | **请求路径**                  |
| ------ | -------------------------- | -------- | ------------------------- |
| 1      | 支付或报名课程后，立刻加入课表            | MQ通知     |                           |
| 2      | 分页查询我的课表                   | GET      | /lessons/page             |
| 3      | 查询我最近正在学习的课程               | GET      | /lessons/now              |
| 4      | 根据id查询指定课程的学习状态            | GET      | /lessons/{courseId}       |
| 5      | 删除课表中的某课程                  | DELETE   | /lessons/{courseId}       |
| 6      | 退款后，立刻移除课表中的课程             | MQ通知     |                           |
| 7      | 校验指定课程是否是课表中的有效课程（Feign接口） | GET      | /lessons/{courseId}/valid |
| 8      | 统计课程学习人数（Feign接口）          | GET      | /lessons/{courseId}/count |
**MyBatisX插件使用方法:**
1. 配置数据源: `Tools-> Config Database`:
2. **设置代码生成:**![[Pasted image 20240915201844.png|800]]
3. 根据主键策略和枚举类调整相应属性:
```java
@ApiModelProperty(value = "主键")  
@TableId(value = "id", type = IdType.ASSIGN_ID)   // 根据数据库主键配置调整主键策略.  
private Long id;  
  
@ApiModelProperty(value = "课程状态，0-未学习，1-学习中，2-已学完，3-已失效")  
private LessonStatus status;    // 利用枚举类定义状态
  
@ApiModelProperty(value = "学习计划状态，0-没有计划，1-计划进行中")  
private PlanStatus planStatus;   
```
4. 根据接口设计调整Controller方法中的默认路径.

### 代码开发-添加课程到课表:
#### 接口设计:
![[Pasted image 20240915204756.png|600]]
#### 代码开发:
##### 1. **编写消息监听类:**
在`com.tianji.learning.mq`新建LessonChangeListener监听类. 
	1) 添加`@Component`注解,将监听类交由Spring容器管理;
	2) `@RequiredArgsConstructor`与`final`,实现构造器注入;
	3) `@RabbitListener`定义监听方法.
```java
@Component  
@Slf4j  
@RequiredArgsConstructor  
public class LessonChangeListener {  
  
    private final ILearningLessonService lessonService;  
  
    @RabbitListener(bindings = @QueueBinding(value = @Queue(value = "learning.lesson.pay.queue",durable = "true"),  
    exchange = @Exchange(value = MqConstants.Exchange.ORDER_EXCHANGE,type = ExchangeTypes.TOPIC),  
    key = MqConstants.Key.ORDER_PAY_KEY))  
    public void onMsg(OrderBasicDTO orderBasicDTO){  
        log.info("接收到消息！！");  
//        TODO 校验参数(健壮性处理)
        if (orderBasicDTO == null || orderBasicDTO.getUserId() == null  
                || CollUtils.isEmpty(orderBasicDTO.getCourseIds())){  
            log.info("订单数据为空！");  
		// 处理异常时,不可抛出,否则Mq会持续尝试,直到达到上限!  
            return;  
        }  

//        TODO 调用service,保存课程到课表  
        lessonService.addUserLesson(orderBasicDTO.getUserId(), orderBasicDTO.getCourseIds());  
    }  
}
```
##### 2. Service层:
- 监听类传递了userId与courseId给Serivce层,实现将课程保存到课表,需要PO类,故需要实现DTO->PO,故观察课表中的字段. 发现很多字段都有默认值,故只需设置`user_id,course_id,expire_time`三个字段即可.
![[Pasted image 20240916092854.png]]
- user_id,course_id已由Listener传递,故只需查询过期时间,即通过"加入课程时间+有效期"获得,由此通过**调用courseClient来查询课程信息,获得每个课程的有效期!**
```java
    @Override  
    public void addUserLesson(Long userId, List<Long> courseIds) {  
//        TODO 通过feign远程调用服务,得到课程信息  
        List<CourseSimpleInfoDTO> cinfos = courseClient.getSimpleInfoList(courseIds);  
  
        List<LearningLesson> list = new ArrayList<>();  
//        TODO 封装PO实体类，填充过期时间  
        for (CourseSimpleInfoDTO info : cinfos){  
            LearningLesson learningLesson = new LearningLesson();  
  
            learningLesson.setUserId(userId);  
            learningLesson.setCourseId(info.getId());  
            Integer validDuration = info.getValidDuration();  
            if (validDuration != null) {  
                LocalDateTime now = LocalDateTime.now();  
                learningLesson.setCreateTime(now);  
                learningLesson.setExpireTime(now.plusMonths(validDuration));  
            }  
  
            list.add(learningLesson);  
        }  
//        TODO 批量保存(MyBatisPlus的方法)
        saveBatch(list);  
    }
```
##### 3. Bug修复:
- 在这里出现了一个问题,添加课程时发现LeanringApplication无响应!?查看前端发送的请求,发现是先请求`/freecourse/{courseId}`,并且返回数据为`msg="课程已过期"`! 查询后发现是`OrderController`中的`enrolledFreeCourse()`,**追踪业务逻辑**,发现是在service层调用了`getOnShelfCourse`判断课程是否过期导致! 故将该判断逻辑注释,重新编译运行,发现请求可正确到达LearningApplication! 自此,成功修复该Bug!!
![[Pasted image 20240916095301.png]]

### 代码开发-分页查询我的课表:
#### **接口设计:**
![[Pasted image 20240915193407.png]]
#### 代码开发:
##### Controller层:
- 使用构造器注入: 1)利用final定义成员变量; 2)添加@RequiredArgsConstructors注解.
```java
private final ILearningLessonService lessonService;

@GetMapping("page")  
@ApiOperation("分页查询我的课表")  
public PageDTO<LearningLessonVO> queryMyLessons(PageQuery pageQuery){  
    return lessonService.queryMyLessons(pageQuery);  
}
```
##### Service层:
>[!实现分页查询的几种方法]
>1)利用MyBatis分页插件的`PageHelper.startPage(PageNum,PageSize)`方法;
>2)利用MyBatis中的Page方法


### 接口开发-查询正在学习的课程