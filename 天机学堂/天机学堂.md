# Day01:
## 1. 天机学堂介绍:
### 项目亮点:
![[Pasted image 20240912131056.png]]

## 2. 项目环境搭建:
### 2.1 导入虚拟机
**部署常用开发组件:**
修改host,直接访问域名即可映射到对应ip地址.访问域名时**自动访问80端口**,**nginx监听了80端口**,并进行反向代理.
![[Pasted image 20240912132332.png]]

## 3.阅读源码:
![[Pasted image 20240915093116.png]]
### 删除订单失效BUG分析:
#### 错误分析:
查看前端发送请求为
![[Pasted image 20240915095341.png]]
查看nginx的配置文件,发现api.tianji.com会被反向代理到![[Pasted image 20240915095955.png]]
即http://192.168.150.101:10010/ts/orders/~.再查看gateway路由,发现以ts开头的请求都被路由到了trade-service服务中,即lb://trade-service/orders/~.
![[Pasted image 20240915100222.png]]
#### 代码开发:
##### **调试方法:**
**方法一(远程调试):**
1. 新建启动项"Remote JVM DEBUG",配置Configuration;同时Jenkins中配置部署脚本,并运行,此时虚拟机中的tj-trade应多出一个5005端口,即远程调试的端口!![[Pasted image 20240915153653.png]]
==**方法二(本地调试):**==
1. 在启动trade-service时配置`-active profile: local`,此时在nacos就会新增一个trade-service服务,并且ip地址为`192.168.150.1`. 此时我们在nacos中将虚拟机中的trade-service下线,当用户访问trade-service服务时,就会走本地的trade服务,而不是虚拟机中的!!![[Pasted image 20240915154402.png]]
##### **bug修复:**
1. 经debug分析,发现是在判断用户id是否相等时出现问题,id为Long型,在进行比较时,是比较其地址.包装类提前将-128~127之间的Long包装类提前创建出来,共享使用,故当Long值在-128~127时,可以使用`==/!=`进行判断;当在这之外,则需要使用equals来判断!!!

##### **分支管理:**
- 避免直接使用lesson-init提交bug代码,新建`hotfix-delete-order-error`分支,提交代码;随后进行测试,再切换到lesson-init分支,并将hotfix分支`merge into lesson-init`分支!

# Day02:
**开发业务流程:**
![[Pasted image 20240915173012.png]]
## 我的课表:
需要强调的一点是，开发中最重要的环节其实是前两步：
- 原型分析、接口设计
- 数据库设计
那为什么要先设计接口呢？原因有两点：
- 第一：目前企业开发的模式往往是前后端分离，前后端并行开发。**前端开发需要调用后端接口**，**后端需要开发接口返回数据给前端**，要想并行开发，就必须有一套接口标准，前后端基于接口完成开发。
- 第二：设计接口的过程就是分析业务的过程，弄清楚了业务的细节，更有助于我们设计数据库结构，开发接口功能。
### 接口设计: 
#### 分析业务流程:
![[Pasted image 20240915191155.png]]

#### 接口统计:
根据业务流程,梳理可能需要开发的接口:
1) **加入课表:** 用户支付完成后,需要将已购买的课程加入课表. 支付完成后,交易服务会基于MQ通知(支付完成与加入课表无需同步进行)的方式,通知学习服务来执行加入课表的动作.
   ->**接口1:** 支付或报名课程后,监听到MQ通知,将课程加入课表.
2) **查询课表:** 课程加入课表后,用户可以在个人中心中查看课程.
   ->**接口2:** 分页查询我的课表.
3) **删除课程:** 课程学完后(或过期,退款等),用户可以选择将课程删除.
   ->**接口3:** 删除指定课程.
   ->**接口4:** 退款后,监听到MQ通知,删除指定课程.
4) **查询学习进度:** 用户可以查看最近的学习进度
   ->**接口5:** 查询最近正在学习的课程.
   ->**接口6:** 查询学习计划的进度.
   ![[Pasted image 20240915192307.png|600]]
5) **查询指定课程的学习状态:** 用户可以在课程中心查看指定课程的学习状态以及学习进度.
   ->**接口7:** 根据id查询指定课程的学习状态.![[Pasted image 20240915192558.png]]
6) **内部访问接口:** 除了页面原型中看到的接口以外,其它微服务也对`tj-learning`服务有数据需求,并且也定义了一些需要我们实现的Feign接口.在天机学堂的项目中,所有Feign接口都定义在了`tj-api`模块下，`learning`服务的接口定义在`com.tianji.api.client.learning`模块下:
   ->**接口8:** **统计某课程的报名人数**:后台管理的某些地方需要知道课程的报名人数
   ->**接口9:** **校验**当前用户是否报名了指定课程:用户学习课程的前提是报名了课程,某些业务中需要做校验![[Pasted image 20240915192742.png]]
**接口总结:**

| **编号** | **接口简述**                   | **请求方式** | **请求路径**                  |
| ------ | -------------------------- | -------- | ------------------------- |
| 1      | 支付或报名课程后，立刻加入课表            | MQ通知     |                           |
| 2      | 分页查询我的课表                   | GET      | /lessons/page             |
| 3      | 查询我最近正在学习的课程               | GET      | /lessons/now              |
| 4      | 根据id查询指定课程的学习状态            | GET      | /lessons/{courseId}       |
| 5      | 删除课表中的某课程                  | DELETE   | /lessons/{courseId}       |
| 6      | 退款后，立刻移除课表中的课程             | MQ通知     |                           |
| 7      | 校验指定课程是否是课表中的有效课程（Feign接口） | GET      | /lessons/{courseId}/valid |
| 8      | 统计课程学习人数（Feign接口）          | GET      | /lessons/{courseId}/count |
**MyBatisX插件使用方法:**
1. 配置数据源: `Tools-> Config Database`:
2. **设置代码生成:**![[Pasted image 20240915201844.png|800]]
3. 根据主键策略和枚举类调整相应属性:
```java
@ApiModelProperty(value = "主键")  
@TableId(value = "id", type = IdType.ASSIGN_ID)   // 根据数据库主键配置调整主键策略.  
private Long id;  
  
@ApiModelProperty(value = "课程状态，0-未学习，1-学习中，2-已学完，3-已失效")  
private LessonStatus status;    // 利用枚举类定义状态
  
@ApiModelProperty(value = "学习计划状态，0-没有计划，1-计划进行中")  
private PlanStatus planStatus;   
```
4. 根据接口设计调整Controller方法中的默认路径.

### 代码开发-添加课程到课表:
#### 接口设计:
![[Pasted image 20240915204756.png|600]]
#### 代码开发:
##### 1. **编写消息监听类:**
在`com.tianji.learning.mq`新建LessonChangeListener监听类. 
	1) 添加`@Component`注解,将监听类交由Spring容器管理;
	2) `@RequiredArgsConstructor`与`final`,实现构造器注入;
	3) `@RabbitListener`定义监听方法.
```java
@Component  
@Slf4j  
@RequiredArgsConstructor  
public class LessonChangeListener {  
  
    private final ILearningLessonService lessonService;  
  
    @RabbitListener(bindings = @QueueBinding(value = @Queue(value = "learning.lesson.pay.queue",durable = "true"),  
    exchange = @Exchange(value = MqConstants.Exchange.ORDER_EXCHANGE,type = ExchangeTypes.TOPIC),  
    key = MqConstants.Key.ORDER_PAY_KEY))  
    public void onMsg(OrderBasicDTO orderBasicDTO){  
        log.info("接收到消息！！");  
//        TODO 校验参数(健壮性处理)
        if (orderBasicDTO == null || orderBasicDTO.getUserId() == null  
                || CollUtils.isEmpty(orderBasicDTO.getCourseIds())){  
            log.info("订单数据为空！");  
		// 处理异常时,不可抛出,否则Mq会持续尝试,直到达到上限!  
            return;  
        }  

//        TODO 调用service,保存课程到课表  
        lessonService.addUserLesson(orderBasicDTO.getUserId(), orderBasicDTO.getCourseIds());  
    }  
}
```
##### 2. Service层:
- 监听类传递了userId与courseId给Serivce层,实现将课程保存到课表,需要PO类,故需要实现DTO->PO,故观察课表中的字段. 发现很多字段都有默认值,故只需设置`user_id,course_id,expire_time`三个字段即可.
![[Pasted image 20240916092854.png]]
- user_id,course_id已由Listener传递,故只需查询过期时间,即通过"加入课程时间+有效期"获得,由此通过**调用courseClient来查询课程信息,获得每个课程的有效期!**
```java
    @Override  
    public void addUserLesson(Long userId, List<Long> courseIds) {  
//        TODO 通过feign远程调用服务,得到课程信息  
        List<CourseSimpleInfoDTO> cinfos = courseClient.getSimpleInfoList(courseIds);  
  
        List<LearningLesson> list = new ArrayList<>();  
//        TODO 封装PO实体类，填充过期时间  
        for (CourseSimpleInfoDTO info : cinfos){  
            LearningLesson learningLesson = new LearningLesson();  
  
            learningLesson.setUserId(userId);  
            learningLesson.setCourseId(info.getId());  
            Integer validDuration = info.getValidDuration();  
            if (validDuration != null) {  
                LocalDateTime now = LocalDateTime.now();  
                learningLesson.setCreateTime(now);  
                learningLesson.setExpireTime(now.plusMonths(validDuration));  
            }  
  
            list.add(learningLesson);  
        }  
//        TODO 批量保存(MyBatisPlus的方法)
        saveBatch(list);  
    }
```
##### 3. Bug修复:
- 在这里出现了一个问题,添加课程时发现LeanringApplication无响应!?查看前端发送的请求,发现是先请求`/freecourse/{courseId}`,并且返回数据为`msg="课程已过期"`! 查询后发现是`OrderController`中的`enrolledFreeCourse()`,**追踪业务逻辑**,发现是在service层调用了`getOnShelfCourse`判断课程是否过期导致! 故将该判断逻辑注释,重新编译运行,发现请求可正确到达LearningApplication! 自此,成功修复该Bug!!
![[Pasted image 20240916095301.png]]

### 代码开发-分页查询我的课表:
#### **接口设计:**
![[Pasted image 20240915193407.png]]
#### 代码开发:
##### Controller层:
- 使用构造器注入: 1)利用final定义成员变量; 2)添加@RequiredArgsConstructors注解.
```java
private final ILearningLessonService lessonService;

@GetMapping("page")  
@ApiOperation("分页查询我的课表")  
public PageDTO<LearningLessonVO> queryMyLessons(PageQuery pageQuery){  
    return lessonService.queryMyLessons(pageQuery);  
}
```
##### Service层:
>[!实现分页查询的几种方法]
>1)利用MyBatis分页插件的`PageHelper.startPage(PageNum,PageSize)`方法;
>2)利用MyBatis中的Page方法


### 接口开发-查询正在学习的课程

# Day03:学习计划和进度
## 提交学习记录:
### 需求分析和接口设计:

#### 需求:
在课程学习页面播放视频时或考试后,需要提交学习记录信息到服务端保存.
![[Pasted image 20240917104006.png|300]]
#### 接口:
- 小节类型包含课程or考试.若考试,则直接记录未完成;若为课程,则需判断视频播放进度超过50%.
![[Pasted image 20240917104134.png]]![[Pasted image 20240917144410.png]]

## 课程过期定时任务
- 利用SpringTask实现定时任务: 1)启动类上开启@EnableScheduling注解; 2)编写定时任务类,如下
```java
@Component
public class LessonStatusCheckJob(){
	@Scheduled(cron = "0 * * * * ?") // 代表每分钟的第0秒执行一次
	public void lessonStatusCheck(){
		// 1. 查询所有未过期的课程 
		List<LearningLesson> list = lessonService.list(Wrappers.<LearningLesson>lambdaQuery()
										.ne(LearningLesson::getStatus, LessonStatus.EXPIRED);
					
		// 2. 判断是否过期
		for (LearningLesson lesson : list){
			if(now.isAfter(lesson.getExpireTime())){
				lesson.setStatus(LessonStatus.Expired);
			}
		}
		// 3. 批量更新
		lessonSerivce.updateBatchById(list);
	}
}
```

## 方案思考
### 思考题：思考一下目前提交学习记录功能可能存在哪些问题？有哪些可以改进的方向？
- 更新学习记录时,因为是每15秒查询一次,所以在用户量大时,对数据库的访问量很大! 所以在"更新最近学习小节"与"更新最近学习时间"时,需要进行优化!

# @Validated注解

# 面试题:
## 1. 你在开发中参与了哪些功能开发让你觉得比较有挑战性？
我参与了整个学习中心的功能开发，其中有很多的学习辅助功能都很有特色。比如视频播放的进度记录。我们网站的课程是以录播视频为主，为了提高用户的学习体验，需要实现**视频续播**功能。这个功能本身并不复杂，只不过我们产品提出的要求比较高：
- 首先续播**时间误差要控制在30秒以内**。
- 而且要做到用户突然断开，甚至切换设备后，都可以继续上一次播放
要达成这个目的，使用传统的手段显然是不行的。
首先，要做到切换设备后还能续播，用户的播放进度必须保存在服务端，而不是客户端。
其次，用户突然断开或者切换设备，续播的时间误差不能超过30秒，那播放进度的记录频率就需要比较高。我们会在**前端每隔15秒就发起一次心跳请求,提交最新的播放进度，记录到服务端**。这样用户下一次续播时直接读取服务端的播放进度，就可以将时间误差控制在15秒左右。

注：此时面试官会追问：播放进度写到服务端保存在哪里？如果写在数据库，那写数据库的压力是不是太大了？等一系列问题，这个会在下一节内容中讲解。

# Day04:高并发优化
## 1. 高并发优化方案:
解决高并发问题从宏观角度来说有3个方向:
其中，水平扩展和服务保护侧重的是运维层面的处理。而**提高单机并发能力侧重**的则是业务层面的处理，也就是我们程序员在开发时可以做到的。
![[Pasted image 20240917191422.png]]
### 1.1 提高单机并发能力:
- 在机器性能一定的情况下,提高单机并发能力就是要尽可能**缩短业务的响应时间**（**R**esponse**T**ime）,而对响应时间影响最大的往往是对数据库的操作。
![[Pasted image 20240917191849.png]]
### 1.2 变同步写为异步写
![[Pasted image 20240917193108.png]]
利用MQ可以把同步业务变成异步，从而提高效率。
- 当我们接收到用户请求后,可以先不处理业务,而是**发送MQ消息并返回给用户结果**。
- 而后通过**消息监听器**监听MQ消息,处理后续业务。

#### **优点**:
- 无需等待复杂业务处理，大大减少响应时间
- 利用MQ暂存消息，起到流量削峰整形作用
- 降低写数据库频率，减轻数据库并发压力
#### 缺点：
- 依赖于MQ的可靠性
- 降低了写频率,但是没有减少数据库写次数
#### 应用场景：
- 比较适合应用于业务复杂,业务链较长,有多次数据库写操作的业务.

### 1.3 合并写请求:
- 合并写请求就是指当写数据库并发较高时，不再直接写到数据库。而是**先将数据缓存到Redis**，然后**定期**将缓存中的数据批量写入数据库。
![[Pasted image 20240917193640.png]]
- 由于Redis是内存操作，写的效率也非常高，这样每次**请求的处理速度大大提高,响应时间大大缩短**，并发能力肯定有很大的提升。
- 而且由于数据都缓存到Redis了，积累一些数据后再**批量写入**数据库，这样数据库的写频率、写次数都大大减少，对数据库压力小了非常多！
#### 优点:
- 写缓存速度快，响应时间大大减少
- 降低数据库的写频率和写次数，大大减轻数据库压力
#### 缺点:
- 实现相对复杂
- 依赖Redis可靠性
-  不支持事务和复杂业务
#### 场景:
- 写频率较高、写业务相对简单的场景

## 2. 播放进度记录方案改进
- 播放进度统计包含大量的数据库读,写操作, 尤其是写操作, 所以通过高并发优化方案2来实现,即合并写请求.
### 2.1 优化方案选择:
前端**每隔15秒**就提交一次请求。在一个视频播放的过程中，可能有数十次请求，但**完播（进度超50%）的请求只会有一次**。因此多数情况下都是更新一下播放进度即可。也就是说，**95%的请求都是在更新`learning_record`表中的`moment`字段，以及`learning_lesson`表中的正在学习的小节id和时间。** 并且我们只需记录最后一次的播放进度即可,故采用合并写的方案来降低数据库写的次数和频率.

### 2.2 Redis数据结构设计:
因为需要更新某个用户的某个小节的播放进度,所以Key为sectionId和userid,Value为播放进度(moment)和用户id. 因为sectionId和userId即为lessonId,故选择lessonId作为Key值即可. 
![[Pasted image 20240917194756.png#pic_center|300]]
这样设计有一个问题.课程有很多,每个课程的小节也非常多.每个小节都是一个独立的KEY，需要创建的KEY也会非常多,浪费大量内存.

而且，用户学习视频的过程中，可能会在多个视频之间来回跳转，这就会导致**频繁的创建缓存、缓存过期，影响到最终的业务性能**。该如何解决呢? 
	可以把一个课程的多个小节作为一个KEY来缓存:
![[Pasted image 20240917200513.png|400]]
这样做有两个好处：
- 可以大大**减少需要创建的KEY的数量**，减少内存占用。
- 一个课程创建一个缓存，当用户在**多个视频间跳转时，整个缓存的有效期都会被延续**，**不会频繁的创建和销毁缓存数据**
### 2.3 业务流程更新:
添加缓存以后，学习记录提交的业务流程就需要发生一些变化:
![[Pasted image 20240917200815.png]]
变化最大的有几点：
- 查询记录是否存在时,先查询Redis,再查询数据库.若Redis无而DB有,则将DB中的数据存入Redis,并继续走左侧分支.
- 提交播放进度后,如果是**更新播放进度则不写数据库,而是写缓存,即更新Redis中的moment**
- 需要一个定时任务，**定期将缓存数据写入数据库**
### 2.4 持久化思路 
对于合并写请求方案，一定有一个步骤就是持久化缓存数据到数据库。一般采用的是定时任务持久化. 但是又会有两个问题: 1)定时任务频率太高,则会造成数据库压力过大; 2)定时任务频率太低,则不满足续播的误差需求.

> 那么问题来了，有什么办法能够在**不增加数据库压力的情况下,保证时间误差较低**吗？

我们再次打开该视频续播的时候，肯定是从最后一次提交的播放进度来续播。也就是说**续播进度之前的N次播放进度都是没有意义的**，都会被覆盖。

既然如此，我们完全没有必要定期把这些播放进度写到数据库，只需要将用户最后一次提交的播放进度写入数据库即可。所以我们完全没有必要定期把这些播放进度写到数据库，只需要将用户**最后一次提交的播放进度写入数据库**即可。

> 但问题来了，我们怎么知道哪一次提交是最后一次提交呢？

只要用户一直在提交记录，Redis中的播放进度就会一直变化。**如果Redis中的播放进度不变，肯定是停止了播放，是最后一次提交。**

>因此，我们只要能判断Redis中的播放进度是否变化即可。怎么判断呢？

每当前端提交播放记录时，我们可以**设置一个延迟任务并保存这次提交的进度**。等待20秒后（因为前端每15秒提交一次，**20秒就是等待下一次提交**），检查Redis中的缓存的进度与任务中的进度是否一致。
- 不一致：说明持续在提交，无需处理
- 一致：说明是最后一次提交，更新学习记录、更新课表最近学习小节和时间到数据库中.

流程如下:![[Pasted image 20240917204209.png]]

## 3. 延迟任务
### 3.1 延迟任务方案
![[Pasted image 20240917204644.png]] 
### DelayQueue的用法:
- `Delayed`类型元素,即实现了Delayed接口的延迟任务类:
  - 实现getDelay()和compareTo()方法,功能为获取剩余延迟时间、比较执行顺序.
```Java
@Data
public class DelayTask<D> implements Delayed {
    private D data;
    private long deadlineNanos;

    public DelayTask(D data, Duration delayTime) {
        this.data = data;
        this.deadlineNanos = System.nanoTime() + delayTime.toNanos();
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(Math.max(0, deadlineNanos - System.nanoTime()), TimeUnit.NANOSECONDS);
    }

    @Override
    public int compareTo(Delayed o) {
        long l = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);
        if(l > 0){
            return 1;
        }else if(l < 0){
            return -1;
        }else {
            return 0;
        }
    }
}
```

- `queue.add(new DelayTask<>(Object,Times))`:往延迟队列中添加`Delayed`类型元素;
- `queue.poll()`: 非阻塞式出队方法,即为空时也会执行并输出;
- `queue.take()`: 阻塞式出队方法,只有当非空时才会出队. 无元素时,线程会一直等待!

## 4. 代码改造
将业务流程封装成工具类,需要时直接调用工具类即可.
1. 添加播放记录到Redis，并添加一个延迟检测任务到DelayQueue
2. 查询Redis缓存中的指定小节的播放记录
3. 删除Redis缓存中的指定小节的播放记录
4. 异步执行DelayQueue中的延迟检测任务，检测播放进度是否变化，如果无变化则写入数据库
### 4.1 定义延迟任务工具类: 
定义延迟任务类,实现Delayed接口,实现其中的`getDelay()`与`compareTo()`方法.
```java
@Data  
public class DelayTask<D> implements Delayed {  
    private D data;  
    private long deadlineNanos;  
  
    public DelayTask(D data, Duration delayTime) {  
        this.data = data;  
        this.deadlineNanos = System.nanoTime() + delayTime.toNanos();  
    }  
  
    @Override  
    public long getDelay(TimeUnit unit) {  
        return unit.convert(Math.max(0, deadlineNanos - System.nanoTime()), TimeUnit.NANOSECONDS);  
    }  
  
    @Override  
    public int compareTo(Delayed o) {  
        long l = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);  
        if(l > 0){  
            return 1;  
        }else if(l < 0){  
            return -1;  
        }else {  
            return 0;  
        }  
    }  
}
```

### 4.2 添加播放记录到Redis与添加延迟任务到DelayQueue

```java
public void addLearningRecordTask(LearningRecord record){  
    // 1.添加数据到Redis缓存  
    writeRecordCache(record);  
    // 2.提交延迟任务到延迟队列 DelayQueue    
    queue.add(new DelayTask<>(new RecordTaskData(record), Duration.ofSeconds(20)));  
}  
  
public void writeRecordCache(LearningRecord record) {  
    log.debug("更新学习记录的缓存数据");  
    try {  
        // 1.数据转换:转换为Json字符串存储到Redis中.
        String json = JsonUtils.toJsonStr(new RecordCacheData(record));  
        // 2.写入Redis,定义Key为learning:record:LessonId
        String key = StringUtils.format(RECORD_KEY_TEMPLATE, record.getLessonId());  
        redisTemplate.opsForHash().put(key, record.getSectionId().toString(), json);  
        // 3.添加缓存过期时间. 缓存过期时间为1mins,而Redis中数据每20秒不更新就会写入DB中,故无影响.
        redisTemplate.expire(key, Duration.ofMinutes(1));  
    } catch (Exception e) {  
        log.error("更新学习记录缓存异常", e);  
    }  
}
```
其中,RecordCacheData类如下,即对应了Redis中的HashValue中的属性.
![[Pasted image 20240917200513.png|400]]
```java
@Data  
@NoArgsConstructor  
private static class RecordCacheData{  
    private Long id;  
    private Integer moment;  
    private Boolean finished;  
  
    public RecordCacheData(LearningRecord record) {  
        this.id = record.getId();  
        this.moment = record.getMoment();  
        this.finished = record.getFinished();  
    }  
}
```

RecordTaskData类:
- 对应Redis中的属性.
```java
@Data  
@NoArgsConstructor  
private static class RecordTaskData{  
    private Long lessonId;  
    private Long sectionId;  
    private Integer moment;  
  
    public RecordTaskData(LearningRecord record) {  
        this.lessonId = record.getLessonId();  
        this.sectionId = record.getSectionId();  
        this.moment = record.getMoment();  
    }  
}
```

### 4.3 查询小节播放记录
从Redis中读取播放记录.
```java
public LearningRecord readRecordCache(Long lessonId, Long sectionId){  
    try {  
        // 1.读取Redis数据:拼接Key并查询!
        String key = StringUtils.format(RECORD_KEY_TEMPLATE, lessonId);  
        Object cacheData = redisTemplate.opsForHash().get(key, sectionId.toString());  
        if (cacheData == null) {  
            return null;  
        }  
        // 2.数据检查和转换  
        return JsonUtils.toBean(cacheData.toString(), LearningRecord.class);  
    } catch (Exception e) {  
        log.error("缓存读取异常", e);  
        return null;  
    }  
}
```

### 4.4 删除小节播放记录
```java
public void cleanRecordCache(Long lessonId, Long sectionId){  
    // 删除数据:拼接Key,查询然后删除.
    String key = StringUtils.format(RECORD_KEY_TEMPLATE, lessonId);  
    redisTemplate.opsForHash().delete(key, sectionId.toString());  
}
```

### 4.5 异步延迟任务
- @PostConstructor:当前类实例化后且属性注入后执行,常用来做初始化!
- @PreDestory:当前类实例销毁前执行.
```java
@PostConstruct  
public void init(){  
    CompletableFuture.runAsync(this::handleDelayTask);  
}  
@PreDestroy  
public void destroy(){  
    log.debug("关闭学习记录处理的延迟任务");  
    begin = false;  
}  
private void handleDelayTask(){  
    while (begin){  
        try {  
            // 1.尝试获取任务: 阻塞式拉取任务
            DelayTask<RecordTaskData> task = queue.take();  
            log.debug("获取到要处理的播放记录任务");  
            RecordTaskData data = task.getData();  
            // 2.读取Redis缓存  
            LearningRecord record = readRecordCache(data.getLessonId(), data.getSectionId());  
            if (record == null) {  
                continue;  
            }  
            // 3.比较数据:拿Redis中的播放记录与任务中的播放记录进行比较!
            if(!Objects.equals(data.getMoment(), record.getMoment())){  
                // 4.如果不一致，播放进度在变化，无需持久化  
                continue;  
            }  
            // 5.如果一致，证明用户离开了视频，需要持久化: 更新数据库
            // 5.1.更新学习记录  
            record.setFinished(null);  
            recordMapper.updateById(record);  
            // 5.2.更新课表  
            LearningLesson lesson = new LearningLesson();  
            lesson.setId(data.getLessonId());  
            lesson.setLatestSectionId(data.getSectionId());  
            lesson.setLatestLearnTime(LocalDateTime.now());  
            lessonService.updateById(lesson);  
  
            log.debug("准备持久化学习记录信息");  
        } catch (Exception e) {  
            log.error("处理播放记录任务发生异常", e);  
        }  
    }  
}
```

### 4.6 源代码改造
将源代码的查询学习记录逻辑(直接查询数据库)进行改造:
1. 先查询缓存
2. 若命中,则直接返回缓存数据;
2. 若未命中,则再查询数据库,并将数据库中的数据写入缓存!

```java
private LearningRecord queryOldRecord(Long lessonId, Long sectionId) {
	// 1.查询缓存
	LearningRecord cache = taskHandler.readRecordCache(lessonId, sectionId);
	// 2.如果命中，直接返回
	if (record != null) {
		return cache;
	}
	// 3.未命中，查询数据库
	LearningRecord dbRecord = lambdaQuery()
			.eq(LearningRecord::getLessonId, lessonId)
			.eq(LearningRecord::getSectionId, sectionId)
			.one();
	// 若数据库中的数据也为空,则返回null以便后面判断通过,以新增学习逻辑.
	if (record == null){
		return null;
	}
	// 4.写入缓存
	taskHandler.writeRecordCache(record);
	return record;
}
```