# Day01
## 前端环境搭建
1. 运行nginx,实现**端口转发**和反向代理:通过此配置可以将前端请求转发到后端服务.
## 后端环境搭建
### 1. 导入工程,各模块具体作用及介绍:
![[SkyTakeout_ModulesRole.png]]
- **Common类存放的子模块及作用:**
	  存放公共类,可供其他模块使用,例如exception,enumeration,utils等.
	- Pojo类存放的子模块及作用:
	  存放entity,DTO,VO模块.![[SkyTakeout_PojoModulesRole.png]]
		- DTO:Data Transfer Object,用于前端和后端传输数据时所用的对象,即用于**层与层之间的数据传输**.
		- VO:View Object,用于表示不可变的数据集合，不涉及持久化,是为前端展示数据所使用的对象.
		- PO:Persistent Object,用于数据库持久化,与数据库表的字段具有一一映射的关系,只有属性和getter,setter方法.
- **Server类的子模块及作用:**
  存放配置文件,配置类,拦截器,controller,service,mapper和启动类等.
### 2. Git远程仓库的创建:
- IDEA中: VCS→Create Git Repository,创建git本地仓库;
- Commit`-o-`: 将文件提交到本地仓库;
- 创建Github远程仓库,复制SSH链接.先在IEDA中push→Define Remote,然后复制SSH链接,将Git本地仓库与Github上的远程仓库进行连接;
- 将Commit的文件推送到远程仓库.
### 3. 数据库导入:
- 导入sky.sql.
### 4. 运行项目:
- application.yaml配置文件中,将数据库的用户名与密码修改成自己的;启动nginx服务;运行sky-server中的启动类;访问localhost/login页面并登录.
> [!NOTE] **思考:前端发送的请求是如何请求到后端服务的?前端请求地址与后端接口地址并不完全一致,这是为什么?**
> - 通过**nginx反向代理**实现,将前端发送的动态请求由nginx转发到后端服务器;
> - nginx的优点有: 1)**提高访问速度**,**nginx可以缓存后端服务器的响应结果**,当同样的前端请求到达时,可以直接返回缓存结果,而无需再次请求后端服务器; 2)负载均衡,将大量请求均衡分配给集群中的每台服务器;3)保证后端服务安全,集群部署在内网,对外只开放nginx服务器,隐藏了后端服务器的实际IP地址和端口.
- **nginx的配置:**
	**反向代理:**
```nginx
server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass http://localhost:8080/admin/; #反向代理
    }
}
```
其中,listen代表监听的端口; server_name代表需要处理的主机名或域名; location代表匹配路径,即`~/api/`的请求都会被处理,并转发到反向代理的路径proxy_pass
	**负载均衡:**
```
upstream webservers{
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
}
server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass http://webservers/admin; #负载均衡
    }
}
```
代表前端请求会被转发到两台server服务器中,并且默认配置为轮询.

**负载均衡策略:**![[SkyTakeout_LoadBalance.png]]

### 5. 登录功能完善:(增加MD5加密)
1. 修改数据库明文密码为MD5加密后的密文;
2. 修改Java代码,将前端提交的密码经MD5加密后与数据库中的密文进行比对:
	`password = DigestUtils.md5DigestAsHex(password.getBytes());`
### 6. 导入接口文档:
1. 将json格式的接口文件导入Yapi接口管理平台(设计阶段使用).
2. 后端接口文档生成及接口测试:(**Swagger**(开发阶段使用)→Knife4j(MVC框架集成Swagger的增强方案)) 
	1) 导入Maven坐标;
	2) MvcConfig中加入Knife4j配置:
	**WebMvcConfiguration.java**
```java
/**
     * 通过knife4j生成接口文档
     * @return
*/
    @Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }

```

	3) 设置静态资源映射: 
```java
/**
	 * 设置静态资源映射
	 * @param registry
*/
		protected void addResourceHandlers(ResourceHandlerRegistry registry) {
				registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
		        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
		}
```
- Knife4j常用注解介绍:![[SkyTakeout_knife4jAnno.png]]

# Day02:
## 新增员工
### 1. 需求分析:
- 根据产品原型分析需求;
- 设计接口:明确新增员工接口的**请求路径、请求方式、请求参数、返回数据**。
- 设计表.
### 2. 代码开发:
1. 设计DTO类:当前端提交的数据和实体类中对应的属性差别比较大时,建议使用DTO来封装数据.
	- 由于上述**传入参数和实体类有**较大差别，所以在sky-pojo-dto中自定义DTO类用于接收前端传输的数据:![[SkyTakeout_AddEmployeeDTO.png]]
2. 在sky-controller的EmployeeController中创建新增员工方法:
```java
	/**  
     * 新增员工  
     * @param employeeDTO  
     * @return  
     */  
    @PostMapping  
    @ApiOperation("新增员工")  
    public Result save(@RequestBody EmployeeDTO employeeDTO){  
        log.info("新增员工:{}", employeeDTO);  
//        log.info("当前线程id"+ Thread.currentThread().getId());  
        employeeServiceImpl.save(employeeDTO);  
        return Result.success();  
    }
```
	Result类为后端统一的返回结果,包含三个属性"code","msg","data".
3. 定义Service层接口:EmployeeService中声明save()方法.
```java
/**  
 * 新增员工  
 * @param employeeDTO  
 */  
void save(EmployeeDTO employeeDTO);
```
4. 在EmployeeServiceImpl中实现该方法:
```java
    @Override  
    public void save(EmployeeDTO employeeDTO) {  
        Employee employee = new Employee();  
  
//        log.info("当前线程id"+ Thread.currentThread().getId());  
  
//        拷贝属性  
        BeanUtils.copyProperties(employeeDTO, employee);  
  
//        设置默认属性:对于字符串,定义常量类.
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));  
        employee.setStatus(StatusConstant.ENABLE);  
        employee.setCreateTime(LocalDateTime.now());  
        employee.setUpdateTime(LocalDateTime.now());  
//        设置创建新用户的人的id.(创建者id) :根据登陆者token获得其id.
        Long currentId = BaseContext.getCurrentId();  
        employee.setCreateUser(currentId);  
        employee.setUpdateUser(currentId);  
  
        employeeMapper.insert(employee);  
    }
```
	1) 接收了前端传输的DTO类,使用BeanUtils中的copyProperties方法将属性复制到Entity类中,然后对于两者差异的属性,使用set方法进行赋默认值.
	2) 对于字符串的值,在sky-common模块中定义Constant类,便于后续修改,且更规范.
5. Mapper层用于实现数据库与后端的交互.这里通过insert方法实现将数据写入数据库,并且因为SQL语句较简单,所以使用注解`@INSERT`的方式编写.(或者可以利用MyBatisPlus直接生成)
```java
@Insert("INSERT INTO employee (id, name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) " +  
        "VALUES (#{id},#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})")  
void insert(Employee employee);
```
SQL语句为:`INSERT INTO TABLE_NAME (id,...) VALUES (#{id},...)`
### 3. 功能测试:
测试方法: 1)前后端联调测试; 2)接口文档测试.
#### 接口文档测试:
1. 在使用接口文档测试时,需要**先设置全局参数token**,才能保证发送的数据能通关Jwt令牌拦截器;
#### 前后端联调测试:
![[SkyTakeout_AddEmployeeTest.png]]
### 4. 代码完善:
在前面编写代码时,留下两个TODO:1)若录入的用户已存在,抛出异常状态码500,并未对异常进行处理; 2)`setCreateUser(10L)`和`setUpdateUser(10L)`传入的是固定值.
#### 1) 处理录入重复用户的异常
表中username设置了"unique",所以不能重复.
1. 在sky-server-GlobalExceptionHandler全局异常处理器中处理该异常:
```java
    /**  
     * 捕获SQL异常(用户名已存在)  
     * @param ex  
     * @return  
     */  
    @ExceptionHandler  
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){  
//        ### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry '小智' for key 'employee.idx_username'  
        String exMessage = ex.getMessage();  
        if (exMessage.contains("Duplicate entry")) {  
            String duplicateName = exMessage.split(" ")[2];  
            String msg = duplicateName + MessageConstant.USERNAME_ALREADYEXISTS;  
            return Result.error(msg);  
        }else {  
            return Result.error(MessageConstant.UNKNOWN_ERROR);  
        }  
    }
```
- 这里获取了SQL的异常语句:`"Duplicate entry '小智' for key 'employee.idx_username'"`, 然后通过`split(" ")[2]`取出其重复的用户名, 然后通过常量类`ALREADYEXISTS`与重复名的拼接,并利用返回结果Result类进行封装,最终实现返回结果:`小智已存在!`
- 使用`if-Contains()`方法确保程序的健壮性,保证处理的是重复用户名的异常;若不是,抛出未知错误的异常信息.
#### 2) 设置创建/修改者的用户id为固定值
根据登录者(当前用户)的token(jwt令牌)动态获取其id.前后端登录校验Jwt令牌的流程如下:![[SkyTakeout_UserIndentify.png]]
据此,可知会为每个用户都生成JwtToken,并且之后前端发送数据时抖会携带该token,故可通过JwtToken获得用户id.
1. 在sky-server-controller中的EmployeeController类中,存在根据用户id为其生成JwtToken的方法:
```java
//登录成功后，生成jwt令牌  
Map<String, Object> claims = new HashMap<>();  
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());  
String token = JwtUtil.createJWT(  
        jwtProperties.getAdminSecretKey(),  
        jwtProperties.getAdminTtl(),  
        claims);
```
可以看出,是根据用户的id来生成相应的Jwt令牌的(id为主键,自增且唯一).故可以根据id来获取其JwtToken.
2. 在sky-server-interceptor的JwtTokenInterceptor类中,存在解析token的方法:
```java
   /**  
     * 校验jwt  
     *     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //判断当前拦截到的是Controller的方法还是其他资源  
        if (!(handler instanceof HandlerMethod)) {  
            //当前拦截到的不是动态方法，直接放行  
            return true;  
        }  
        //1、从请求头中获取令牌  
        String token = request.getHeader(jwtProperties.getAdminTokenName());  
       // log.info("当前线程id"+ Thread.currentThread().getId());  

        //2、校验令牌  
        try {  
            log.info("jwt校验:{}", token);  
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);  
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
            log.info("当前员工id：", empId);  
            BaseContext.setCurrentId(empId);  
            //3、通过，放行  
            return true;  
        } catch (Exception ex) {  
            //4、不通过，响应401状态码  
            response.setStatus(401);  
            return false;  
        }  
    }
```
前端发送的请求中包含token,通过`request.getHeader(jwtProperties.getAdminTokenName())`来获取用户Token.
3. 在拦截器处获得了用户的Token,如何传递给service层呢? 因为拦截器,Controller和Service层共用一个线程,所以通过ThreadLocal实现.
```
在拦截器中设置线程局部变量:
	/////将用户id存储到ThreadLocal////////
	BaseContext.setCurrentId(empId);

在Service中获取局部变量:
//  设置创建新用户的人的id.(创建者id)  
	Long currentId = BaseContext.getCurrentId();  
	employee.setCreateUser(currentId);  
	employee.setUpdateUser(currentId);
```
##### **ThreadLocal**
**介绍:**
- ThreadLocal并不是一个Thread，而是Thread的局部变量。 ThreadLocal为**每个线程提供单独一份存储空间**，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
**常用方法:**
- `public void set(T value)`:设置当前线程的线程局部变量的值
- `public T get()`:返回当前线程所对应的线程局部变量的值
- `public void remove()`:移除当前线程的线程局部变量
![[SkyTakeout_ThreadLocal.png]]
通过ske-common-context中的BaseContext类封装了ThreadLocal方法:
```java
package com.sky.context;

public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```
---


## 员工分页查询:
### 需求分析和接口设计:
**业务规则**：
- 根据页码展示员工信息
- 每页展示10条数据
- 分页查询时可以根据需要，输入员工姓名进行查询
**接口设计:**
![[SkyTakeout_PageQueryInterface.png|300]]![[Pasted image 20240901144042.png|400]]
使用GET请求. 返回数据中必须带有Data,所以返回值为`Result<Employee>.`
### 代码开发:
1. 封装DTO类,用于接收GET请求参数:
```java
@Data
public class EmployeePageQueryDTO implements Serializable {

    //员工姓名

    //页码
    private int page;

    //每页显示记录数
    private int pageSize;
}
```
2. 封装PageResult,用于接收分页查询结果,即data中的total和records.
```java
/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable {

    private long total; //总记录数

    private List records; //当前页数据集合

}
```
3. 在Controller层中,定义分页查询方法`Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO)`:
因为接口定义中返回的Result的data为必须项,且数据包含`total`,`data`.
```java
	/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping("/page")
    @ApiOperation("员工分页查询")
    public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO){
        log.info("员工分页查询，参数为：{}", employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);//后续定义
        return Result.success(pageResult);
    }
```
4. Service层中,通过PageHelper进行分页,`startPage()`方法用于定义第几页及每页的数据量;调用Mapper中的方法进行查询,返回`Page<Employee>`结果,并且**Page类中有`getTotal()`和`getResult()`方法用于获取PageResult中的total和records属性.**
```java
/**  
 * 分页查询  
 * @param employeePageQueryDTO  
 * @return  
 */  
@Override  
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {  
    PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());  
    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);  
  
    return new PageResult(page.getTotal(),page.getResult());  
}
```
5. Mapper层中,在xml文件中定义SQL语句.通过resultType定义返回参数;if标签用于判断传入的参数是否为空,若非空,则添加该WHERE标签;并将查询到的employee按创建时间降序排列;**分页插件PageHelper会在调用pageQuery查询语句时在末尾添加LIMIT语句,并将返回结果包装成`Page<ResultType>`类.**

> [!NOTE] 何时会在SQL语句后添加LIMIT参数?
> `PageHelper`插件的工作原理是基于**ThreadLocal**存储分页信息,当某个线程调用分页方法时,`PageHelper`会在该线程的上下文中设置分页参数.
> SQL语句上面添加代码`PageHelper.startPage()`,即可实现在SQL语句后自动添加LIMIT参数.
```xml
<select id="pageQuery" resultType="com.sky.entity.Employee">  
    SELECT * FROM employee    
    <where>  
        <if test="name != null and name != ''">  
            AND name LIKE concat('%',#{name},'%')        
		</if>  
    </where>  
    ORDER BY create_time desc
</select>
```
### 代码完善:
在测试中,返回结果的日期未格式化.通过两种方法实现:1)对应属性上加上注解@JsonFormat();2) 拓展WebMvcConfiguration中拓展SpringMVC的消息转换器.
1.先定义转换器; 2.设置转换器,实现序列化; 3.添加到容器converters中,并设置index,使其能先被执行. 
```java
    @Override  
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  
        log.info("消息转换器启动..");  
//          创建消息转换器  
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();  
//         设置对象转换器 -> 序列化: 将Java对象转换为Json  
        converter.setObjectMapper(new JacksonObjectMapper());  
//        将自定义消息转换器加入容器. index转换器顺序.  
        converters.add(0,converter);  
    }
```
## 启用禁用员工账号:
### 需求分析和设计:
**业务规则：**
- 可以对状态为“启用” 的员工账号进行“禁用”操作 
- 可以对状态为“禁用”的员工账号进行“启用”操作
- 状态为“禁用”的员工账号不能登录系统
**接口设计:**
![[SkyTakeout_UpdateStatus.png|300]]![[SkyTakeout_updateStatus2.png|300]]
- POST请求,请求参数放在路径中`{Status}`->通过@PathVariable接收.
- 返回结果中只有Code为必须->即返回修改是否成功
### 代码开发:
1. **Controller层**,定义startOrStop()方法,通过注解@PathVariable()接收路径参数. 调用Service层方法,返回Result.success()结果.
```java
/**  
 * 启用或禁用员工账号  
 * @param status  
 * @param id  
 * @return  
 */  
@PostMapping("/status/{status}")  
@ApiOperation("启用或禁用员工")  
public Result startOrStop(@PathVariable Integer status, Long id){  
    log.info("启用禁用员工账号");  
    employeeService.startOrStop(status,id);  
    return Result.success();  
}
```
2. **Service层**,定义startOrStop()方法.调用Mapper层的update方法更新数据.
因为Employee实体类中添加了@Builder注解,可通过builder方法来设置对象属性,可读性更高.
```java
@Override  
public void startOrStop(Integer status, Long id) {  
    Employee employee = Employee.builder()  
            .status(status)  
            .id(id)  
            .build();  
    employeeMapper.update(employee);  
}
```
3. **Mapper层**,定义通用的update()方法,在xml中写SQL语句.通过if标签来设置更新已有属性,未传入的则不更新.
```xml
<update id="update" parameterType="Employee">  
    UPDATE employee    <set>  
        <if test="name != null">name = #{name},</if>  
        <if test="username != null">username = #{username},</if>  
        <if test="password != null">password = #{password},</if>  
        <if test="phone != null">phone = #{phone},</if>  
        <if test="sex != null">sex = #{sex},</if>  
        <if test="idNumber != null">id_Number = #{idNumber},</if>  
        <if test="updateTime != null">update_Time = #{updateTime},</if>  
        <if test="updateUser != null">update_User = #{updateUser},</if>  
        <if test="status != null">status = #{status},</if>  
    </set>  
        WHERE id = #{id};</update>
```
## 编辑员工:

# Day03:
## 公共字段自动填充:

## 新增菜品:
### 需求设计和分析:
#### **业务规则:**
- 菜品名称必须是唯一的
- 菜品必须属于某个分类下，不能单独存在
- 新增菜品时可以根据情况选择菜品的口味
- 每个菜品必须对应一张图片
#### **接口设计:**
- 根据类型查询分类（已完成）![[SkyTakeout_SearchByCata.png]]
- 文件上传![[skyTakeout_uploadFile.png]]
- 新增菜品![[SkyTakeout_addNewDish.png]]
#### **数据库设计:** 
**逻辑外键:** 即不在数据库中体现,而是通过程序保证其唯一.
![[SkyTakeout_dbdesign.png]]

### 代码开发:
