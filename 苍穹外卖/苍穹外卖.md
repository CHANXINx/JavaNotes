# Day01
## 前端环境搭建
1. 运行nginx,实现**端口转发**和反向代理:通过此配置可以将前端请求转发到后端服务.
## 后端环境搭建
### 1. 导入工程,各模块具体作用及介绍:
![[SkyTakeout_ModulesRole.png]]
- **Common类存放的子模块及作用:**
	  存放公共类,可供其他模块使用,例如exception,enumeration,utils等.
	- Pojo类存放的子模块及作用:
	  存放entity,DTO,VO模块.![[SkyTakeout_PojoModulesRole.png]]
		- DTO:Data Transfer Object,用于前端和后端传输数据时所用的对象,即用于**层与层之间的数据传输**.
		- VO:View Object,用于表示不可变的数据集合，不涉及持久化,是为前端展示数据所使用的对象.
		- PO:Persistent Object,用于数据库持久化,与数据库表的字段具有一一映射的关系,只有属性和getter,setter方法.
- **Server类的子模块及作用:**
  存放配置文件,配置类,拦截器,controller,service,mapper和启动类等.
### 2. Git远程仓库的创建:
- IDEA中: VCS→Create Git Repository,创建git本地仓库;
- Commit`-o-`: 将文件提交到本地仓库;
- 创建Github远程仓库,复制SSH链接.先在IEDA中push→Define Remote,然后复制SSH链接,将Git本地仓库与Github上的远程仓库进行连接;
- 将Commit的文件推送到远程仓库.
### 3. 数据库导入:
- 导入sky.sql.
### 4. 运行项目:
- application.yaml配置文件中,将数据库的用户名与密码修改成自己的;启动nginx服务;运行sky-server中的启动类;访问localhost/login页面并登录.
> [!NOTE] **思考:前端发送的请求是如何请求到后端服务的?前端请求地址与后端接口地址并不完全一致,这是为什么?**
> - 通过**nginx反向代理**实现,将前端发送的动态请求由nginx转发到后端服务器;
> - nginx的优点有: 1)**提高访问速度**,**nginx可以缓存后端服务器的响应结果**,当同样的前端请求到达时,可以直接返回缓存结果,而无需再次请求后端服务器; 2)负载均衡,将大量请求均衡分配给集群中的每台服务器;3)保证后端服务安全,集群部署在内网,对外只开放nginx服务器,隐藏了后端服务器的实际IP地址和端口.
- **nginx的配置:**
	**反向代理:**
```nginx
server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass http://localhost:8080/admin/; #反向代理
    }
}
```
其中,listen代表监听的端口; server_name代表需要处理的主机名或域名; location代表匹配路径,即`~/api/`的请求都会被处理,并转发到反向代理的路径proxy_pass
	**负载均衡:**
```
upstream webservers{
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
}
server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass http://webservers/admin; #负载均衡
    }
}
```
代表前端请求会被转发到两台server服务器中,并且默认配置为轮询.

**负载均衡策略:**![[SkyTakeout_LoadBalance.png]]

### 5. 登录功能完善:(增加MD5加密)
1. 修改数据库明文密码为MD5加密后的密文;
2. 修改Java代码,将前端提交的密码经MD5加密后与数据库中的密文进行比对:
	`password = DigestUtils.md5DigestAsHex(password.getBytes());`
### 6. 导入接口文档:
1. 将json格式的接口文件导入Yapi接口管理平台(设计阶段使用).
2. 后端接口文档生成及接口测试:(**Swagger**(开发阶段使用)→Knife4j(MVC框架集成Swagger的增强方案)) 
	1) 导入Maven坐标;
	2) MvcConfig中加入Knife4j配置:
	**WebMvcConfiguration.java**
```java
/**
     * 通过knife4j生成接口文档
     * @return
*/
    @Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }

```

	3) 设置静态资源映射: 
```java
/**
	 * 设置静态资源映射
	 * @param registry
*/
		protected void addResourceHandlers(ResourceHandlerRegistry registry) {
				registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
		        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
		}
```
- Knife4j常用注解介绍:![[SkyTakeout_knife4jAnno.png]]

# Day02:
## 新增员工
### 1. 需求分析:
- 根据产品原型分析需求;
- 设计接口:明确新增员工接口的**请求路径、请求方式、请求参数、返回数据**。
- 设计表.
### 2. 代码开发:
1. 设计DTO类:当前端提交的数据和实体类中对应的属性差别比较大时,建议使用DTO来封装数据.
	- 由于上述**传入参数和实体类有**较大差别，所以在sky-pojo-dto中自定义DTO类用于接收前端传输的数据:![[SkyTakeout_AddEmployeeDTO.png]]
2. 在sky-controller的EmployeeController中创建新增员工方法:
```java
	/**  
     * 新增员工  
     * @param employeeDTO  
     * @return  
     */  
    @PostMapping  
    @ApiOperation("新增员工")  
    public Result save(@RequestBody EmployeeDTO employeeDTO){  
        log.info("新增员工:{}", employeeDTO);  
//        log.info("当前线程id"+ Thread.currentThread().getId());  
        employeeServiceImpl.save(employeeDTO);  
        return Result.success();  
    }
```
	Result类为后端统一的返回结果,包含三个属性"code","msg","data".
3. 定义Service层接口:EmployeeService中声明save()方法.
```java
/**  
 * 新增员工  
 * @param employeeDTO  
 */  
void save(EmployeeDTO employeeDTO);
```
4. 在EmployeeServiceImpl中实现该方法:
```java
    @Override  
    public void save(EmployeeDTO employeeDTO) {  
        Employee employee = new Employee();  
  
//        log.info("当前线程id"+ Thread.currentThread().getId());  
  
//        拷贝属性  
        BeanUtils.copyProperties(employeeDTO, employee);  
  
//        设置默认属性:对于字符串,定义常量类.
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));  
        employee.setStatus(StatusConstant.ENABLE);  
        employee.setCreateTime(LocalDateTime.now());  
        employee.setUpdateTime(LocalDateTime.now());  
//        设置创建新用户的人的id.(创建者id) :根据登陆者token获得其id.
        Long currentId = BaseContext.getCurrentId();  
        employee.setCreateUser(currentId);  
        employee.setUpdateUser(currentId);  
  
        employeeMapper.insert(employee);  
    }
```
	1) 接收了前端传输的DTO类,使用BeanUtils中的copyProperties方法将属性复制到Entity类中,然后对于两者差异的属性,使用set方法进行赋默认值.
	2) 对于字符串的值,在sky-common模块中定义Constant类,便于后续修改,且更规范.
5. Mapper层用于实现数据库与后端的交互.这里通过insert方法实现将数据写入数据库,并且因为SQL语句较简单,所以使用注解`@INSERT`的方式编写.(或者可以利用MyBatisPlus直接生成)
```java
@Insert("INSERT INTO employee (id, name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) " +  
        "VALUES (#{id},#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})")  
void insert(Employee employee);
```
SQL语句为:`INSERT INTO TABLE_NAME (id,...) VALUES (#{id},...)`
### 3. 功能测试:
测试方法: 1)前后端联调测试; 2)接口文档测试.
#### 接口文档测试:
1. 在使用接口文档测试时,需要**先设置全局参数token**,才能保证发送的数据能通关Jwt令牌拦截器;
#### 前后端联调测试:
![[SkyTakeout_AddEmployeeTest.png]]
### 4. 代码完善:
在前面编写代码时,留下两个TODO:1)若录入的用户已存在,抛出异常状态码500,并未对异常进行处理; 2)`setCreateUser(10L)`和`setUpdateUser(10L)`传入的是固定值.
#### 1) 处理录入重复用户的异常
表中username设置了"unique",所以不能重复.
1. 在sky-server-GlobalExceptionHandler全局异常处理器中处理该异常:
```java
    /**  
     * 捕获SQL异常(用户名已存在)  
     * @param ex  
     * @return  
     */  
    @ExceptionHandler  
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){  
//        ### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry '小智' for key 'employee.idx_username'  
        String exMessage = ex.getMessage();  
        if (exMessage.contains("Duplicate entry")) {  
            String duplicateName = exMessage.split(" ")[2];  
            String msg = duplicateName + MessageConstant.USERNAME_ALREADYEXISTS;  
            return Result.error(msg);  
        }else {  
            return Result.error(MessageConstant.UNKNOWN_ERROR);  
        }  
    }
```
- 这里获取了SQL的异常语句:`"Duplicate entry '小智' for key 'employee.idx_username'"`, 然后通过`split(" ")[2]`取出其重复的用户名, 然后通过常量类`ALREADYEXISTS`与重复名的拼接,并利用返回结果Result类进行封装,最终实现返回结果:`小智已存在!`
- 使用`if-Contains()`方法确保程序的健壮性,保证处理的是重复用户名的异常;若不是,抛出未知错误的异常信息.
#### 2) 设置创建/修改者的用户id为固定值
根据登录者(当前用户)的token(jwt令牌)动态获取其id.前后端登录校验Jwt令牌的流程如下:![[SkyTakeout_UserIndentify.png]]
据此,可知会为每个用户都生成JwtToken,并且之后前端发送数据时抖会携带该token,故可通过JwtToken获得用户id.
1. 在sky-server-controller中的EmployeeController类中,存在根据用户id为其生成JwtToken的方法:
```java
//登录成功后，生成jwt令牌  
Map<String, Object> claims = new HashMap<>();  
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());  
String token = JwtUtil.createJWT(  
        jwtProperties.getAdminSecretKey(),  
        jwtProperties.getAdminTtl(),  
        claims);
```
可以看出,是根据用户的id来生成相应的Jwt令牌的(id为主键,自增且唯一).故可以根据id来获取其JwtToken.
2. 在sky-server-interceptor的JwtTokenInterceptor类中,存在解析token的方法:
```java
   /**  
     * 校验jwt  
     *     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //判断当前拦截到的是Controller的方法还是其他资源  
        if (!(handler instanceof HandlerMethod)) {  
            //当前拦截到的不是动态方法，直接放行  
            return true;  
        }  
        //1、从请求头中获取令牌  
        String token = request.getHeader(jwtProperties.getAdminTokenName());  
       // log.info("当前线程id"+ Thread.currentThread().getId());  

        //2、校验令牌  
        try {  
            log.info("jwt校验:{}", token);  
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);  
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
            log.info("当前员工id：", empId);  
            BaseContext.setCurrentId(empId);  
            //3、通过，放行  
            return true;  
        } catch (Exception ex) {  
            //4、不通过，响应401状态码  
            response.setStatus(401);  
            return false;  
        }  
    }
```
前端发送的请求中包含token,通过`request.getHeader(jwtProperties.getAdminTokenName())`来获取用户Token.
3. 在拦截器处获得了用户的Token,如何传递给service层呢? 因为拦截器,Controller和Service层共用一个线程,所以通过ThreadLocal实现.
```
在拦截器中设置线程局部变量:
	/////将用户id存储到ThreadLocal////////
	BaseContext.setCurrentId(empId);

在Service中获取局部变量:
//  设置创建新用户的人的id.(创建者id)  
	Long currentId = BaseContext.getCurrentId();  
	employee.setCreateUser(currentId);  
	employee.setUpdateUser(currentId);
```
##### **ThreadLocal**
**介绍:**
- ThreadLocal并不是一个Thread，而是Thread的局部变量。 ThreadLocal为**每个线程提供单独一份存储空间**，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
**常用方法:**
- `public void set(T value)`:设置当前线程的线程局部变量的值
- `public T get()`:返回当前线程所对应的线程局部变量的值
- `public void remove()`:移除当前线程的线程局部变量
![[SkyTakeout_ThreadLocal.png]]
通过ske-common-context中的BaseContext类封装了ThreadLocal方法:
```java
package com.sky.context;

public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```
---


## 员工分页查询:
### 需求分析和接口设计:
**业务规则**：
- 根据页码展示员工信息
- 每页展示10条数据
- 分页查询时可以根据需要，输入员工姓名进行查询
**接口设计:**
![[SkyTakeout_PageQueryInterface.png|300]]![[Pasted image 20240901144042.png|400]]
使用GET请求. 返回数据中必须带有Data,所以返回值为`Result<Employee>.`
### 代码开发:
1. 封装DTO类,用于接收GET请求参数:
```java
@Data
public class EmployeePageQueryDTO implements Serializable {

    //员工姓名

    //页码
    private int page;

    //每页显示记录数
    private int pageSize;
}
```
2. 封装PageResult,用于接收分页查询结果,即data中的total和records.
```java
/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable {

    private long total; //总记录数

    private List records; //当前页数据集合

}
```
3. 在Controller层中,定义分页查询方法`Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO)`:
因为接口定义中返回的Result的data为必须项,且数据包含`total`,`data`.
```java
	/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping("/page")
    @ApiOperation("员工分页查询")
    public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO){
        log.info("员工分页查询，参数为：{}", employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);//后续定义
        return Result.success(pageResult);
    }
```
4. Service层中,通过PageHelper进行分页,`startPage()`方法用于定义第几页及每页的数据量;调用Mapper中的方法进行查询,返回`Page<Employee>`结果,并且**Page类中有`getTotal()`和`getResult()`方法用于获取PageResult中的total和records属性.**
```java
/**  
 * 分页查询  
 * @param employeePageQueryDTO  
 * @return  
 */  
@Override  
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {  
    PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());  
    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);  
  
    return new PageResult(page.getTotal(),page.getResult());  
}
```
5. Mapper层中,在xml文件中定义SQL语句.通过resultType定义返回参数;if标签用于判断传入的参数是否为空,若非空,则添加该WHERE标签;并将查询到的employee按创建时间降序排列;**分页插件PageHelper会在调用pageQuery查询语句时在末尾添加LIMIT语句,并将返回结果包装成`Page<ResultType>`类.**

> [!NOTE] 何时会在SQL语句后添加LIMIT参数?
> `PageHelper`插件的工作原理是基于**ThreadLocal**存储分页信息,当某个线程调用分页方法时,`PageHelper`会在该线程的上下文中设置分页参数.
> SQL语句上面添加代码`PageHelper.startPage()`,即可实现在SQL语句后自动添加LIMIT参数.
```xml
<select id="pageQuery" resultType="com.sky.entity.Employee">  
    SELECT * FROM employee    
    <where>  
        <if test="name != null and name != ''">  
            AND name LIKE concat('%',#{name},'%')        
		</if>  
    </where>  
    ORDER BY create_time desc
</select>
```
### 代码完善:
在测试中,返回结果的日期未格式化.通过两种方法实现:1)对应属性上加上注解@JsonFormat();2) 拓展WebMvcConfiguration中拓展SpringMVC的消息转换器.
1.先定义转换器; 2.设置转换器,实现序列化; 3.添加到容器converters中,并设置index,使其能先被执行. 
```java
    @Override  
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  
        log.info("消息转换器启动..");  
//          创建消息转换器  
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();  
//         设置对象转换器 -> 序列化: 将Java对象转换为Json  
        converter.setObjectMapper(new JacksonObjectMapper());  
//        将自定义消息转换器加入容器. index转换器顺序.  
        converters.add(0,converter);  
    }
```
## 启用禁用员工账号:
### 需求分析和设计:
**业务规则：**
- 可以对状态为“启用” 的员工账号进行“禁用”操作 
- 可以对状态为“禁用”的员工账号进行“启用”操作
- 状态为“禁用”的员工账号不能登录系统
**接口设计:**
![[SkyTakeout_UpdateStatus.png|300]]![[SkyTakeout_updateStatus2.png|300]]
- POST请求,请求参数放在路径中`{Status}`->通过@PathVariable接收.
- 返回结果中只有Code为必须->即返回修改是否成功
### 代码开发:
1. **Controller层**,定义startOrStop()方法,通过注解@PathVariable()接收路径参数. 调用Service层方法,返回Result.success()结果.
```java
/**  
 * 启用或禁用员工账号  
 * @param status  
 * @param id  
 * @return  
 */  
@PostMapping("/status/{status}")  
@ApiOperation("启用或禁用员工")  
public Result startOrStop(@PathVariable Integer status, Long id){  
    log.info("启用禁用员工账号");  
    employeeService.startOrStop(status,id);  
    return Result.success();  
}
```
2. **Service层**,定义startOrStop()方法.调用Mapper层的update方法更新数据.
因为Employee实体类中添加了@Builder注解,可通过builder方法来设置对象属性,可读性更高.
```java
@Override  
public void startOrStop(Integer status, Long id) {  
    Employee employee = Employee.builder()  
            .status(status)  
            .id(id)  
            .build();  
    employeeMapper.update(employee);  
}
```
3. **Mapper层**,定义通用的update()方法,在xml中写SQL语句.通过if标签来设置更新已有属性,未传入的则不更新.
```xml
<update id="update" parameterType="Employee">  
    UPDATE employee    <set>  
        <if test="name != null">name = #{name},</if>  
        <if test="username != null">username = #{username},</if>  
        <if test="password != null">password = #{password},</if>  
        <if test="phone != null">phone = #{phone},</if>  
        <if test="sex != null">sex = #{sex},</if>  
        <if test="idNumber != null">id_Number = #{idNumber},</if>  
        <if test="updateTime != null">update_Time = #{updateTime},</if>  
        <if test="updateUser != null">update_User = #{updateUser},</if>  
        <if test="status != null">status = #{status},</if>  
    </set>  
        WHERE id = #{id};</update>
```
## 编辑员工:

# Day03:
## 公共字段自动填充:

## 新增菜品:
### 需求设计和分析:
#### **业务规则:**
- 菜品名称必须是唯一的
- 菜品必须属于某个分类下，不能单独存在
- 新增菜品时可以根据情况选择菜品的口味
- 每个菜品必须对应一张图片
#### **接口设计:**
- 根据类型查询分类（已完成）![[SkyTakeout_SearchByCata.png]]
- 文件上传![[skyTakeout_uploadFile.png]]
- 新增菜品![[SkyTakeout_addNewDish.png]]
#### **数据库设计:** 
**逻辑外键:** 即不在数据库中体现,而是通过程序保证其唯一.
![[SkyTakeout_dbdesign.png]]

### 代码开发:
## 菜品分页查询:
## 删除菜品
### 需求分析和设计:
#### 业务规则:
- 可以一次删除一个菜品，也可以批量删除菜品
- 起售中的菜品不能删除->status判断
- 被套餐关联的菜品不能删除->
- 删除菜品后，关联的口味数据也需要删除掉->操作dish_flavors.
#### 数据库设计:![[SkyTakeout_dbDelDish.png]]

## 修改菜品:
### 需求分析和设计:
在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面**回显菜品相关信息并进行修改**，最后点击保存按钮完成修改操作。
#### 接口设计:
**接口：**
- **根据id查询菜品**![[Pasted image 20240905143724.png]]

- 根据类型查询分类(已实现)
- 文件上传(已实现)
- **修改菜品**![[Pasted image 20240905144001.png]]


# Day07:

## SpringCache:
### 介绍:
Spring Cache 是一个框架，实现了**基于注解**的缓存功能，只需要简单地加一个注解，就能实现缓存功能。
Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现,(切换很方便!)例如：
- EHCache
- Caffeine
- Redis(常用)
**起步依赖：**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-cache</artifactId>                      <version>2.7.3</version>   
</dependency>
```
### 常用注解
在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：

| **注解**         | 位置  | **说明**                                                      |
| -------------- | --- | ----------------------------------------------------------- |
| @EnableCaching | 启动类 | 开启缓存注解功能，通常**加在启动类**上                                       |
| **@Cacheable** | 方法  | 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中 |
| @CachePut      | 方法  | 将方法的返回值放到缓存中(只放不取!)                                         |
| @CacheEvict    | 方法  | 将一条或多条数据从缓存中删除(清理缓存!)                                       |

在spring boot项目中，**使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持**即可。
例如,使用Redis作为缓存技术,只需要导入Spring data Redis的maven坐标即可。

#### @CachePut:
**说明:** 
- ​作用:将方法返回值，放入缓存
**属性:**
- value:**缓存的名称**, 每个缓存名称下面可以有很多key
- key:缓存的key---------- 支持Spring的表达式语言SPEL语法
- 根据CachePut注解动态生成的KEY值为:"value::key".
```java
	/**
	* CachePut：将方法返回值放入缓存
	* value：缓存的名称，每个缓存名称下面可以有多个key
	* key：缓存的key
	*/
	@PostMapping
    @CachePut(value = "userCache", key = "#user.id")//key的生成：userCache::1
    public User save(@RequestBody User user){
        userMapper.insert(user);
        return user;
    }
```
**key的写法如下:**
`#user.id`:`#user`指的是方法形参的名称,id指的是user的id属性,也就是使用**方法形参的id属性**作为key;
`#result.id`:`#result`代表方法返回值,该表达式代表以**返回对象的id属性**作为key;
~~`#p0.id`:#p0`指的是方法中的第一个参数,id指的是第一个参数的id属性,也就是使用第一个参数的id属性作为key;
`#a0.id`:`#a0`指的是方法中的第一个参数,id指的是第一个参数的id属性,也就是使用第一个参数的id属性作为key;
`#root.args[0].id`:`#root.args[0]`指的是方法中的第一个参数，id指的是第一个参数的id属性,也就是使用第一个参数的id属性作为key;~~
​	
#### @Cacheable:
**说明:**
作用: 在**查询方法**执行前，spring**先查看缓存中是否有数据**,如果有数据,则直接返回缓存数据;若没有数据，调用查询数据库方法并将方法返回值放到缓存中
**属性:**
- value: 缓存的名称，每个缓存名称下面可以有多个key
- key: 缓存的key ----------> 支持Spring的表达式语言SPEL语法
- (Cacheable的key不能使用#result)
>[!注意]
**若在缓存中成功查询,则不会调用controller中的查询方法,即通过代理对象查询Redis是否中有数据).**

#### **@CacheEvict**
**说明:**
作用: 清理指定缓存
**属性:**
value: 缓存的名称，每个缓存名称下面可以有多个key
key: 缓存的key ----------> 支持Spring的表达式语言SPEL语法
allEntries: 若为true,则会删除Redis中value下的所有缓存数据.

## 添加购物车:
### 需求分析和设计
#### **产品原型:**
用户可以将**菜品或者套餐**添加到购物车.对于菜品来说,如果设置了**口味信息**,则需要**选择规格**后才能加入购物车;对于套餐来说,可以直接点击+将当前套餐加入购物车。在购物车中可以**修改菜品和套餐的数量，也可以清空购物车**。
#### **接口设计:**
菜品和套餐不可能同时添加,所以单次添加的请求参数只能为菜品id或套餐id.
**POST请求**:采用@RequestBody接收.
**返回参数:** 仅code是必须,故Result即可,无需携带泛型.
![[Pasted image 20240907223502.png]]
#### **数据库设计:**
![[Pasted image 20240907223711.png]]
- 冗余字段,即在多个表中反复出现的重复的字段.可提高查询速度,即**减少连接查询**!但冗余字段不可大量出现,以及应该是稳定不变的.
### 代码开发:
#### Controller层:
常见ShoppingCartController,使用POST请求,路径为~/add,使用ShoppingCartDTO接收请求参数,调用shoppingCartService处理后续逻辑.
```java
/**
 * 购物车
 */
@RestController
@RequestMapping("/user/shoppingCart")
@Slf4j
@Api(tags = "C端-购物车接口")
public class ShoppingCartController {

    @Autowired
    private ShoppingCartService shoppingCartService;

    /**
     * 添加购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping("/add")
    @ApiOperation("添加购物车")
    public Result<String> add(@RequestBody ShoppingCartDTO shoppingCartDTO){
        log.info("添加购物车：{}", shoppingCartDTO);
        shoppingCartService.addShoppingCart(shoppingCartDTO);//后绪步骤实现
        return Result.success();
    }
}
```
#### Service层:
创建ShoppingCartService接口
```java
public interface ShoppingCartService {

    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
}
```
#### Service层实现类:
实现addShoppingCart方法,处理逻辑为:
1. 根据userId查询购物车,判断当前商品是否在购物车中;
2. 根据购物车是否存在商品进行后续处理:
	1. 存在,则实现数量+1,即通过list.get(0)获取商品,并通过setNumber将数量+1,再调用updateNumberById进行数据库操作;
	2. 不存在,则新增商品,即调用insert()方法向数据库内插入数据.
		1. 需要判断插入的是套餐还是菜品(通过getSetmealId/getDishId实现)
```java
@Service  
public class ShoppingCartServiceImpl implements ShoppingCartService {  
  
    @Autowired  
    private ShoppingCartMapper shoppingCartMapper;  
    @Autowired  
    private DishMapper dishMapper;  
    @Autowired  
    private SetmealMapper setmealMapper;  
  
    /**  
     * 添加购物车  
     * @param shoppingCartDTO  
     */  
    @Override  
    public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) {  
//        判断商品是否存在：1. 存在则+1->update; 2. 不存在则添加->insert  
        ShoppingCart shoppingCart = new ShoppingCart();  
        BeanUtils.copyProperties(shoppingCartDTO,shoppingCart);  
        shoppingCart.setUserId(BaseContext.getCurrentId());  
        List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);  
  
//        购物车存在该商品  
        if (list != null && list.size() > 0 ){  
//            每个用户只有一个购物车,
            shoppingCart = list.get(0);  
//            将购物车+1  
            shoppingCart.setNumber(shoppingCart.getNumber()+1);  
            shoppingCartMapper.updateNumberById(shoppingCart);  
        }  
//        不存在,则添加该商品: 插入商品时,还需要根据是菜品还是套餐,查询菜品套餐表获得商品信息!  
        else {  
            Long dishId = shoppingCartDTO.getDishId();  
//            添加的是菜品  
            if (dishId != null){  
//                设置购物车中的菜品信息.  
                Dish dish = dishMapper.getById(dishId);  
                shoppingCart.setImage(dish.getImage());  
                shoppingCart.setName(dish.getName());  
                shoppingCart.setAmount(dish.getPrice());  
//                第一次添加,数量设置为1  
//                shoppingCart.setNumber(1);  
//                shoppingCart.setCreateTime(LocalDateTime.now());  
            }else {   // 添加的是套餐  
                Long setmealId = shoppingCartDTO.getSetmealId();  
                Setmeal setmeal = setmealMapper.getById(setmealId);  
                shoppingCart.setImage(setmeal.getImage());  
                shoppingCart.setName(setmeal.getName());  
                shoppingCart.setAmount(setmeal.getPrice());  
            }  
//            抽出相同代码  
            shoppingCart.setNumber(1);  
            shoppingCart.setCreateTime(LocalDateTime.now());  
            shoppingCartMapper.insert(shoppingCart);  
        }  
    }  
}
```

#### Mapper层:
list条件查询,获取购物车.获取该user下的商品,不同菜品,套餐和不同口味都定义为不同商品!
```java
    /**
     * 条件查询
     *
     * @param shoppingCart
     * @return
     */
    List<ShoppingCart> list(ShoppingCart shoppingCart);
```
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.ShoppingCartMapper">
    <select id="list" parameterType="ShoppingCart" resultType="ShoppingCart">
        select * from shopping_cart
        <where>
            <if test="userId != null">
                and user_id = #{userId}
            </if>
            <if test="dishId != null">
                and dish_id = #{dishId}
            </if>
            <if test="setmealId != null">
                and setmeal_id = #{setmealId}
            </if>
            <if test="dishFlavor != null">
                and dish_flavor = #{dishFlavor}
            </if>
        </where>
        order by create_time desc
    </select>
</mapper>
```
更新商品数量:
```java
/**
 * 更新商品数量
 *
 * @param shoppingCart
 */
@Update("update shopping_cart set number = #{number} where id = #{id}")
void updateNumberById(ShoppingCart shoppingCart);
```
插入购物车数据:
```java
    /**
     * 插入购物车数据
     *
     * @param shoppingCart
     */
    @Insert("insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) " +
            " values (#{name},#{userId},#{dishId},#{setmealId},#{dishFlavor},#{number},#{amount},#{image},#{createTime})")
    void insert(ShoppingCart shoppingCart);
```
## 查看购物车:
### 需求分析和接口设计
#### 接口设计: 
![[Pasted image 20240908084512.png]]
### 代码开发:
1. 返回数据中data为`OBject[]`,所以返回数据为`Result<List<ShoppingCart>>`;
2. GET请求并没有传参,故根据token获取用户id,以此调用Mapper层查询数据库获取购物车数据:`shoppingCartMapper.getById(BaseContext.getCurrentId());`
	- 也可通过添加购物车中定义的list方法进行查询,即封装获得ShoppingCart实例,但仅对userId赋值!
## 清空购物车:
### 需求分析和接口设计:
#### 接口设计:
发送DELETE请求.无需传入参数,返回参数.
![[Pasted image 20240908090703.png|300]]
### 代码开发:
- 设计`deleteById()`方法,通过token获取userId(`BaseContext.getCurrentId()`),以此操作数据库.

# Day08:
## 用户下单,订单支付:★★★★★
### 需求分析和接口设计:
#### 接口设计:

#### 数据库设计:
![[Pasted image 20240909012834.png]]
![[Pasted image 20240909012934.png]]
![[Pasted image 20240909013043.png]]
### 代码开发:
#### Controller层:
- 创建order方法,实现用户下单功能:调用OrderSerive接口中的order方法.
#### Service层:
- 创建order方法.
#### Service层实现类:
>**注意@Service注解是放在实现类上**
- 实现order方法,具体逻辑为:
	 **用户下单:**  
	- 处理业务异常:(地址簿为空, 购物车数据为空)
	- 向订单表插入1条数据;
	- **向明细表插入n条数据;**
	- 清空当前购物车;
	- 构造VO并返回.
```java
    @Override  
    public OrderSubmitVO order(OrdersSubmitDTO ordersSubmitDTO) {  
        Long currentId = BaseContext.getCurrentId();
//        TODO 处理业务异常  
//        地址簿为空  
        Long addressBookId = ordersSubmitDTO.getAddressBookId();  
        AddressBook addressBook = addressBookMapper.getById(addressBookId);  
        if (addressBook == null){  
            throw new AddressBookBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);  
        }  
//        购物车数据为空  
        List<ShoppingCart> shoppingCart = shoppingCartMapper.getById(currentId);  
        if (shoppingCart == null || shoppingCart.size() == 0){  
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);  
        }  
//        TODO 向订单表插入1条数据;  
        Orders order = new Orders();  
        BeanUtils.copyProperties(ordersSubmitDTO,order);  
//        订单号  
        order.setNumber(String.valueOf(System.currentTimeMillis()));  
//        订单状态  
        order.setStatus(Orders.PENDING_PAYMENT);  
//        用户id  
        order.setUserId(currentId);  
//        地址、电话、收货人  
        order.setAddress(addressBook.getDetail());  
        order.setConsignee(addressBook.getConsignee());  
        order.setPhone(addressBook.getPhone());  
        order.setPayStatus(Orders.UN_PAID);  
        order.setOrderTime(LocalDateTime.now());  
  
        orderMapper.insert(order);  
  
//        TODO 向明细表插入n条数据  
        List<OrderDetail> orderDetailList = new ArrayList<>();  
        for (ShoppingCart cart : shoppingCart){  
//            每一个cart代表1种商品,而每个orderDetail也代表一种商品.  
            OrderDetail orderDetail = new OrderDetail();  
            BeanUtils.copyProperties(cart, orderDetail);  
//            orderDetail都有共同的订单id  
            orderDetail.setOrderId(order.getId());  
            orderDetailList.add(orderDetail);  
        }  
  
        orderDetailMapper.insertBatch(orderDetailList);  
  
  
//        TODO 清空当前购物车  
        shoppingCartMapper.deleteById(currentId);  
//        TODO 构造VO并返回.  
        OrderSubmitVO orderSubmitVO = OrderSubmitVO.builder()  
                .orderTime(order.getOrderTime())  
                .orderAmount(order.getAmount())  
                .id(order.getId())  
                .orderNumber(order.getNumber())  
                .build();  
        return orderSubmitVO;  
    }
```

#### Mapper层:
- `orderMapper.insert(order)`:向order表(订单表)中插入订单信息,普通的INSERT方法.
- `orderDetailMapper.insertBatch(orderDetailList)`:向order_detail表中插入订单商品(菜品或套餐,数量多少等..),因为传入的是List集合,**所以需要带上foreach标签来进行批量插入.**

## 订单支付:
### 如何保证数据安全
微信提供的方式就是**对数据进行加密、解密、签名多种方式**。要完成数据加密解密，需要提前准备相应的一些文件，其实就是一些证书。
### 如何调用到商户系统?
微信后台会调用到商户系统给推送支付的结果，在这里我们就会遇到一个问题，就是微信后台怎么就能调用到我们这个商户系统呢？因为这个调用过程，其实本质上也是一个HTTP请求。

目前，商户系统它的ip地址就是当前自己电脑的ip地址，只是一个局域网内的ip地址，微信后台无法调用到。

**解决：内网穿透.** 通过cpolar软件可以获得一个**临时域名**，而这个**临时域名是一个公网ip**，这样，微信后台就可以请求到商户系统了。

完善后, 管理端不再需要临时域名!

# Day10
## SpringTask
### 介绍:
**Spring Task**是Spring框架提供的任务调度工具，可以按照**约定的时间自动执行**某个代码逻辑。
**定位**:定时任务框架
**作用**:定时自动执行某段Java代码
### Cron表达式:
>通过Cron表达式生成器实现,无需自己构造.

**介绍:** 
**cron表达式**其实就是一个字符串，通过cron表达式可以**定义任务触发的时间**
**构成规则**:分为6或7个域，由**空格分隔**开，每个域代表一个含义
每个域的含义分别为：秒、分钟、小时、日、月、周、年(可选)

**举例：**
2022年10月12日上午9点整 对应的cron表达式为：**0 0 9 12 10 ? 2022**
![image-20221218184412491](file:///E:/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/%E8%AE%B2%E4%B9%89/day10/assets/image-20221218184412491.png?lastModify=1725865800)
说明：一般**日和周的值不同时设置**,其中一个设置,另一个用?表示.

**通配符：**
`*`表示所有值；
`?`表示未说明的值，即不关心它为何值；
`-`表示一个指定的范围；
`,`表示附加一个可能值；
`/`符号前表示开始时间，符号后表示每次递增的值；

**cron表达式案例：**
`*/5 * * * * ?` 每隔5秒执行一次
`0 */1 * * * ?` 每隔1分钟执行一次
`0 0 5-15 * * ?` 每天5-15点整点触发
`0 0/3 * * * ?` 每三分钟触发一次
`0 0-5 14 * * ?` 在每天下午2点到下午2:05期间的每1分钟触发
`0 0/5 14 * * ?` 在每天下午2点到下午2:55期间的每5分钟触发
`0 0/5 14,18 * * ?` 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
`0 0/30 9-17 * * ?` 朝九晚五工作时间内每半小时
`0 0 10,14,16 * * ?` 每天上午10点，下午2点，4点
### 使用步骤:
1. 导入spring-text坐标;
2. 启动类上添加@EnableScheduling注解开启任务调度;
3. **自定义定时任务类.**(一般放在task包中,添加@Component注解)
```java
/**
 * 自定义定时任务类
 */
@Component
@Slf4j
public class MyTask {
    /**
     * 定时任务 每隔5秒触发一次
     */
    @Scheduled(cron = "0/5 * * * * ?")
    public void executeTask(){
        log.info("定时任务开始执行：{}",new Date());
    }
}
```
## 订单状态定时处理:
### 需求分析:
对于上面两种情况需要通过**定时任务**来修改订单状态，具体逻辑为：
- 通过定时任务**每分钟检查一次**是否存在支付超时订单（下单后超过15分钟仍未支付则判定为支付超时订单），如果存在则修改订单状态为“已取消”
- 通过定时任务**每天凌晨1点检查一次**是否存在“派送中”的订单，如果存在则修改订单状态为“已完成”
### 代码开发:
1. 创建自定义定时任务类:`com.sky.task.OrderTask`.
	- 添加@Scheduled注解,设置定时任务.
	- 根据需求查询数据库,并更新订单信息.
>**加上了@Component注解,即交给Spring容器管理,故可以使用@AutoWired自动注入.**
```java
@Component  
@Slf4j  
public class OrderTask {  
  
    @Autowired  
    private OrderMapper orderMapper;  
  
    /**  
     * 处理超时订单.  
     *///    @Scheduled(cron = "0 * * * * ? ")   //每分钟触发一次  
    @Scheduled(cron = "*/5 * * * * ?")  
  
    public void processTimeOutOrder(){  
        log.info("定时处理超时订单:{}", LocalDateTime.now());  
//      查询超时订单: 状态为未支付;下单时间距离现在超过15mins  
        List<Orders> orders = orderMapper.getByStatusAndOrderTime(Orders.PENDING_PAYMENT,(LocalDateTime.now().plusMinutes(-15)));  
        if (orders != null && orders.size() > 0) {  
            orders.forEach(order -> {  
//                更新状态  
                order.setStatus(Orders.CANCELLED);  
//                更新取消原因  
                order.setCancelReason("订单超时!");  
//                更新取消时间  
                order.setCancelTime(LocalDateTime.now());  
                orderMapper.update(order);  
            });  
        }  
    }  
  
    /**  
     * 定时处理状态为派送中的订单  
     */  
//    @Scheduled(cron = "0 0 1 * * ?")  
    @Scheduled(cron = "*/5 * * * * ?")  
    public void processDeliveryOrder(){  
        log.info("定时处理派送中订单:{}",LocalDateTime.now());  
  
        List<Orders> orders = orderMapper.getByStatusAndOrderTime(Orders.DELIVERY_IN_PROGRESS, LocalDateTime.now().plusHours(-1));  
        if (orders != null && orders.size() > 0) {  
            orders.forEach(order -> {  
//                更新状态  
                order.setStatus(Orders.COMPLETED);  
                orderMapper.update(order);  
            });  
        }  
    }  
  
}
```

## WebSocket
### 介绍:
WebSocket是**基于TCP**的一种新的**网络协议**。它实现了浏览器与服务器**全双工通信**——浏览器和服务器只需要完成一次握手，两者之间就可以创建**持久性**的连接,并进行**双向**数据传输。

**HTTP协议和WebSocket协议对比：**
- HTTP是**短连接**:每次请求-响应完成后，客户端和服务器之间的TCP连接会**立即关闭**.
- WebSocket是**长连接**
- HTTP通信是**单向**的，基于请求响应模式
- WebSocket支持**双向**通信
- HTTP和WebSocket底层都是TCP连接

**WebSocket缺点：**
服务器长期维护长连接需要一定的成本,各个浏览器支持程度不一,WebSocket是长连接,受网络限制比较大,需要处理好重连.
**结论:** WebSocket并不能完全取代HTTP，它只适合在特定的场景下使用

**应用场景:**
常运用在需要实时更新的网页当中.
### 使用步骤:

**注解介绍:**
`@ServerEndpoint`:用于标注一个WebSocket服务器的端点类,需要指定一个URI(即WebSocket客户端连接的地址).
	`@ServerEndpoint("/ws/chat")`
`@OnOpen`:当有新的WebSocket连接建立时,该方法会被调用.
`@OnMessage`:标注一个方法,当WebSocket接收到消息时触发执行.
`@OnClose`:当WebSocket连接关闭时触发执行.
`@OnError`:当WebSocket通信过程中发生错误时触发执行.

**实现步骤：**
1. 直接使用websocket.html页面作为WebSocket客户端
	**连接WebSocket节点**:`websocket = new Websocket("ws:localhost:8080/ws/" + clientId);`
2. 导入WebSocket的maven坐标
3. 导入WebSocket服务端组件WebSocketServer,**用于和客户端通信(类似于HttpClient)**
4. 导入配置类WebSocketConfiguration,注册WebSocket的服务端组件,即添加@Bean
5. 导入定时任务类WebSocketTask,定时向客户端推送数据
## 来电提醒:
### 需求分析和设计:
**设计思路：**
- 通过WebSocket实现管理端页面和服务端保持长连接状态
- 当客户支付后,调用WebSocket的相关API实现服务端向客户端推送消息
- 客户端浏览器**解析服务端推送的消息**,判断是来单提醒还是客户催单,进行相应的消息提示和语音播报
- 约定服务端发送给客户端浏览器的数据格式为JSON，字段包括:type，orderId，content
    - type为消息类型，1为来单提醒 2为客户催单
    - orderId为订单id
    - content为消息内容

### 代码开发:
来单提醒,即在支付完成后进行提醒,故将代码添加到支付功能`PayNotifyController`中的`paySuccess()`中.
```java
@AutoWired
private WebSocket webSocket;
//创建Map对象,设置传回前端的数据.
Map map = new HashMap();
map.put("type", 1);//消息类型，1表示来单提醒
map.put("orderId", orders.getId());
map.put("content", "订单号：" + outTradeNo);

//通过WebSocket实现来单提醒，向客户端浏览器推送消息
webSocketServer.sendToAllClient(JSON.toJSONString(map));
```

## 客户催单:
### 需求分析和设计:
**接口设计:**
当用户点击催单按钮时,向服务端发送请求.
![[Pasted image 20240909214325.png|300]]
### 代码开发:
在orderServiceImpl中实现该方法:
```java
/**
 * 用户催单
 *
 * @param id
 */
public void reminder(Long id) {
	// 查询订单是否存在
	Orders orders = orderMapper.getById(id);
	if (orders == null) {
		throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
	}

	//基于WebSocket实现催单
	Map map = new HashMap();
	map.put("type", 2);//2代表用户催单
	map.put("orderId", id);
	map.put("content", "订单号：" + orders.getNumber());
	webSocketServer.sendToAllClient(JSON.toJSONString(map));
}
```

# Day11
## ~~Apache ECharts(前端)~~
### 介绍:
Apache ECharts是一款基于 Javascript 的**数据可视化图表库**，提供直观，生动，可交互，可个性化定制的数据可视化图表。
### 使用步骤:
1. 引入echarts.js文件(官网下载)
2. 为ECharts准备一个设置宽高的DOM
3. 初始化echarts实例
4. 指定图表的配置项和数据
5. 使用指定的配置项和数据显示图表

## 营业额统计:
### 需求分析和设计:
**业务规则：**
- 营业额指订单状态为**已完成的订单金额**合计(查询数据库)
- 基于可视化报表的折线图展示营业额数据，X轴为日期，
- 根据时间选择区间，展示每天的营业额数据(限制时间)
**接口设计:**
- 查询类操作->使用GET请求.
- 传入开始时间和结束时间. Query参数,可直接使用,无需加注解.
- 返回参数中code和data均为必须,其中data由dataList和turnoverList构成,故将其封装成`TurnoverReportVO`.
![[Pasted image 20240909220421.png]]
### 代码开发:
#### VO设计:
- 约定返回数据的格式.
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0
    private String turnoverList;

}
```
#### Controller层:
- 创建ReportController,并调用ReportService实现具体业务逻辑.
- 通过`@DataTimeFormat(pattern = "yyyy-MM-dd")`设置参数日期格式.
```java
@RestController
@RequestMapping("/admin/report")
@Slf4j
@Api(tags = "统计报表相关接口")
public class ReportController {

    @Autowired
    private ReportService reportService;

    /**
     * 营业额数据统计
     *
     * @param begin
     * @param end
     * @return
     */
    @GetMapping("/turnoverStatistics")
    @ApiOperation("营业额数据统计")
    public Result<TurnoverReportVO> turnoverStatistics(
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) {
            // 调用service实现具体业务逻辑.
        return Result.success(reportService.getTurnover(begin, end));
    }
}
```

#### Service层:
- dataList存放前端传过来的所有的日期,格式为`2024-09-08,2024-09-09,~`;
- turnoverList用于存放每个日期对应的营业额统计,格式为`299,399,~`;

>[!如何查询orders表中的对应日期的营业额?]
>前端传入的日期格式为LocalDate,只有年月日,而orders订单表中的日期格式为LocalDateTime,包含时分秒.所以这里通过`LocalDateTime.of(date,LocalTime.MIN/MAX)`进行构造,即对应了当天的00:00和23:59:59999.
![[Pasted image 20240909224620.png]]

>[!如何查询数据库?]
使用如下SQL语句:
`SELECT sum(amount) FROM order WHERE order_time > ? AND order_time < ? AND status = ?;`
>因为需要传入三个参数,所以使用Map作为方法参数:`orderMapper.sumByMap(Map map)`.

```java
@Service
@Slf4j
public class ReportServiceImpl implements ReportService {

    @Autowired
    private OrderMapper orderMapper;

    /**
     * 根据时间区间统计营业额
     * @param begin
     * @param end
     * @return
     */
    public TurnoverReportVO getTurnover(LocalDate begin,  LocalDate end) {
        List<LocalDate> dateList = new ArrayList<>();
        dateList.add(begin);
		// 将begin到end的所有日期添加到dataList中.
        while (!begin.equals(end)){
            begin = begin.plusDays(1);//日期计算，获得指定日期后1天的日期
            dateList.add(begin);
        }
        // turnoverList用于存放每天的营业额
// `SELECT sum(amount) FROM order WHERE order_time > ? AND order_time < ?` AND status = 5;
       List<Double> turnoverList = new ArrayList<>();
        for (LocalDate date : dateList) {
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Map map = new HashMap();
        	map.put("status", Orders.COMPLETED);
        	map.put("begin",beginTime);
        	map.put("end", endTime);
            Double turnover = orderMapper.sumByMap(map); 
		// 健壮性保证: 若查询结果为空,则将营业额设为0.
            turnover = turnover == null ? 0.0 : turnover;
            turnoverList.add(turnover);
        }

        //利用Builder实现数据封装
        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList,",")) //将list中的元素取出并用逗号分隔.
                .turnoverList(StringUtils.join(turnoverList,","))
                .build();
    }
}
```

#### Mapper层:
- 大写,小写使用转义字符:&gt,&lt.
```java
/**
 * 根据动态条件统计营业额
 * @param map
 */
Double sumByMap(Map map);

```
```xml
<select id="sumByMap" resultType="java.lang.Double">
        select sum(amount) from orders
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="begin != null">
                and order_time &gt;= #{begin}
            </if>
            <if test="end != null">
                and order_time &lt;= #{end}
            </if>
        </where>
</select>
```
## 用户统计:
### 需求分析和设计:
**需求分析:**
用户统计主要统计**两个数据**,一个是**总的用户数量**,另外一个是**新增用户数量**.

**业务规则：**
- 基于可视化报表的折线图展示用户数据，X轴为日期，Y轴为用户数
- 根据时间选择区间，展示每天的用户总量和新增用户量数据

**接口设计:**
- 查询,使用GET请求;
- 请求参数依旧为开始和结束日期;返回数据data使用UserReportVO进行封装.
![[Pasted image 20240909230444.png]]

### 代码开发:
#### VO设计:
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

}
```

#### Controller层:
与营业额统计的逻辑没区别.
```java
/**
     * 用户数据统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping("/userStatistics")
    @ApiOperation("用户数据统计")
    public Result<UserReportVO> userStatistics(
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end){

        return Result.success(reportService.getUserStatistics(begin,end));            
}
```

#### Service层:
- 与营业额统计的逻辑基本是一样的,但是注意一下查询新增用户的逻辑:即**用户的创建时间是在begin和end之间的.**
	`select count(id) from user where create_time > ? and create_time < ?`
- 查询总用户数量,即用户的创建时间在end之前的.
	`select count(id) from user where  create_time < ?`
```java
@Override
public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) {
	List<LocalDate> dateList = new ArrayList<>();
	dateList.add(begin);

	while (!begin.equals(end)){
		begin = begin.plusDays(1);
		dateList.add(begin);
	}
	List<Integer> newUserList = new ArrayList<>(); //新增用户数
	List<Integer> totalUserList = new ArrayList<>(); //总用户数

	for (LocalDate date : dateList) {
		LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
		LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
		//新增用户数量 select count(id) from user where create_time > ? and create_time < ?
		Integer newUser = getUserCount(beginTime, endTime);
		//总用户数量 select count(id) from user where  create_time < ?
		Integer totalUser = getUserCount(null, endTime);

		newUserList.add(newUser);
		totalUserList.add(totalUser);
	}

	return UserReportVO.builder()
			.dateList(StringUtils.join(dateList,","))
			.newUserList(StringUtils.join(newUserList,","))
			.totalUserList(StringUtils.join(totalUserList,","))
			.build();
}
```
这里还封装了一个`getUserCount`的私有方法,用于调用数据库统计数量,封装相同代码,减少代码冗余.
```java
/**
 * 根据时间区间统计用户数量
 * @param beginTime
 * @param endTime
 * @return
 */
private Integer getUserCount(LocalDateTime beginTime, LocalDateTime endTime) {
	Map map = new HashMap();
	map.put("begin",beginTime);
	map.put("end", endTime);
	return userMapper.countByMap(map);
}
```
#### Mapper层:
```xml
<select id="countByMap" resultType="java.lang.Integer">
	select count(id) from user
	<where>
		<if test="begin != null">
			and create_time &gt;= #{begin}
		</if>
		<if test="end != null">
			and create_time &lt;= #{end}
		</if>
	</where>
</select>
```

## 订单统计:
### 需求分析和设计:
![[Pasted image 20240910013807.png]]
**业务规则：**
- 有效订单指状态为 “已完成” 的订单
- 基于可视化报表的折线图展示订单数据，X轴为日期，Y轴为订单数量
- 根据时间选择区间，展示每天的订单总数和有效订单数
- 展示所选时间区间内的有效订单数、总订单数、订单完成率,订单完成率 = 有效订单数 / 总订单数 * 100%

**接口设计:**
- 参考前面的统计接口.这里根据折线图原型,需要返回3个List+订单总数,有效订单数,订单完成率.
![[Pasted image 20240910013953.png]]
### 代码开发:
#### VO设计:
- 根据返回数据设置相应的属性.
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Integer totalOrderCount;

    //有效订单数
    private Integer validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

}
```

#### Service层:
- 查询有效订单数,即在查询订单总数的基础上加入status的限制(`AND status = ?`),故二者可以使用相同的SQL语句,并使用动态条件(`<if test=""></if>`)
- (有效)订单总数:通过对(有效)订单List进行累加获得,具体可通过Stream流实现.
	- `orderList.stream().reduce(Integer::sum).get()`
		- `.stream()`创建管道;`.reduce()`操作流,将元素求和;`.get()`获取管道操作结果.
- 获取有效订单率时,需要保证分母不为0.
```java
/**
* 根据时间区间统计订单数量
* @param begin 
* @param end
* @return 
*/
public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end){
	List<LocalDate> dateList = new ArrayList<>();
    dateList.add(begin);

    while (!begin.equals(end)){
          begin = begin.plusDays(1);
          dateList.add(begin);
     }
    //每天订单总数集合
     List<Integer> orderCountList = new ArrayList<>();
    //每天有效订单数集合
    List<Integer> validOrderCountList = new ArrayList<>();
    for (LocalDate date : dateList) {
         LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
         LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
   //查询每天的总订单数 select count(id) from orders where order_time > ? and order_time < ?
         Integer orderCount = getOrderCount(beginTime, endTime, null);

  //查询每天的有效订单数 select count(id) from orders where order_time > ? and order_time < ? and status = ?
         Integer validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

         orderCountList.add(orderCount);
         validOrderCountList.add(validOrderCount);
        }

    //时间区间内的总订单数
    Integer totalOrderCount = orderCountList.stream().reduce(Integer::sum).get();
    //时间区间内的总有效订单数
    Integer validOrderCount = validOrderCountList.stream().reduce(Integer::sum).get();
    //订单完成率
    Double orderCompletionRate = 0.0;
    if(totalOrderCount != 0){
         orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
     }
    return OrderReportVO.builder()
                .dateList(StringUtils.join(dateList, ","))
                .orderCountList(StringUtils.join(orderCountList, ","))
                .validOrderCountList(StringUtils.join(validOrderCountList, ","))
                .totalOrderCount(totalOrderCount)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .build();
    
}
```
## 销量排名统计:
### 需求分析和设计:
**业务规则：**
- 根据时间选择区间，展示**销量前10的商品**（包括菜品和套餐）
- 基于可视化报表的柱状图降序展示商品销量
**接口设计:**
![[Pasted image 20240910201447.png]]
### 代码开发:
#### VO设计:
```java
public class SalesTop10ReportVO implements Serializable {

    //商品名称列表，以逗号分隔，例如：鱼香肉丝,宫保鸡丁,水煮鱼
    private String nameList;

    //销量列表，以逗号分隔，例如：260,215,200
    private String numberList;

}
```
#### Service层:
使用`List<GoodsSalesDTO>`接收结果: 用List存储每一天的查询结果,即每一个查询结果封装成DTO,而每一天都对应一个DTO,用List进行接收.
```java
/**
 * 查询指定时间区间内的销量排名top10
 * @param begin
 * @param end
 * @return
 * */
public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end){
	LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
	LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);
	//使用List<GoodsSalesDTO>接收结果:
	List<GoodsSalesDTO> goodsSalesDTOList = orderMapper.getSalesTop10(beginTime, endTime);
	// 将List集合转换为String类型返回(具体看接口设计)
	String nameList = StringUtils.join(goodsSalesDTOList.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList()),",");
	String numberList = StringUtils.join(goodsSalesDTOList.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList()),",");

	return SalesTop10ReportVO.builder()
			.nameList(nameList)
			.numberList(numberList)
			.build();
}
```
#### Mapper层:
- 查询数据库,要求查出销量排名前10的菜品,即查询:1)订单状态为已完成(`status=5`),且status只在orders表中有,故需联表查询; 2)对菜品/套餐数量进行累加,统计总销量(`sum(od.number)`); 3)查询前10名,即根据总销量排名,并降序排列取前10.
```xml
<select id="getSalesTop10" resultType="com.sky.dto.GoodsSalesDTO">
	select od.name name,sum(od.number) number from order_detail od ,orders o
	where od.order_id = o.id
		and o.status = 5
		<if test="begin != null">
			and order_time &gt;= #{begin}
		</if>
		<if test="end != null">
			and order_time &lt;= #{end}
		</if>
	group by name
	order by number desc
	limit 0, 10
</select>
```
#### DTO设计:
- 查询结果为name,numberList,故可以设计一个DTO用来接收数据.
```java
public class GoodsSalesDTO implements Serializable {  
    //商品名称  
    private String name;  
  
    //销量  
    private Integer number;  
}
```

# Day12:
## 工作台:
### 需求分析和设计:
- 根据工作台展示数据内容,划分区域,对应不同接口,减少程序复杂性和耦合度.
![[Pasted image 20240910214913.png]]

### 代码开发:
#### Serivce层:
- 每个方法分别对应不同接口,每个接口根据返回数据设置不同的VO.
- **今日数据接口:**
	- 总订单数: 查询所有订单, status为null.
	- 有效订单数: status为已完成的订单数.
	- 订单完成率: 上述二者作除.
	- 查询营业额: status为已完成的订单的金额总和.
	- 平均客单价: 作除.
	- 新增用户: 查询创建时间在begin和end之间的用户.
- **订单管理接口:** 查询order表->OrderMapper.
  ![[Pasted image 20240910220931.png|400]]
	- 待接单: status为待确认.
	- 待派送: status为待派送.
	- 已完成: ~
	- 已取消: ~
	- 全部订单: status为null,也可以计算上述总和.
- **菜品总览接口:**
	- 查询dish表->DishMapper,分别查询出status为1和0(启售和停售)的菜品.
- **套餐总览接口:**
	- 查询order表->OrderMapper,分别查询出status为1和0(启售和停售)的套餐.
- 
```java
@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService {

    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) {
        /**
         * 营业额：当日已完成订单的总金额
         * 有效订单：当日已完成订单的数量
         * 订单完成率：有效订单数 / 总订单数
         * 平均客单价：营业额 / 有效订单数
         * 新增用户：当日新增用户的数量
         */

        Map map = new HashMap();
        map.put("begin",begin);
        map.put("end",end);

        //查询总订单数
        Integer totalOrderCount = orderMapper.countByMap(map);

        map.put("status", Orders.COMPLETED);
        //营业额
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null? 0.0 : turnover;

        //有效订单数
        Integer validOrderCount = orderMapper.countByMap(map);

        Double unitPrice = 0.0;

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0 && validOrderCount != 0){
            //订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
            //平均客单价
            unitPrice = turnover / validOrderCount;
        }

        //新增用户数
        Integer newUsers = userMapper.countByMap(map);

        return BusinessDataVO.builder()
                .turnover(turnover)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .unitPrice(unitPrice)
                .newUsers(newUsers)
                .build();
    }


    /**
     * 查询订单管理数据
     *
     * @return
     */
    public OrderOverViewVO getOrderOverView() {
        Map map = new HashMap();
        map.put("begin", LocalDateTime.now().with(LocalTime.MIN));
        map.put("status", Orders.TO_BE_CONFIRMED);

        //待接单
        Integer waitingOrders = orderMapper.countByMap(map);

        //待派送
        map.put("status", Orders.CONFIRMED);
        Integer deliveredOrders = orderMapper.countByMap(map);

        //已完成
        map.put("status", Orders.COMPLETED);
        Integer completedOrders = orderMapper.countByMap(map);

        //已取消
        map.put("status", Orders.CANCELLED);
        Integer cancelledOrders = orderMapper.countByMap(map);

        //全部订单
        map.put("status", null);
        Integer allOrders = orderMapper.countByMap(map);

        return OrderOverViewVO.builder()
                .waitingOrders(waitingOrders)
                .deliveredOrders(deliveredOrders)
                .completedOrders(completedOrders)
                .cancelledOrders(cancelledOrders)
                .allOrders(allOrders)
                .build();
    }

    /**
     * 查询菜品总览
     *
     * @return
     */
    public DishOverViewVO getDishOverView() {
        Map map = new HashMap();
        map.put("status", StatusConstant.ENABLE);
        Integer sold = dishMapper.countByMap(map);

        map.put("status", StatusConstant.DISABLE);
        Integer discontinued = dishMapper.countByMap(map);

        return DishOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    }

    /**
     * 查询套餐总览
     *
     * @return
     */
    public SetmealOverViewVO getSetmealOverView() {
        Map map = new HashMap();
        map.put("status", StatusConstant.ENABLE);
        Integer sold = setmealMapper.countByMap(map);

        map.put("status", StatusConstant.DISABLE);
        Integer discontinued = setmealMapper.countByMap(map);

        return SetmealOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    }
}
```
#### Mapper层:
**SetmealMapper:** 添加countByMap方法.根据传入的不同status进行查询,适用性更强.
```java
<select id="countByMap" resultType="java.lang.Integer">
        select count(id) from setmeal
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="categoryId != null">
                and category_id = #{categoryId}
            </if>
        </where>
</select>
```
**DishMapper:** 
```java
<select id="countByMap" resultType="java.lang.Integer">
        select count(id) from dish
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="categoryId != null">
                and category_id = #{categoryId}
            </if>
        </where>
</select>
```


## Apache POI:
### 介绍:
- Apache POI是一个**处理Miscrosoft Office各种文件格式**的开源项目. 简单来说就是,我们可以使用POI在Java程序中对Miscrosoft Office各种文件进行**读写操作**. 一般情况下,POI 都是用于操作Excel文件。
### 使用步骤:
#### 读操作:
1. 获取excel对象: `new XSSFWorkbook(FileInputStream)`;
2. 获取sheet对象: `excel.getSheetAt(int index)`
3. 获取行: `sheet.getRow(int index)`
4. 获取单元格: `row.getCell(int index)`
5. 获取单元格内文本内容: `cell.getStringValue()`
```java
public class POITest {
    /**
     * 基于POI读取Excel文件
     * @throws Exception
     */
    public static void read() throws Exception{
        FileInputStream in = new FileInputStream(new File("D:\\itcast.xlsx"));
        //通过输入流读取指定的Excel文件
        XSSFWorkbook excel = new XSSFWorkbook(in);
        //获取Excel文件的第1个Sheet页
        XSSFSheet sheet = excel.getSheetAt(0);

        //获取Sheet页中的最后一行的行号
        int lastRowNum = sheet.getLastRowNum();

        for (int i = 0; i <= lastRowNum; i++) {
            //获取Sheet页中的行
            XSSFRow titleRow = sheet.getRow(i);
            //获取行的第2个单元格
            XSSFCell cell1 = titleRow.getCell(1);
            //获取单元格中的文本内容
            String cellValue1 = cell1.getStringCellValue();
            //获取行的第3个单元格
            XSSFCell cell2 = titleRow.getCell(2);
            //获取单元格中的文本内容
            String cellValue2 = cell2.getStringCellValue();

            System.out.println(cellValue1 + " " +cellValue2);
        }

        //关闭资源
        in.close();
        excel.close();
    }

    public static void main(String[] args) throws Exception {
        read();
    }
}
```
#### 写操作:
1. 创建excel对象: `new XSSFWorkbook()`;
2. 创建sheet对象: `excel.createSheet(String sheetName)`
3. 创建行: `sheet.createRow(int index)`
4. 创建单元格: `row.createCell(int index)`
5. 设置单元格内文本内容: `cell.setCellValue(String value)`
```java
public class POITest {

    /**
     * 基于POI向Excel文件写入数据
     * @throws Exception
     */
    public static void write() throws Exception{
        //在内存中创建一个Excel文件对象
        XSSFWorkbook excel = new XSSFWorkbook();
        //创建Sheet页
        XSSFSheet sheet = excel.createSheet("itcast");

        //在Sheet页中创建行，0表示第1行
        XSSFRow row1 = sheet.createRow(0);
        //创建单元格并在单元格中设置值，单元格编号也是从0开始，1表示第2个单元格
        row1.createCell(1).setCellValue("姓名");
        row1.createCell(2).setCellValue("城市");

        XSSFRow row2 = sheet.createRow(1);
        row2.createCell(1).setCellValue("张三");
        row2.createCell(2).setCellValue("北京");

        XSSFRow row3 = sheet.createRow(2);
        row3.createCell(1).setCellValue("李四");
        row3.createCell(2).setCellValue("上海");

        FileOutputStream out = new FileOutputStream(new File("D:\\itcast.xlsx"));
        //通过输出流将内存中的Excel文件写入到磁盘上
        excel.write(out);

        //关闭资源
        out.flush();
        out.close();
        excel.close();
    }
    public static void main(String[] args) throws Exception {
        write();
    }
}
```
## 导出Excel数据报表:
### 需求分析和设计:
在数据统计页面，有一个**数据导出的按钮**，点击该按钮时，其实就会下载一个文件。这个文件实际上是一个Excel形式的文件，文件中主要**包含最近30日运营相关的数据**。表格的形式已经固定，主要由**概览数据和明细数据两部分组成**。真正导出这个报表之后，相对应的数字就会填充在表格中，就可以进行存档。

**业务规则：**
- 导出Excel形式的报表文件
- 导出最近30天的运营数据

**接口设计:**
![[Pasted image 20240910231328.png|150]]
**注意：**
- 当前接口没有传递参数，因为导出的是最近30天的运营数据，后端计算即可，所以不需要任何参数
- 当前接口没有返回数据，因为报表导出功能本质上是文件下载，服务端会通过输出流将Excel文件下载到客户端浏览器.
### 代码开发:
#### 3.2.1 实现步骤
1. 设计Excel模板文件: 在程序外操作,设计模板文件并读取.
2. 查询近30天的运营数据
3. 将查询到的运营数据写入模板文件
4. 通过输出流将Excel文件下载到客户端浏览器