**水产：**
- 水产使用Topic：`tms.tsc.waybill.bind.allot.notify`
- 水产Msg添加：①变更场景：运单绑定调拨单、波次变更；②波次变更前数据。

**非水产：**
- 非水产使用Topic：`tms.tws.waybill.deliveryTag.notify`
- 非水产Msg添加：①波次变更前数据；②对应配送单列表（附带仓ID）→ 查询tes中的distribution_order表。

**理解：**
- 水产、非水产仅针对消息体进行改造，新增内容；
- 非水产需要结合配送单列表，因此需要与tes进行交互，调用tes的api查询配送单。
### 需求背景
DCC需要感知运单的波次变化，以进一步同步给库存侧，库存侧对应调整在途售卖运单。
> **在途售卖**：指的是商品售罄后，通过运单来提醒用户商品下一次到达时间。

1、变化原因：手工误操作后续改回正确波次标签、调度为了准点率考核打下一个波次标签  
2、变化时机：误操作部分发运后或到站签收复盘改回，准点考核部分运单完结后变更

![[Pasted image 20250806145955.png|450]]
复用BindAllot这个Topic发送水产调拨单信息。由于非水产不与调拨单绑定，并且需要发送配送单信息，因此新增一个Topic用于发送非水产变更通知。

#### 判断是否是水产订单逻辑：

1. 查询单个运单是否是水产运单：
```
GetDistributionDepartmentDetailResponse response = tosGateway.getDistributionDepartmentDetail(WaybillConstant.TENANT_ID, waybill.getPoiId());
response.getDistributionDepartment().getSupportAquaticMode() ==  SupportAquaticMode.SUPPORT_AQUATIC.getValue()
```
2. 
```
    public List<WaybillPO> filterAquaticWaybill(List<WaybillPO> waybillPOList) {
        if (CollectionUtils.isEmpty(waybillPOList)) {
            return Lists.newArrayList();
        }
        // 获取水产配送部id
        List<DistributionDepartmentDTO> distributionDepartmentList = tosGateway.getDistributionDepartmentList();
        Set<Long> aquaticDistributionDepartmentIdSet = distributionDepartmentList.stream()
                .filter(distributionDepartmentDTO -> distributionDepartmentDTO.getSupportAquaticMode() == SupportAquaticMode.SUPPORT_AQUATIC.getValue())
                .map(DistributionDepartmentDTO::getDistributionDepartmentId)
                .collect(Collectors.toSet());

        return waybillPOList.stream()
                .filter(e -> aquaticDistributionDepartmentIdSet.contains(e.getPoiId()) && Objects.equals(e.getType(), WaybillType.TEMPORARY.getValue()))
                .collect(Collectors.toList());
    }
```
BindAllotMsg
- 调拨单绑定：不能使用「运单号-波次标签」，否则会被错误幂等。并且
- 波次变更：使用「运单号-波次标签」，可以。因为只关心最终的变更后波次。

DeliveryTagMsg：
- 波次变更：使用
这里的重复发送要注意区分：
1. Mafka自带的重试机制，例如服务端出问题了，可能导致消息发送后未收到ACK确认，而再次发送一次消息。这时候消息的内容是一致的，即使使用了UUID。
2. 在某些边界情况，例如用户点击了一次接口，前端发起了两次请求，这样就会导致重复发送了消息，而此时UUID就会不一致。

![[Pasted image 20250806150239.png|500]]

### 为什么要传变更类型？

deliveryTagMsg中是传了变更类型：1. 新建运单；2. 修改运单的，目的是为了什么呢？

1. 新建运单的时候，originDeliveryTag是为空的，为了方便DCC侧进行校验；
### 为什么要传运输类型？

运输类型区分为「订单运输」、「店群调拨」等，而DCC侧只关心订单运输类型，并且「店群调拨」类型的运单是不存在对应的配送单信息的。

### DCC侧数据要求

DCC关心的是更新运单，
![[Pasted image 20250806150319.png|600]]
### 是否会出现调拨单为空的情况？

目前查询调拨单的情况：

1. 新建运单时，且运单是水产运单；
2. 接收sku货量场景；

新增：
- 新建、更新运单时，会接收DeliveryTag的消息。此时若为水产运单，则会再发送一次BindAllotMsg给水产运单；
- 新建水产运单时，一个是会发送DeliveryTag给TSC，同时TSC也会监听到水产运单创建的binlog，因此此时会发送两次BindAllotMsg给DCC。但是两个Msg对应的场景以及运单ID是不同的。
DCC侧只关心发运之后的波次变更消息。
  
注意，新建运单后不一定绑定了调拨单，因此此时查询调拨单是会为空的。

调拨单下发时，此时会新建线路，线路中会有对应的运单号，但是此时并不代表运单已经创建了！因此查询waybill表会查询出不到运单列表。

### 如何判断是否为新建运单？

目前我的判断逻辑是根据是否能查到ext信息，但发现对于有些正向运输订单（可能是历史遗留）、退货订单（确认现在也有），我的这个逻辑是由问题的，因为已发运运单，也会有查不到ext的情况。那么还有什么判断是否是新建运单的方法呢？根据waybill是否存在？

后续发现，实质上waybill表中就有运单状态，会标明是新建运单。并且默认设置值就是“0”，因此直接基于status字段进行判断即可。

### DeliveryTag的值出错问题

测试时发现TSC发送的BindAllotMsg出现了变更后波次信息与变更前波次信息一致的问题。定位问题，发现是自己的逻辑有问题！因为我们是①先获取了vehicleRoutes；②更新vehicleRoutes的值。原有代码逻辑直接调用了vehicleRoute中的DeliveryTag来构建待发送的消息！这里从两个方面来说都是有问题的：
1. vehicleRoutes的值取出来后，即使后面进行更新了，但在方法中的这个vehicleRoutes对象的值仍旧是不会改变的！
2. 即使再次从数据库中获取vehicleRoutes对象，值也依旧不会改变。因为方法有事务，在方法结束前，数据是不会落库的。
### build方法重构

发现build方法中使用vehicleRoutes的场景只有两个：①设置waybillCode；②设置DeliveryTag。于是打算直接重构

## 测试场景梳理

#### 1. 新建水产运单

期望发送BindAllot消息；

#### 2. 新建非水产运单

期望发送DeliveryTag消息和BindAllot消息；

#### 3. 更新水产运单

期望发送BindAllot

1. 更新水产、非水产波次标签；



### 是否会出现调拨单为空的情况？

目前查询调拨单的情况：

1. 新建运单时，且运单是水产运单；
2. 接收sku货量场景；
    

新增：
- 新建、更新运单时，会接收DeliveryTag的消息。此时若为水产运单，则会再发送一次BindAllotMsg给水产运单；
- 新建水产运单时，一个是会发送DeliveryTag给TSC，同时TSC也会监听到水产运单创建的binlog，因此此时会发送两次BindAllotMsg给DCC。但是两个Msg对应的场景以及运单ID是不同的。

DCC侧只关心发运之后的波次变更消息。

注意，新建运单后不一定绑定了调拨单，因此此时查询调拨单是会为空的。

调拨单下发时，此时会新建线路，线路中会有对应的运单号，但是此时并不代表运单已经创建了！因此查询waybill表会查询出不到运单列表。

### 如何判断是否为新建运单？

目前我的判断逻辑是根据是否能查到ext信息，但发现对于有些正向运输订单（可能是历史遗留）、退货订单（确认现在也有），我的这个逻辑是由问题的，因为已发运运单，也会有查不到ext的情况。那么还有什么判断是否是新建运单的方法呢？根据waybill是否存在？

后续发现，实质上waybill表中就有运单状态，会标明是新建运单。并且默认设置值就是“0”，因此直接基于status字段进行判断即可。

### DeliveryTag的值出错问题

测试时发现TSC发送的BindAllotMsg出现了变更后波次信息与变更前波次信息一致的问题。定位问题，发现是自己的逻辑有问题！因为我们是①先获取了vehicleRoutes；②更新vehicleRoutes的值。原有代码逻辑直接调用了vehicleRoute中的DeliveryTag来构建待发送的消息！这里从两个方面来说都是有问题的：

1. vehicleRoutes的值取出来后，即使后面进行更新了，但在方法中的这个vehicleRoutes对象的值仍旧是不会改变的！
    
2. 即使再次从数据库中获取vehicleRoutes对象，值也依旧不会改变。因为方法有事务，在方法结束前，数据是不会落库的。