
## MySQL设计思想：
1. 如果内存足够，就多利用内存，尽量减少磁盘IO.

## 01 | 一条SQL查询语句是如何执行的？
![[Pasted image 20250128222043.png|300]]
MySQL分为Sever层和存储引擎层。
- Server层包括连接器、缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎层负责数据的存储和提取，其架构是**插拔式**的，支持InnoDB、MyISAM、Memory等。
#### 连接器
连接器负责跟客户端的连接，获取权限、维持和管理连接。
- 客户端与连接器是通过TCP握手来建立连接的。
- 如果用户密码认证通过，连接器会到权限表中查出已拥有的权限，并在之后的权限判断中都依赖于此时获取的权限。即，若管理员对某用户的权限进行了修改，**也不会影响已经存在连接的权限**。

#### 缓存
执行查询请求时，会先到缓存中查看是否存在该缓存，若存在，则直接返回结果；若不存在，则会在执行完查询语句后将结果存储在缓存中。
- 缓存以KEY-VALUE的形式存储，KEY为查询语句，VALUE为查询结果。
- 缓存层的利大于弊：
	- 因为缓存失效非常频繁，**只要有对一个表的更新，那么该表上的所有查询缓存都会被清空！**
	- 查询缓存的维护需要全局锁
#### 分析器
分析器会对SQL语句做“词法分析”和“语法分析”。
- **词法分析**：分析器识别出每个字符串是什么，代表什么，例如识别出SELECT为查询语句、识别出T为表名等；
- **语法分析**：根据词法分析的结果，分析器会根据语法规则判断输入的SQL语句是否符合MySQL语法。

例如`elect * from t where ID=1;`就会被分析器识别出语法错误，报错：
`ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1`
#### 优化器
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。不同执行方案的执行结果相同，效率不同，而优化器就是负责选择哪个方案的执行效率更高！
#### 执行器
执行器，负责开始执行语句。

开始执行时，需要先判断对表T是否有执行查询的权限，如果没有，就会返回没有权限的错误：`ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'`

>[!abstract]- 权限校验
>1. 在命中查询缓存，会在**查询缓存返回结果的时候**做权限校验；
>2. **优化器执行前**会调用precheck验证权限。
>3. **开始执行前**，会判断对待查询的表是否有执行查询的权限。

**执行器的执行流程：（无索引）**
1. 调用执行引擎接口取表的第一行，判断是否满足条件，不满足则跳过，满足则将结果存在结果集中；
2. 调用引擎接口取下一行，执行相同的判断逻辑，直至取最后一行；
3. 执行器反复调用引擎接口，直至遍历所有行，将符合结果的结果集返回给客户端。

### 提问
>`如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？`

分析器，因为分析器在分析阶段会判断语句是否正确，表是否正确、列是否存在等。

## 02 | 一条SQL更新语句是如何执行的?
## 08 | 事务的隔离


## 12 | MySQL为什么会“抖”一下?
为了保证读写效率，MySQL不是每一次写数据都会更新到磁盘中，而是先记录在内存中的redo log中。此时，磁盘中的数据和内存中的数据并不一致，称为脏页。在某些时刻，系统会停止所有更新操作，根据redo log中记录的日志信息，更新磁盘中的操作，称为刷脏页。


#### 场景一：redo log写满
redo log是有内存限制的，当记录日志过多时，此时write position接近于checkpoint，剩余空间不足了，此时需要进行一次刷脏页操作，将redo log中的checkpoint向前推进，以留出空间继续写。

此时对性能影响最大，因为在刷脏页过程中，整个系统不再接受更新。

redo log的大小是可以设置的，若设置的太小，则更新记录会很快占满内存，导致系统需要停止所有更新，进行刷脏页，更新checkpoint，导致磁盘压力很小(因为每次写入的数据都很少，低于磁盘IOPS)，数据库间歇性地性能下降。
#### 场景二：内存满了
此时是内存满了，当需要淘汰的是脏页时，就会触发先将脏页刷(flush)到磁盘中。

缓冲池中的内存页存在三种情况：1）未使用的内存页；2）使用了且是干净的；3）使用了且是脏页。当要读入的数据不在内存页中时，就必须到缓冲池申请一个内存页，当是情况1时，就直接申请；当是情况2时，就直接释放并复用；当是情况3时，就需要先刷脏页到磁盘中，变成干净页后才能复用。

#### 场景三：
此时是MySQL判断此时是属于“空闲时刻”，就会触发刷脏页。

#### 场景四：
此时MySQL正常关闭，需要先将内存中的脏页都刷到磁盘中才能关闭。下次MySQL启动时，直接从磁盘中读取数据。

### InnoDB的刷脏页策略
InnoDB的刷脏页能力与系统磁盘的IO能力息息相关，建议通过设置参数`innodb_io_capacity`为磁盘的IOPS。磁盘的IOPS可通过fio工具进行测试，测试语句为：
```bash
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```

InnoDB刷脏页时，还会有连坐机制：
假设某个查询需要的数据内存中没有，此时就可能需要淘汰内存页、刷脏页，此时若旁边的数据页也是脏页，则会将此邻居也一同刷掉。若连带脏页的邻居也是脏页，则也会一并刷掉，直到旁边的数据页是干净页。

### 总结
利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。
- 写Redo log，只需要进行将更新记录写入日志这一个磁盘操作即可，是顺序写；而如果需要更新磁盘中的具体数据，就需要进行随机写，因为要涉及到**磁盘寻址**操作。

## 13 | 表数据删除一半，为什么表文件大小不变?
InnoDB表包含两部分：表结构定义和表数据。在MySQL8.0以后，已经支持将表结构定义放到系统数据表中。**系统数据表，主要用于存储MySQL的系统数据，比如：数据字典、undo log(默认)等文件**

### 参数 innodb_file_per_table
>**控制表数据是否存放到共享空间中.**

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：
- 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
- 这个参数设置为ON表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。

建议设置为ON，一个表单独存储在一个.ibd表文件中，在需要删除表时就会将该文件删除，直接释放空间；而若将表数据存储在共享空间中，此时即使drop table，空间也不会回收。

## 数据删除流程


## 14 | count(\*)为什么这么慢，如何解决?

### count(\*)的实现方式
不同引擎的实现方式不同：
- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\*)的时候会直接返回这个数，效率很高；
- 而 InnoDB 引擎就麻烦了，它执行 count(\*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数，因此效率很低！

InnoDB采用此方法计算行数的原因是MVCC，解释如下：
![[Pasted image 20241111230420.png]]
InnoDB的默认事务隔离级别为可重复读，因此会在select count(\*) from t时创建read view,所以会话A返回的行数为10000；而会话B此时在查询前又插入了一条数据，由于当前读，所以会创建一个新视图，包含会话C插入的数据，所以会话B最后返回的是10002；而会话C此时看不到会话B插入的数据，只能看到自己插入的数据，所以返回的是10001；

InnoDB对此进行了优化，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键，所以普通索引树会比主键索引树小很多，因此MySQL优化器会选择最小的树进行遍历。

### 解决办法:
#### 方法一:使用缓存计数
使用Redis保存表的总行数，此时读写速度都很快。但是缓存系统可能丢失更新，导致数据不准确！
假设插入了新数据，但是Redis还没有来得及计数就异常重启了，此时就可能导致计数操作丢失。解决办法是在重启后进行一次count(\*)全表扫描获取真实行数。

**使用缓存计数最大的问题在于不精确。**

考虑以下2种情况：
	1. 此时数据已经插入，但是Redis还未更新。
	![[Pasted image 20241111232726.png|450]]
	2. 此时数据已经插入，但是Redis技术还未更新。
	   ![[Pasted image 20241111233019.png|450]]

把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因，是**这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。**
#### 方法二:在数据库保存计数
将计数直接放在数据库单独的一张计数表C中进行存储。

可以通过**添加事务来保证在数据插入前对其他线程不可见**。这里将更新计数表C放在插入数据后，是因为更新计数表涉及到同一行数据的操作，会加行锁；而插入数据是对不同行的操作，不会加行锁，因此先更新计数表能尽可能的减少阻塞。
![[Pasted image 20241112001927.png|450]]

##### 不同count语句的差别:
count语句性能分析原则：
- server 层要什么就给什么；
- InnoDB 只给必要的值；
- 现在的优化器只优化了 count(\*) 的语义为“取行数”，其他“显而易见”的优化并没有做。

**count(主键id)**：InnoDB 引擎会遍历整张表，**把每一行的 id 值都取出来**，返回给server 层。server 层拿到 id 后，判断是不可能为空的(主键不能为null)，就按行累加。

**count(1)**：InnoDB 引擎遍历整张表，**但不取值**。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

>count(1) 执行得要比 count(主键 id) 快。**因为从引擎返回id给server层会涉及到解析数据行，以及拷贝字段值的操作。**

**count(字段)**：
1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，**还要把值取出来再判断一下**，不是 null 才累加。

**count(\*)**：并不会将所有字段取出，MySQL对此进行了优化，不会取值。count(\*)肯定不是null，直接按行累加。

所以，执行效率上，**count(字段)<count(主键 id)<count(1)≈count(\*)**


## 16 | Order By是如何工作的?

这个语句执行流程如下所示 ：
1. 初始化 sort_buffer，确定放入 name、city、age 这三个字段；
2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
3. 到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
4. 从索引 city 取下一个记录的主键 id；
5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；
6. 对 sort_buffer 中的数据按照字段 name 做快速排序；
7. 按照排序结果取前 1000 行返回给客户端。


## 17 | 如何正确显示随机消息?
### 方法1: 内存临时表

### 方法2: 随机排序算法


## 21 | 为什么我只改一行的语句，锁这么多？

