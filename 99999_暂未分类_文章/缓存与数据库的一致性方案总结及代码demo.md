大致有三种：
1. 先更新数据库，再删除缓存。
2. 延迟双删：（先删缓存，再更新数据库，最后再删缓存）。
3. Cache-Aside：基于binlog监听实现缓存的更新或删除。

### 方案一：先更新，后删除（Cache-Aside | 旁路验证）
数据要更新时，先更新数据库中的数据，然后再删除缓存。下一次查询时缓存判空，会去数据库读取数据，然后写入缓存。至此，保证了缓存与数据库的一致性。
#### 存在的问题
##### ~~1. 脏数据~~
只要是非原子性的操作，都有可能引发并发问题。在更新后、删除前，可能会有线程读取到缓存中的脏数据。
![[Pasted image 20250228172450.png]]
##### 2. 缓存击穿
在删除缓存之后，只要等下一个线程出现cache miss后才会写缓存。因此，在这之间，若该KEY有大量请求过来，就会导致数据库压力过大，也就是缓存击穿问题。不过，可通过加锁解决：第一个读请求到来时，发现缓存未命中，则加锁并读取数据库、更新缓存，缓存更新后才释放锁，这样之后的线程就可以读取到缓存了。
##### 3. 不一致问题
即使是先更新，后删除，也仍会出现不一致问题。具体如下：
- 要求很严格，要满足①线程B读取时缓存不存在；②线程A的「先更新、后删除」操作要在线程B的「读取并重写缓存」之间。因此，发生的概率很低。
![[Pasted image 20250301000946.png]]
##### 4. 删除缓存操作失败
先更新数据库，后删除缓存，若更新数据库成功，而缓存删除失败，也会导致缓存与数据库的不一致问题。不过①删除缓存操作的失败概率低；②数据库作为持久层，已有最新值，可以基于此重新删除缓存。

#### 为什么不是更新缓存，而是删除缓存？
首先，更新操作是需要查询、更新、然后再写入，是三步非原子性的操作！并且可能缓存中存取的数据是一个大的JSON串等类型，因此可能**需要反序列化、解析出其中的某个字段并、修改该字段的数据、再序列化、最后再更新到缓存**。因此，相比于直接删除缓存，**更新缓存是一个操作很复杂的过程，开销、耗时也更长**，因此也会导致数据不一致的概率增大。

更新缓存可能会因为写写并发的问题导致数据不一致。如下，最终导致了数据库中的数据为10，而缓存中的数据为20！
![[Pasted image 20250301001607.png]]
#### 为什么不是先删除缓存，再更新数据库？
更容易出现数据不一致问题！因为是先删除缓存，因此后续的读请求就会`cache miss`，就可能将数据库的旧值重写到缓存中。
![[Pasted image 20250301003948.png]]

## 方案二：延迟双删
先删缓存，再更新数据库，可能会因为`cache miss`导致数据不一致问题，并且这种不一致会持续存在。要想解决这种问题，可以再更新完数据库后再删一次缓存，也就是延迟双删，这样就能避免线程B在线程A更新最新数据到数据库后再写入缓存的旧值删掉。

#### 为什么先删缓存，再更新数据库？
- 若先更新数据库，再删除缓存，那就变为了方案一，此时删除缓存若失败会导致数据不一致问题。
- 归根结底，两次删除就是为了降低数据不一致的发生概率！若无第一次删除，则并发读、删除失败都会导致数据不一致；若无第二次，则会因操作失败导致数据不一致。
#### 为什么需要再删除一次？
见\[[[#为什么不是先删除缓存，再更新数据库？]]]。因此为了删除缓存后的读操作重写缓存为旧值，我们需要在数据库更新成功后，延迟一段时间后，再将缓存中的值删掉！
#### 为什么需要延迟一段时间？
因为`cache miss`后的重写缓存操作，即可能发生在更新数据库前，也可能发生在更新数据库后，因此为了保证能成功删除，需要延迟一段时间（相当于等缓存重新写入）再删除，一般建议设置1~2秒即可。
## 方案三：Cache-Aside，基于Binlog监听进行缓存删除
与方案一的思路一致，先更新数据库，再删除缓存。通过binlog的监听重试机制，保证删除缓存操作的成功！具体逻辑：
1. 先删除数据库，删除成功后，发送异步消息；
2. 监听者/消费者收到消息后，**异步**将缓存中的数据删除掉。
	- 或是借助MySQL的binlog，订阅数据库变更后，异步清除缓存。

>注意：基于Binlog监听机制的异步删除，会有一定延时，通常在毫秒级别，一般用于可接受秒级延迟的场景。

#### 为什么可以不做延迟双删？
因为我们认为基于binlog的监听是相对可靠的，监听后可以通过不断重试保证缓存能被删除成功。

## 如何选择适合的方案？
- 并发量不大的情况下，直接选择先更新数据库、再删除缓存即可。
- 若并发量较大，可以选择基于Binlog监听的Cache-Aisde方案，或是延迟双删。