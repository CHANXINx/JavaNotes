
## 1. 讲讲OSI七层模型。
1. 物理层（Physical Layer）：主要规定传输介质的传输方式，包括电信号、电压、光脉冲等。该层的主要协议是物理媒介相关协议，如RS232、V.35、以太网等。  
2. 数据链路层（Data Link Layer）：在物理层上建立数据链路，对数据进行分帧、差错校验等处理，确保数据可靠地传输。该层的主要协议有点对点协议PPP（Point-to-Point Protocol）、高级数据链路控制协议HDLC（High-Level Data Link Control）、以太网协议等。  
3. 网络层（Network Layer）：主要解决数据在网络中的传输问题，包括寻址、路由选择等。该层的主要协议有IP协议、网关协议（ARP）、路由协议（RIP、OSPF、BGP等）等。  
4. 传输层（Transport Layer）：提供端到端的可靠传输服务，包括数据传输控制、流量控制等。该层的主要协议有TCP协议、UDP协议、SCTP协议等。  
5. 会话层（Session Layer）：提供会话管理功能，负责建立、维护和结束会话。该层主要实现了不同计算机之间的会话控制，为高层协议提供一个传输数据的会话环境，该层的主要协议有NetBIOS等。  
6. 表示层（Presentation Layer）：负责数据格式的转换，确保应用层数据的格式一致。该层主要实现了数据格式的转换和数据加密解密等功能，如JPEG、MPEG等。  
7. 应用层（Application Layer）：提供应用程序之间的交互，包括文件传输、电子邮件、远程登录等。该层的主要协议有HTTP、FTP、SMTP、DNS、TELNET、SNMP等。
![[Pasted image 20241205223731.png|600]]

## 2. TCP/IP 五层模型和四层模型
1. 物理层（Physical Layer）：定义物理设备标准，如网线、光纤、网卡等。  
2. 数据链路层（Data Link Layer）：在物理层的基础上，定义了数据的格式、传输速率等，如以太网协议、Wi-Fi协议等。  
3. 网络层（Network Layer）：处理数据包的传输，确定网络地址，以及路由选择等，如IP协议、ICMP协议等。  
4. 传输层（Transport Layer）：建立端到端的连接，保证数据的完整性和可靠性，如TCP协议、UDP协议等。  
5. 应用层（Application Layer）：处理特定的应用程序，如HTTP协议、FTP协议等。
![[Pasted image 20241208203017.png|400]]
## 3. 什么是TCP三次握手、四次挥手？
![[Pasted image 20241208203458.png]]
TCP三次握手是在
## 4. TCP是如何保证可靠传输的？

## 5. 说说 TCP 和 UDP 的区别？

## 6. HTTPS和HTTP的区别是什么？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手过程**，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
## 7. 说下 ping 的原理？

## 8. IPV4和IPV6的区别是什么？
## 9. JWT令牌详解:
### 出现背景:
互联网服务离不开用户认证。一般流程是下面这样:
> 1、用户向服务器发送用户名和密码。
> 2、服务器验证通过后，在**当前对话（session）里面保存相关数据**，比如用户角色、登录时间等等。
> 3、服务器向用户返回一个session_id，**写入用户的Cookie。**
> 4、用户随后的每一次请求,都会**通过 Cookie将session_id 传回服务器**。
> 5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

### JWT令牌原理:
JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户.

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器**完全只靠这个对象认定用户身份**。为了防止用户篡改数据，服务器在生成这个对象的时候，会**加上签名**（详见后文）。

**服务器就不保存任何 session 数据了，也就是说，服务器变成==无状态==了，从而比较容易实现扩展。**

### JWT的数据结构:
JWT由三个部分组成:`头部(Header).负载(Payload).签名(Signature)`,三者之间通过`.`隔开.
#### Header:
Header 部分是一个JSON对象，描述JWT的元数据,样例如下:
```JavaScript
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`表示签名算法,默认为`HMAC SHA256`(写成HS256);
- `typ`表示token类型,JWT令牌统一写成JWT.

#### Payload:
Payload部分也是一个JSON对象，用来存放实际需要传递的数据.JWT规定了7个官方字段:
- iss (issuer)：签发人
- **exp (expiration time)：过期时间**
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号
除了官方字段，你还可以在这个部分**定义私有字段**，下面就是一个例子:
```JavaScript
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
**JWT 默认是不加密**的，任何人都可以读到，所以不要把秘密信息放在这个部分。

#### Signature:
Signature部分是对前两部分的签名,防止数据篡改.

首先，需要**指定一个密钥（secret）**。这个**密钥只有服务器才知道，不能泄露给用户**。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。
>即`签名=HS257(Header.Payload,secret)`
```JavaScript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
计算出签名后,**将Header,Payload与Signature之间用`.`进行拼接**就得到了Token,就可以返回给用户了.
即对Header和Payload使用Base64URL算法生成JSON字符串,然后加上密钥,三者使用`.`进行拼接,获得最终的token.

### JWT的使用方式:
客户端收到服务器返回的 JWT，**可以储存在 Cookie 里面，也可以储存在 localStorage。**

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript 
> Authorization: Bearer <token>
 ```

另一种做法是,跨域的时候,JWT就放在POST请求的数据体里面。

### JWT的几个特点:
1. JWT**默认是不加密**，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次.
2. JWT不加密的情况下，不能将秘密数据写入JWT。
3. JWT不仅可以用于认证，也可以**用于交换信息**。有效使用JWT，可以**降低服务器查询数据库的次数。**
4. JWT的最大缺点是，由于服务器不保存 session 状态，因此**无法在使用过程中废止某个 token**，或者更改token的权限。也就是说，一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
5. JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，**JWT的有效期应该设置得比较短**。对于一些比较重要的权限，使用时应该再次对用户进行认证。
6. 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。

![[Pasted image 20241011012123.png]]

## 10. WebSocket详解
### 出现背景:
根本原因在于HTTP协议的缺点,通信只能由客户端发起. 例如,如果想了解当天的天气,只能是由客户端想服务端发起查询请求,服务端返回查询结果. 而无法做到服务端向客户端主动推送消息.

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用**轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息**。最典型的场景就是聊天室。

轮询的效率很低,并且浪费资源,因为客户端和服务端必须不停连接,或者HTTP连接始终打开.

### 简介:
WebSocket的最大特点就是，**服务器可以主动向客户端推送信息,客户端也可以主动向服务器发送信息**，是真正的双向通信，属于服务器推送技术的一种。

WebSocket的其他特点:
1. 建立**在 TCP 协议**之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL.

### WebSocket出现之前的即时通讯方式:
1. **定期轮询:**
	- **客户端按照某个时间间隔不断地向服务端发送请求**，请求服务端的最新数据然后更新客户端显示。这种方式实际上**浪费了大量流量并且对服务端造成了很大压力**。
2. **SSE(Server-Sent Event,服务器推送事件):**
	- SSE是一种允许服务端向客户端推送新数据的HTML5技术.