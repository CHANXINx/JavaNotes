# 基础篇
## 1. 讲讲OSI七层模型。
1. 物理层（Physical Layer）：主要规定传输介质的传输方式，包括电信号、电压、光脉冲等。该层的主要协议是物理媒介相关协议，如RS232、V.35、以太网等。  
2. 数据链路层（Data Link Layer）：在物理层上建立数据链路，对数据进行分帧、差错校验等处理，确保数据可靠地传输。该层的主要协议有点对点协议PPP（Point-to-Point Protocol）、高级数据链路控制协议HDLC（High-Level Data Link Control）、以太网协议等。  
3. 网络层（Network Layer）：主要解决数据在网络中的传输问题，包括寻址、路由选择等。该层的主要协议有IP协议、网关协议（ARP）、路由协议（RIP、OSPF、BGP等）等。  
4. 传输层（Transport Layer）：提供端到端的可靠传输服务，包括数据传输控制、流量控制等。该层的主要协议有TCP协议、UDP协议、SCTP协议等。  
5. 会话层（Session Layer）：提供会话管理功能，负责建立、维护和结束会话。该层主要实现了不同计算机之间的会话控制，为高层协议提供一个传输数据的会话环境，该层的主要协议有NetBIOS等。  
6. 表示层（Presentation Layer）：负责数据格式的转换，确保应用层数据的格式一致。该层主要实现了数据格式的转换和数据加密解密等功能，如JPEG、MPEG等。  
7. 应用层（Application Layer）：提供应用程序之间的交互，包括文件传输、电子邮件、远程登录等。该层的主要协议有HTTP、FTP、SMTP、DNS、TELNET、SNMP等。
![[Pasted image 20241205223731.png|600]]

## 2. TCP/IP 五层模型和四层模型
四层：**应用层，传输层，网络层和网络接口层**（四层就是在五层的基础撒好难过将数据链路层和物理层合并成了网络接口层）
1. 应用层（Application Layer）：处理特定的应用程序，**如HTTP协议**、FTP协议等。
2. 传输层（Transport Layer）：建立端到端的连接，保证数据的完整性和可靠性，**如TCP协议**、**UDP协议等**。  
3. 网络层（Network Layer）：处理数据包的传输，确定网络地址，以及路由选择等，**如IP协议**、ICMP协议等。  
4. 数据链路层（Data Link Layer）：在物理层的基础上，定义了数据的格式、传输速率等，如以太网协议、Wi-Fi协议等。  
5. 物理层（Physical Layer）：定义物理设备标准，如网线、光纤、网卡等。  
![[Pasted image 20241208203017.png|400]]
## 3. TCP的粘包、拆包问题是什么？
#### 是什么？
TCP通信时，因为TCP是面向流的，所以发送方在传输数据时可能会**将多个小数据包粘合在一起进行发送**，而接收方可能**将这些数据包拆成多个小数据包进行接收**，从而导致数据接收错误、或者数据粘连问题。

主要出现在以下两种情况：
1. 发送方连续发送多个小数据包：TCP是基于流的协议，因此发送方可能将多个小数据包组合成一个大数据包进行发送，从而导致接收方在接收数据时**无法区分不同数据包的界限**。
2. 接收方缓存区大小限制：接收方在接收数据时，如果**接收缓存区大小有限，可能会将一个大数据包拆分成多个小数据包进行接收**，从而导致粘包和拆包问题出现。
#### 如何解决？
对包的格式进行约束，有以下四种常见的解决方案：
1. 将业务层协议包的**长度固定**，当客户端发送数据长度不足固定长度，则通过添加空格补全。
2. 在每个包的末尾**添加固定的分隔符**，如换行符\n，当拆分时，通过\n换行符连接不同包的拆分部分。
3. 仿照TCP/IP协议，将消息分为header和body，**在header中保存了当前整个消息的长度，只有读取到足够长度，才算一个完整消息**。
4. ~~通过自定义协议进行粘包和拆包处理。~~
## ARP协议和RARP协议有什么区别？
二者都是网络通信协议，用于IP地址和MAC地址的转换。
#### 功能不同
ARP协议：用于将IP地址转换为MAC地址。
RARP协议：用于将MAC地址转换为IP地址。需要知道本机IP地址时，可以向网络中发送RARP请求，获取自己的IP地址。
#### 工作方式不同
ARP协议是**广播协议**，当一台主机需要知道另一台主句的MAC地址时，会在本地局域网上广播一个ARP请求包，所有主机都能接收该请求包，但只有目标主机会响应请求，发送自己的MAC地址。
RAPR协议，则是**向预定义的RARP服务器发出请求**，请求服务器返回本机IP地址。
## 路由器和交换机的区别是什么？
在OSI七层模型中，路由器主要工作在网络层，交换机主要工作在数据链路层。

路由器转发依据IP地址，交换机转发依据的是MAC地址。
交换机用于组建局域网，路由器用于将局域网相互连接，或者接入互联网。

## 4. 什么是TCP三次握手、四次挥手？
### 三次握手（建立连接）
![[Pasted image 20241208203458.png]]
TCP是面向连接的，所以使用TCP之前必须先建立连接，而建立连接通过三次握手实现。具体过程如下：
 - **客户端发送 SYN**，请求建立连接。
- **服务端回复 SYN + ACK**，同意连接并同步状态。
- **客户端发送 ACK**，确认连接建立。

TCP的连接建立要解决以下三个问题：
1. 使TCP双方能够**确认对方的存在**；
2. 使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 使TCP双方能够对运输实体资源（如缓存大小等）进行分配。

### 四次挥手（断开连接）
![[Pasted image 20250110215715.png]]
- **第一步（主动关闭方发送 FIN）：** 主动关闭方请求关闭连接。
- **第二步（被动关闭方发送 ACK）：** 被动关闭方确认请求，准备关闭。
- **第三步（被动关闭方发送 FIN）：** 被动关闭方请求关闭连接。
- **第四步（主动关闭方发送 ACK）：** 主动关闭方确认关闭，进入 `TIME_WAIT` 状态。
---
### 1. **TCP 三次握手（建立连接）**

**目标：** 确保通信双方都能正常发送和接收数据，建立可靠的连接。

**过程：**

1. **第一次握手（客户端 -> 服务端）：**  
    客户端发送一个带有 `SYN` 标志位的报文给服务端，表示请求建立连接，同时包含一个初始序列号 `seq = x`。  
    **作用：** 客户端发起连接请求。
2. **第二次握手（服务端 -> 客户端）：**  
    服务端收到客户端的 `SYN` 报文后，发送一个 `SYN+ACK` 报文给客户端，表示同意建立连接。
    - `SYN` 表示服务端愿意建立连接。
    - `ACK` 确认客户端的初始序列号，并返回 `ack = x+1`。  
        **作用：** 服务端确认收到连接请求，并向客户端发送自己的连接请求。
3. **第三次握手（客户端 -> 服务端）：**  
    客户端收到服务端的 `SYN+ACK` 报文后，发送一个 `ACK` 报文给服务端，确认服务端的序列号 `ack = y+1`。  
    **作用：** 客户端确认连接建立，双方进入 **ESTABLISHED** 状态。

**总结：** 三次握手的本质是为了确认：
- 双方的发送和接收能力正常。
- 双方的初始序列号已经交换，为后续可靠传输做好准备。

---

### 2. **TCP 四次挥手（断开连接）**

**目标：** 可靠地释放双方的资源，断开连接。

**过程：**
1. **第一次挥手（客户端 -> 服务端）：**  
    客户端发送一个 `FIN` 报文给服务端，表示数据发送完毕，请求断开连接。  
    **作用：** 客户端进入 **FIN_WAIT_1** 状态，等待服务端的确认。
2. **第二次挥手（服务端 -> 客户端）：**  
    服务端收到 `FIN` 报文后，返回一个 `ACK` 报文，表示收到断开请求。  
    **作用：** 服务端进入 **CLOSE_WAIT** 状态，客户端进入 **FIN_WAIT_2** 状态，等待服务端处理未完成的数据。
3. **第三次挥手（服务端 -> 客户端）：**  
    服务端处理完数据后，发送一个 `FIN` 报文，表示数据发送完毕，请求断开连接。  
    **作用：** 服务端进入 **LAST_ACK** 状态，等待客户端确认。
4. **第四次挥手（客户端 -> 服务端）：**  
    客户端收到服务端的 `FIN` 报文后，返回一个 `ACK` 报文，表示确认断开。
    - 客户端进入 **TIME_WAIT** 状态，等待一段时间（默认 2MSL，约 2 分钟）以保证服务端收到确认后完全关闭。
    - 服务端收到确认后进入 **CLOSED** 状态，释放连接资源。

**总结：** 四次挥手的设计目的是为了保证：
- 双方的数据都被完整传输，不会遗漏或丢失。
- 连接关闭后释放双方的资源。
## 5. 为什么需要三次握手？不能是两次吗？
简单来说，是为了防止超时失效的连接请求报文突然又传送到了TCP服务器，因而导致错误。

>**_The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.防止旧的重复连接初始化造成混乱。_**
## 6. 为什么需要四次挥手？
对于四次挥手，因为 TCP 是**全双工通信**，在主动关闭方发送 FIN 包后，**接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道**，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。

服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，**但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序**：
## 7. 第二次和第三次不能合并吗？
可以合并！当被动关闭方在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**【**捎带确认机制**】
## 8. 为什么TCP客户进程在发送完最后一个确认 报文段后还要等待2MSL才关闭？
假设普通的TCP确认报文段发送后，TCP客户端进入关闭状态。此时**TCP确认报文段在发送过程中丢失，此时TCP服务器会对TCP连接释放报文段进行超时重传，并仍处于最后确认状态**。然而此时由于TCP客户端处于关闭状态，因此无法接收该报文，导致TCP服务器对该报文不断超时重传， 并始终处于最后确认状态，无法进入关闭状态。

总结：2MSL可以**保证TCP服务器能收到最后一个TCP确认报文段并进入关闭状态**

## 9. 若TCP客户端发生故障，TCP服务端是如何发现故障并及时关闭的？
使用保活计时器实现。
- TCP服务器每接收到TCP客户端发送的一条数据，就重新设置并启动保活计时器（2小时）
- 若保活计时器定时周期内未收到TCP客户端发送的数据，则**计时器到时后，TCP服务器进程就会向TCP客户端发送一个探测报文段**，以后每隔75秒发送一次。若**一连发送10个探测报文仍无TCP客户进程的响应**，TCP服务器进程就认为TCP客户进程所在主机发生了故障，就会关闭该连接。
## 10. 为什么SYN=1的报文不可以携带数据？
根据 TCP 协议规范（[RFC 793](https://tools.ietf.org/html/rfc793)），`SYN` 报文用于初始化连接，其序列号占用一个序号位置，但不携带实际数据。如果 `SYN` 报文携带数据，接收方需要在连接完全建立之前处理这些数据，这与 TCP 标准的连接控制逻辑相违背。
## TCP保证可靠传输，如何理解这个可靠性？
网络协议可靠，需要满足以下要求：
1. 数据完整性。
2. 数据顺序。
3. 不能重复。
4. 不能被篡改。
## 11. TCP是如何保证可靠传输的？
TCP将应用数据分割成TCP认为最适合发送的数据块。TCP给发送的每个包进行编号，接收方对数据包进行排序，将有序数据传送到应用层。

- **连接管理**：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。
- **序列号**：TCP将每个字节的数据都进行了编号，这就是序列号。序列号的具体作用如下：能够保证可靠性，既能防止数据丢失，又能避免数据重复。能够保证有序性，按照序列号顺序进行数据包还原。能够提高效率，基于序列号可实现多次发送，一次确认。
- **确认应答**：接收方接收数据之后，会回传ACK报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。在指定时间后，若发送端仍未收到确认应答，就会启动超时重传。
- **流量控制**：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，就会导致接收端的缓冲区溢出，进而导致丢包。为了避免上述情况的发生，TCP支持根据接收端的处理能力，来决定发送端的发送速度。这就是流量控制。流量控制是通过在TCP报文段首部维护一个滑动窗口来实现的。
- **拥塞控制**：拥塞控制就是当网络拥堵严重时，发送端减少数据发送。拥塞控制是通过发送端维护一个拥塞窗口来实现的。可以得出，发送端的发送速度，受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复。
- **超时重传**：超时重传主要有两种场景：数据包丢失：在指定时间后，若发送端仍未收到确认应答，就会启动超时重传，向接收端重新发送数据包。确认包丢失：当接收端收到重复数据(通过序列号进行识别)时将其丢弃，并重新回传ACK报文。

## 12. TCP的拥塞控制方法有哪些？
#### 慢启动
#### 快重传
#### 快恢复
#### 拥塞避免
## 什么是HTTP/3的QUIC协议？

## 13. 说说 TCP 和 UDP 的区别？
- **连接**：
	- TCP 是面向连接的传输层协议，传输数据前先要通过三次握手建立连接，并在结束后通过四次握手断开连接；
	- UDP 是不需要连接，即刻传输数据。
- **可靠性**：
	- TCP 是可靠交付数据的，通过确认和重传机制保证数据的正确送达。
	- UDP 是尽最大努力交付，发送数据单不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议
- **拥塞控制、流量控制**：
	- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
	- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
- **传输方式**：
	- TCP 是流式传输，没有边界，但保证顺序和可靠。
	- UDP 是报文传输，一个包一个包的发送，是有边界的，但可能会丢包和乱序。
- **首部开销**：
	- TCP 首部长度较长，最小为20字节，包含更多控制信息。
	- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
- **使用场景**：
	- TCP通常用于高可靠性的应用，如网页浏览、电子邮件、文件传输等；
	- UDP适用于实时应用，如视频流、语音通话等。
## 14. Cookie，Session，Token的区别是什么？
- cookie是存储于浏览器端的一小段文本数据，后续请求中，cookie会随着http请求一同发送到服务端。
- session是一种在服务端保存用户状态信息的机制，可以用于存储用户信息等资源，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。
- token类似一个令牌，是一种用于身份验证的字符串，通常由服务器生成并发送到客户端。用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。
## 15. ⭐浏览器输入`www.baidu.com`回车之后发生了什么？
- **解析URL**：分析 URL 所需要使用的传输协议和请求的资源路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。
- **缓存判断**：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。
- **DNS解析**：如果资源不在本地缓存，首先需要进行DNS解析。浏览器会向本地DNS服务器发送域名解析请求，本地DNS服务器会逐级查询，最终找到对应的IP地址。
- **获取MAC地址**：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
- **建立TCP连接**：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器转发，等路由器转到目标服务器后，服务器回复一个SYN-ACK包，确认连接请求。然后，主机发送一个ACK包，确认已收到服务器的确认，然后 TCP 连接建立完成。
- **HTTPS 的 TLS 四次握手**：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的四次握手。
- **发送HTTP请求**：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。
- **服务器处理请求并返回响应**：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。

**1. DNS 解析：** 将域名解析为 IP 地址。  
**2. TCP 三次握手：** 建立客户端与服务器的连接。  
**3. 浏览器发送 HTTP 请求：** 向服务器请求页面资源（如 HTML 文件）。  
**4. 服务器返回 HTTP 响应：** 包含 HTML、CSS、JS 等资源文件。  
**5. 浏览器渲染页面：** 解析 HTML 和 CSS，执行 JS，最终绘制页面。  
**6. 后续异步加载：** 如图片、AJAX 数据等。
## 16. 对称加密和非对称加密有什么区别？
#### 是什么AND区别
- 对称加密，指的是加密和解密使用**相同秘钥**的加密算法。对称加密可以通过加密后的密文，再根据密钥还原出明文。
- 非对称加密，指的是加密和解密使用不同密钥的加密算法，也称为公私钥加密。
#### 各举几个常见的加密算法
## 17. 简单介绍一下DNS
DNS全称Domain Name System，域名系统。 DNS是作为一个**将域名和IP地址相互映射的分布式数据库**，使得用户能更方便地访问互联网。

DNS最主要的作用就是将域名翻译成IP地址。因为为了方便记忆，都是将IP地址映射成由点分隔的字符组成的域名，用户可以通过直接访问域名来代替IP地址，DNS就是处理域名与IP地址相互映射的工具。
## 18. Ping的原理是什么？
ping用于探测本机与网络中的另一台主机是否可达。利用Ping命令可以检查网络是否畅通以及网络连接速度。

Ping是基于ICMP（Internet Control Messages Protocol）来工作的，即因特网信报控制协议）。Ping利用了ICMP的两种控制消息：echo request回显请求和echo reply回显应答。主机A执行Ping时，就会发送回显请求，主机B正确接收后会返回回显应答，通过对方回复的数据包来确定两台网络机器是否相同、以及时延是多少。

PING命令本身处于应用层，而ICMP是网络层协议，因此PING命令是一个应用层直接使用网络层的例子。
## 19. 如何解决跨域问题？
跨域访问问题（Cross-Origin Resource Sharing，CORS）是由浏览器同源策略引发的，它要求网页中的所有资源必须来自同一个域名、协议和端口，否则浏览器会阻止跨域的资源请求。

#### 解决办法
1. **CORS**：CORS是目前最常见的解决跨域问题的方案，通过在服务端设置相应的响应头来解决跨域问题。服务器在响应中添加Access-Control-Allow-Origin头，指定允许跨域访问的域名或通配符*，使得浏览器可以放行跨域请求。
2. 
3. **代理服务器**：在同源域名下设置代理服务器实现跨域访问。前端将请求发送给代理服务器，通过代理服务器转发给目标服务器，并将响应返回给前端。
## 20. CDN是什么，为什么可以做缓存？
CDN是Content Delivery Network的缩写，翻译成**内容分发网络**。主要通过**将内容存储在全国各地的边缘节点**，以就近原则向用户提供内容。

CDN可以做缓存是因为它在全球范围内部署了多个边缘节点，这些节点分布在不同的地理位置，靠近用户所在的区域。当用户请求某个资源（例如网页、图片、视频等），CDN会根据用户的位置，**将资源从最近的边缘节点提供给用户**。

用户首次访问这些资源的时候，**CDN会将资源从服务器获取到，并将其缓存到边缘节点上**。当其他用户在同一地区请求相同的资源时，CDN会直接从边缘节点返回缓存的副本，而不必再次访问源服务器。这样可以减少网络延迟和带宽消耗，提高内容的传输速度和响应性能。
## 21. 什么是长连接和短连接？
#### 短连接
- 客户端和服务器之间的连接在每次请求完毕后立即关闭，下一次请求重新建立连接。
- 优点：
	- 节约服务器资源，也能避免服务器长时间维护过多连接。
- 缺点：
	- 每次请求都需要重新建立连接，有很多额外的性能开销。
#### 长连接
- 客户端与服务端建立TCP连接后，保持连接状态，允许复用一个连接进行多次请求和响应。
- 优点：
	- 避免频繁建立和关闭TCP连接的开销，提高性能。
- 缺点：
	- 服务器需要维护大量连接，导致资源占用增加；
	- 连接可能因超时而断开，需要心跳检测（KeepAlive机制）来维持连接。

---

# HTTP篇
## 1. HTTP是什么？
- HyperText Transfer Protocol，超文本传输协议。HTTP是一个在两者之间传输文字、链接、音频、视频、图片等超文本数据的约定和规范。
- 两者之间可以是服务器和浏览器、也可以是服务器和服务器。
## 2. HTTP的常见状态码有哪些？
![[Pasted image 20241226134318.png|500]]
- **1xx，提示信息，是协议处理中的一种中间状态。**
- **2xx，表示服务器成功处理客户端请求。**【正确处理】
	- 200，表示一切正常。若请求为非HEAD请求，则返回的响应头中会带有响应体body；
	- 204 No Content，成功状态码，但是响应头中没有body数据；
	- 206 Partial Content，应用于HTTP分块下载或断点续传，表示响应返回的body数据中只是**资源的一部分**。
- **3xx，表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，即重定向。**【重定向】
	- 301 Moved Permanently，表示永久重定向，说明**请求的资源已不存在**，需要使用新的URL再次访问；
	- 302 Found，表示临时重定向，说明资源仍在，只是**暂时**需要用另一个URL来访问。
	- ⭐304 Not Modified，不具有跳转含义，**表示资源未修改**，重定向已存在的缓存文件，也称**缓存重定向**。也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- **4xx，表示客户端发送的报文有误，服务器无法处理！**【客户端的错误】
	- 400 Bad Request，笼统的错误；
	- 403 Forbidden，**表示服务器禁止访问资源**，并不是客户端请求出错；
	- ⭐404 Not Found，表示请求资源在服务器不存在或未找到；
- **5xx，表示请求正确，但是服务器内部处理发生了错误，属于服务端的错误码。**【服务端的错误】
	- 500 Internal Server Error，笼统错误码；
	- 501 Not Implemented，表示所请求的功能暂不支持；
	- 502 Bad GateWay，服务器作为网关或代理返回的错误码，说明请求后端服务器时发生了错误；
	- 503 Service Unavailable，表示服务器很忙，暂时无法响应客户端。
	- ⭐504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。
## 3. HTTP常见字段有哪些？
- Host：www.A.com，用于将请求发往服务器的不同网站；
- Content-Length字段：服务器返回数据时，表明本次回应的数据长度；
- Connection字段：用于客户端要求服务器使用「HTTP长连接」机制，以便其他请求复用；
- Content-Type字段：用于服务器回应时，告诉客户端本次数据的格式；
	- Accept字段：用于客户端发送时，声明可以接收的数据格式。
- Content-Encoding字段：表示服务器返回数据所使用的压缩格式。
	- Accept-Encoding字段：表明客户端所能接受的压缩格式。
## 4. GET和POST的区别
- GET请求一般用于从服务器获取指定资源。
	- GET方法是安全、幂等、可被缓存的。
- POST请求是根据请求负荷对指定资源做出处理。
	- POST请求是不安全、非幂等、不可缓存的。

GET请求也可以携带body，理论上任何请求都可以携带body。只不过遵循RFC规范，GET请求是获取资源，一般不需要用到Body。
## 5. HTTP缓存有哪些实现方式？ TODO
有**强制缓存和协商缓存**两种实现方式。

## 6. HTTP/1.1、HTTP/2、HTTP/3 演变

#### HTTP/1.1：
- 使用长连接的方式改善了HTTP/1.0短连接造成的性能开销；
- 支持**管道网络传输【解决了请求的队头阻塞问题】**，第一个请求发出去后，不必等待响应就可发送第二个请求，可减少整体的响应时间；

**性能瓶颈：**
- 请求头、响应头未经压缩就发送，首部信息越多延迟越大；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器按请求顺序响应，若服务器响应慢，会导致客户端一直请求不到数据，造成队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务端只能被动响应。
#### HTTP/2：
##### HTTP/2的优化：
- **基于HTTPS协议**，安全性提高；
- **头部压缩**：若发送多个请求的头部是一样或近似的，则会**消除重复部分**；
	- HPACK算法：客户端和服务器同时维护头信息表，所有字段都存入该表，生成索引号，以后只发送索引不发送字段，提高响应速度，减少资源浪费；
- **二进制格式**：区别于HTTP/1.1的纯文本形式，采用二进制格式，头信息和数据体都用二进制形式，称为**头信息帧和数据帧**。无需再将明文转换为二进制，而是直接解析二进制报文，提高数据传输效率。
  ![[Pasted image 20241226145208.png|340]]
- **并发传输**：HTTP/2引入Stream概念，**多条Stream可复用一条TCP连接【解决了响应的队头阻塞问题】**，每个Stream可包含一个或多个Message（对应HTTP/1请求或响应），由HTTP头部和包体构成。
	- Message包含一条或多条Frame，Frame是HTTP/2的最小单位，以二进制压缩格式存放HTTP/1中的内容。
	  ![[Pasted image 20241226193110.png|300]]
	- 接收端可以根据StreamID将Steam有序拼接成HTTP消息，因此HTTP可以乱序发送，共享一条TCP连接。
	  ![[Pasted image 20241226193147.png|400]]
- **服务器推送**：服务端可以主动向客户端发送消息。
	- 例如：HTTP/1.1中，客户端从服务器获取了HTML文件，可能还需要再发送请求获取CSS文件才能渲染页面；而在HTTP/2中，客户端获取HTML文件后，服务端可以主动发送CSS文件，减少通信次数。
	  ![[Pasted image 20241226193624.png|400]]

##### HTTP/2的缺陷：
- **解决了HTTP的队头阻塞，但依然存在TCP层的队头阻塞问题**。HTTP/2基于**TCP协议**传输数据。由于TCP协议是字节流协议，因此必须保证收到的字节数据是完整且连续的，才会将缓冲区的数据返回给HTTP应用。因此，假设发送端发送了多个Packet，构成一条TCP数据，但此时某个Packet丢失了，则内核中的TCP数据就不是完整且连续的了，此时就无法从缓冲区中获取数据，而必须等待丢失的Packet进行重传。
  ![[Pasted image 20241226194400.png|450]]
#### HTTP/3：
##### HTTP/3的优化：
1. 通过把HTTP下层的TCP协议改成UDP协议，优化了丢包造成的TCP层的队头阻塞问题。UDP发送不管顺序、也不管丢包，因此不是可靠传输。但是HTTP/3通过**基于UDP的QUIC协议**实现了类似TCP的可靠传输。
	   ![[Pasted image 20241226195418.png|500]]
	-  QUIC协议的特点：1）无队头阻塞；2）更快的连接建立；3）连接迁移。
		1. **无队头阻塞**：在同一条连接上并发传输多个Stream，一个Stream可认为是一条HTTP请求。
			- 可靠性传输：某个Stream丢包时，只会阻塞该流，其它流不会受到影响。
			  ![[Pasted image 20241226195932.png|450]]
		2. **更快的连接建立**：
		3. **连接迁移**：
## 7. HTTP/1.1如何优化？
- **避免发送HTTP请求**：缓存；
- **需要发送时，减少请求次数**：1）减少重定向次数；2）合并请求；3）延迟发送请求；
- **减少服务器的HTTP响应的数据大小**：1）无损压缩；2）有损压缩。
#### 避免发送HTTP请求
- 通过**缓存技术**。客户端会把第一次请求以及响应的数据保存在本地磁盘上，将请求的URL作为KEY，响应的数据作为VALUE。后续发生相同请求，都会先读缓存。
- 服务端发送HTTP响应时，会估算过期时间并放到响应头部，这样客户端发现资源过期后，就会重新发送网络请求。
	- 客户端重新发送请求时，会在请求的Etag头部带上响应的摘要，用于唯一标识响应资源。当服务器收到请求后，会将本地资源的摘要与Etag中的摘要进行比较：若相同，则返回的响应中不会携带资源，仅返回304状态码，用于告诉客户端缓存仍有效；若不同，则会返回最新的资源。
![[Pasted image 20241226203259.png|450]]
#### 减少HTTP请求次数
##### 减少重定向请求次数
- 将**重定向工作交给代理服务器完成**，减少HTTP请求次数。
  ![[Pasted image 20241226204402.png]]
##### 合并请求
- 将多个访问小文件的请求合并成一个大请求，虽然传输的总资源一致，但是减少次数，也就意味着减少了重复发送的HTTP头部。
##### 延迟发送请求
- 网页中会包含很多HTTP的URL，避免一次性获取。只有当用户滑动网页需要浏览时，才发送请求获取资源，从而减少第一时间的请求次数。
#### 减少HTTP响应的数据大小
##### 无损压缩
- 压缩代码：去掉多余的换行符、空格等利于程序员阅读的符号；
- 无损压缩：对原始资源建立统计模型，将常出现的数据用较短的二进制比特序列表示；将不常出现的数据用较长的二进制比特序列表示。
##### 有损压缩
- 将PNG图片压缩成WebP格式；
- 压缩视频：通过将静态画面部分使用增量数据来表示后续的帧，从而减少很多数据。
## 8. ⭐HTTPS和HTTP的区别是什么？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手过程**，才可进入加密报文传输。【HTTP三次握手，HTTPS四次握手】
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
## 9. HTTPS RSA握手过程解析
#### TLS握手过程【基于RSA算法】
HTTPS在HTTP和TCP层之间加入了**TLS协议**，通过信息加密、校验机制和安全证书三方面来保证信息安全。
![[Pasted image 20241227094257.png|300]]

在HTTP通信前，需要先进行TLS握手：
- 图中 每一个框都是一个记录，记录是TLS收发数据的基本单位，类似于TCP里的segment。多个记录可以组合成一个TCP包发送，所以通常经过「**四个信息**」就可以完成TLS握手，也就是需要**两个RTT时延**。
- HTTPS是应用层协议，所以需要先完成TCP连接，然后再进行TLS握手后，才能建立可靠安全的连接。
![[Pasted image 20241227094410.png|400]]
- TLS第一次握手：【Client→Server】
	- `Client Hello`，携带TLS版本号、密码套件以及生成的随机数。其中随机数会被保留，作为生成对称加密密钥的材料之一。
- TLS第二次握手：【Server→Client】
	- `Server Hello`：服务端确认TLS版本、选择一个合适的密码套件并返回服务端生成的随机数。
		- 密码套件：由「**密钥交换算法+签名算法+对称加密算法+摘要算法**」组成。
	- `Certificate`：发送数字证书，证明服务器身份。
	- `ServerHelloDone`：告知信息已发送完毕。
- TLS第三次握手：【Client→Server】
	- `ClientKeyExchange`：验证证书，生成随机数并使用服务器的RSA公钥加密后发送给服务端；服务端收到密钥后，用RSA私钥解密，得到客户端发送的随机数。
		- 至此，双方已共享三个随机数：`Server Random`、`Client Random`和`pre-master`。双方根据随机数生成会话密钥（对称密钥），用于对后续HTTP请求/响应的数据加解密。
	- `Change Cipher Spec`：根据随机数生成完会话密钥后，会发送此消息告诉客户端开始使用加密方式发送消息。
	- `Finished`：客户端会把之前所有发送的数据做摘要，再用会话密钥加密后发送，让服务器做验证，以保证加密通信可用、未被篡改。
- TLS第四次握手：【Server→Client】
	- `Change Cipher Spec`：根据随机数做加密，并以加密方式发送信息。
	- `Finished`：确认加密通信可用且未被篡改。
- 完成四次握手后，开始传输应用数据。
**RSA算法的缺点：**
1. 不支持前向保密。若私钥泄露，则还会导致过去所有的密文被破译。
#### 基于DH算法的TSL握手过程：


## 10. 有了HTTP协议，为什么还要有RPC协议？
- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式【远程过程调用】**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员**能像调用本地方法那样去调用远端的服务方法**。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议【基于UDP协议也行】**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## 11. 有了HTTP协议，为什么还要有WebSocket？
- HTTP协议是半双工的，对于需要双向通信，尤其是服务器主动向客户端推送数据的场景不友好；而WebSocket是全双工的，支持建立连接后服务器与客户端的双向通信。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。【本质还是客户端主动请求服务端数据】
	- **【定时轮询】**：基于HTTP协议可以实现**伪推送**模式，就是前端在用户无感知的情况下不断向后端发送请求，服务器收到请求后向客户端返回数据。但是会有延迟，因为前端请求可能是每1~2秒发送。【定时轮询】
	- **【长轮询】**：将HTTP请求的超时时间延长，例如由3秒延长至30秒，此时只要服务器收到了用户的扫码请求，就立刻返回数据给客户端。若超时，则立马再发送请求，建立长轮询。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
## 12. HTTP报文有哪些部分？
分为请求报文和响应报文。
# IP

## 1. IPV4和IPV6的区别是什么？
## 2. JWT令牌和传统方式有什么区别？
1. **无状态性**：JWT是无状态的令牌，不需要在服务器端存储会话信息。相反，**JWT令牌中包含了所有必要的信息**，如用户身份、权限等。这使得JWT在分布式系统中更加适用，可以方便地进行扩展和跨域访问。
2. **安全性**：JWT使用密钥对令牌进行签名，确保令牌的完整性和真实性。只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比传统的基于会话和Cookie的验证更加安全，有效防止了CSRF（跨站请求伪造）等攻击。
3. **跨域支持**：JWT令牌可以在不同域之间传递，适用于跨域访问的场景。通过在请求的头部或参数中携带JWT令牌，可以实现无需Cookie的跨域身份验证。
## 3. JWT 令牌都有哪些字段？
JWT令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为JSON格式，使用**Base64编码进行序列化**，而**签名部分是对头部、载荷和密钥进行签名后的结果**。

## 4. JWT 令牌为什么能解决集群部署？
**JWT令牌通过在令牌中包含所有必要的身份验证和会话信息**，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。当用户进行登录认证后，服务器将生成一个JWT令牌并返回给客户端。客户端在后续的请求中携带该令牌，**服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息**，而无需访问共享的会话存储。
## 5. jwt的缺点是什么？
派发后无法撤销。
解决办法：在Redis中存储黑名单列表，配合布隆过滤器过滤黑名单用户。
## 6. JWT令牌详解:
### 出现背景:
互联网服务离不开用户认证。一般流程是下面这样:
> 1、用户向服务器发送用户名和密码。
> 2、服务器验证通过后，在**当前对话（session）里面保存相关数据**，比如用户角色、登录时间等等。
> 3、服务器向用户返回一个session_id，**写入用户的Cookie。**
> 4、用户随后的每一次请求,都会**通过 Cookie将session_id 传回服务器**。
> 5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。
### JWT令牌原理:
JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户.

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器**完全只靠这个对象认定用户身份**。为了防止用户篡改数据，服务器在生成这个对象的时候，会**加上签名**（详见后文）。

**服务器就不保存任何 session 数据了，也就是说，服务器变成==无状态==了，从而比较容易实现扩展。**
### JWT的数据结构:
JWT由三个部分组成:`头部(Header).负载(Payload).签名(Signature)`,三者之间通过`.`隔开.
#### Header:
Header 部分是一个JSON对象，描述JWT的元数据,样例如下:
```JavaScript
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`表示签名算法,默认为`HMAC SHA256`(写成HS256);
- `typ`表示token类型,JWT令牌统一写成JWT.
#### Payload:
Payload部分也是一个JSON对象，用来存放实际需要传递的数据.JWT规定了7个官方字段:
- iss (issuer)：签发人
- **exp (expiration time)：过期时间**
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号
除了官方字段，你还可以在这个部分**定义私有字段**，下面就是一个例子:
```JavaScript
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
**JWT 默认是不加密**的，任何人都可以读到，所以不要把秘密信息放在这个部分。

#### Signature:
Signature部分是对前两部分的签名,防止数据篡改.

首先，需要**指定一个密钥（secret）**。这个**密钥只有服务器才知道，不能泄露给用户**。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。
>即`签名=HS257(Header.Payload,secret)`
```JavaScript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
计算出签名后,**将Header,Payload与Signature之间用`.`进行拼接**就得到了Token,就可以返回给用户了.
即对Header和Payload使用Base64URL算法生成JSON字符串,然后加上密钥,三者使用`.`进行拼接,获得最终的token.

### JWT的使用方式:
客户端收到服务器返回的 JWT，**可以储存在 Cookie 里面，也可以储存在 localStorage。**

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript 
> Authorization: Bearer <token>
 ```

另一种做法是,跨域的时候,JWT就放在POST请求的数据体里面。

### JWT的几个特点:
1. JWT**默认是不加密**，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次.
2. JWT不加密的情况下，不能将秘密数据写入JWT。
3. JWT不仅可以用于认证，也可以**用于交换信息**。有效使用JWT，可以**降低服务器查询数据库的次数。**
4. JWT的最大缺点是，由于服务器不保存 session 状态，因此**无法在使用过程中废止某个 token**，或者更改token的权限。也就是说，一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
5. JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，**JWT的有效期应该设置得比较短**。对于一些比较重要的权限，使用时应该再次对用户进行认证。
6. 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。

![[Pasted image 20241011012123.png]]

## 7. WebSocket详解
### 出现背景:
根本原因在于HTTP协议的缺点,通信只能由客户端发起. 例如,如果想了解当天的天气,只能是由客户端想服务端发起查询请求,服务端返回查询结果. 而无法做到服务端向客户端主动推送消息.

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用**轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息**。最典型的场景就是聊天室。

轮询的效率很低,并且浪费资源,因为客户端和服务端必须不停连接,或者HTTP连接始终打开.

### 简介:
WebSocket的最大特点就是，**服务器可以主动向客户端推送信息,客户端也可以主动向服务器发送信息**，是真正的双向通信，属于服务器推送技术的一种。

WebSocket的其他特点:
1. 建立**在 TCP 协议**之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL.

### WebSocket出现之前的即时通讯方式:
1. **定期轮询:**
	- **客户端按照某个时间间隔不断地向服务端发送请求**，请求服务端的最新数据然后更新客户端显示。这种方式实际上**浪费了大量流量并且对服务端造成了很大压力**。
2. **SSE(Server-Sent Event,服务器推送事件):**
	- SSE是一种允许服务端向客户端推送新数据的HTML5技术.