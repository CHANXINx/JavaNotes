# 基础篇
## 1. 讲讲OSI七层模型。
1. 物理层（Physical Layer）：主要规定传输介质的传输方式，包括电信号、电压、光脉冲等。该层的主要协议是物理媒介相关协议，如RS232、V.35、以太网等。  
2. 数据链路层（Data Link Layer）：在物理层上建立数据链路，对数据进行分帧、差错校验等处理，确保数据可靠地传输。该层的主要协议有点对点协议PPP（Point-to-Point Protocol）、高级数据链路控制协议HDLC（High-Level Data Link Control）、以太网协议等。  
3. 网络层（Network Layer）：主要解决数据在网络中的传输问题，包括寻址、路由选择等。该层的主要协议有IP协议、网关协议（ARP）、路由协议（RIP、OSPF、BGP等）等。  
4. 传输层（Transport Layer）：提供端到端的可靠传输服务，包括数据传输控制、流量控制等。该层的主要协议有TCP协议、UDP协议、SCTP协议等。  
5. 会话层（Session Layer）：提供会话管理功能，负责建立、维护和结束会话。该层主要实现了不同计算机之间的会话控制，为高层协议提供一个传输数据的会话环境，该层的主要协议有NetBIOS等。  
6. 表示层（Presentation Layer）：负责数据格式的转换，确保应用层数据的格式一致。该层主要实现了数据格式的转换和数据加密解密等功能，如JPEG、MPEG等。  
7. 应用层（Application Layer）：提供应用程序之间的交互，包括文件传输、电子邮件、远程登录等。该层的主要协议有HTTP、FTP、SMTP、DNS、TELNET、SNMP等。
![[Pasted image 20241205223731.png|600]]

## 2. TCP/IP 五层模型和四层模型
四层：**应用层，传输层，网络层和网络接口层**（四层就是在五层的基础上将数据链路层和物理层合并成了网络接口层）
1. 应用层（Application Layer）：处理特定的应用程序，**如HTTP协议**、FTP协议等。
2. 传输层（Transport Layer）：建立端到端的连接，保证数据的完整性和可靠性，**如TCP协议**、**UDP协议等**。  
3. 网络层（Network Layer）：处理数据包的传输，确定网络地址，以及路由选择等，**如IP协议**、ICMP协议等。  
4. 数据链路层（Data Link Layer）：在物理层的基础上，定义了数据的格式、传输速率等，如以太网协议、Wi-Fi协议等。  
5. 物理层（Physical Layer）：定义物理设备标准，如网线、光纤、网卡等。  
![[Pasted image 20241208203017.png|400]]
## 3. TCP的粘包、拆包问题是什么？
#### 是什么？
TCP通信时，因为TCP是面向流的，所以发送方在传输数据时可能会**将多个小数据包粘合在一起进行发送**，而接收方可能**将这些数据包拆成多个小数据包进行接收**，从而导致数据接收错误、或者数据粘连问题。

主要出现在以下两种情况：
1. 发送方连续发送多个小数据包：TCP是基于流的协议，因此发送方可能**将多个小数据包组合成一个大数据包进行发送**，从而导致接收方在接收数据时**无法区分不同数据包的界限**。
2. 接收方缓存区大小限制：接收方在接收数据时，如果**接收缓存区大小有限，可能会将一个大数据包拆分成多个小数据包进行接收**，从而导致粘包和拆包问题出现。

>就是类似于发送「夏洛特烦恼」，接收方是无法区分发送的是「夏洛特+烦恼」，还是「夏洛+特烦恼」。
#### 如何解决？
对包的格式进行约束，有以下四种常见的解决方案：
1. **固定消息长度**：将业务层协议包的**长度固定**，当客户端发送数据长度不足固定长度，则通过添加空格补全。
2. **添加特殊字符作为边界**：在每个包的末尾**添加固定的分隔符**，如换行符\n，当拆分时，通过\n换行符连接不同包的拆分部分。
	- 例如HTTP协议利用回车符、换行符作为HTTP报文协议的边界。
3. **自定义消息结构**：仿照TCP/IP协议，将消息分为header和body，**在header中保存了当前整个消息的长度，只有读取到足够长度，才算一个完整消息**。
4. ~~通过自定义协议进行粘包和拆包处理。~~
## 4. ARP协议和RARP协议有什么区别？
ARP（Address Resolution Protocol）和RARP（Reverse Address Resolution Protocol）
二者都是网络通信协议，**用于IP地址和MAC地址的转换**。
#### 功能不同
- ARP协议：用于将IP地址转换为MAC地址。用于根据IP地址查询目标的MAC地址。
- RARP协议：用于将MAC地址转换为IP地址。需要知道本机IP地址时，可以向网络中发送RARP请求，**获取自己的IP地址**。
#### 工作方式不同
- ARP协议是**广播协议**，当一台主机需要知道另一台主机的MAC地址时，会在本地局域网上广播一个ARP请求包，所有主机都能接收该请求包，但只有目标主机会响应请求，发送自己的MAC地址。
	- 理解，ARP是获取MAC地址，自然是需要遍历所有主机才能获取MAC地址。
- RAPR协议，则是**向预定义的RARP服务器发出请求**，请求服务器返回本机IP地址。
	- 理解，已知MAC地址，相当于已知主机，那么只需要向该主机发送请求即可获取IP地址。
#### 用途不同
- 现代操作系统和网络设备都可以自动分配IP地址，因此鲜少使用RARP协议获取IP地址了。而ARP协议仍旧频繁使用，需要获取目标主机的MAC地址。
## 5. 路由器和交换机的区别是什么？
在OSI七层模型中，路由器主要工作在网络层，交换机主要工作在数据链路层。

- 路由器转发依据IP地址，交换机转发依据的是MAC地址。
- 交换机用于组建局域网，路由器用于将局域网相互连接，或者接入互联网。

## 6. 什么是TCP三次握手、四次挥手？
### 三次握手（建立连接）
![[Pasted image 20241208203458.png]]
TCP是面向连接的，所以使用TCP之前必须先建立连接，而建立连接通过三次握手实现。具体过程如下：
 - **客户端发送 SYN**，请求建立连接。
- **服务端回复 SYN + ACK**，同意连接并同步状态。
- **客户端发送 ACK**，确认连接建立。

TCP的连接建立要解决以下三个问题：
1. 使TCP双方能够**确认对方的存在**；
2. 使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 使TCP双方能够对运输实体资源（如缓存大小等）进行分配。

### 四次挥手（断开连接）
![[Pasted image 20250110215715.png]]
- **第一步（主动关闭方发送 FIN）：** 主动关闭方请求关闭连接。
- **第二步（被动关闭方发送 ACK）：** 被动关闭方确认请求，准备关闭。
- **第三步（被动关闭方发送 FIN）：** 被动关闭方请求关闭连接。
- **第四步（主动关闭方发送 ACK）：** 主动关闭方确认关闭，进入 `TIME_WAIT` 状态。
### 1. **TCP 三次握手（建立连接）**

**目标：** 确保通信双方都能正常发送和接收数据，建立可靠的连接。

**过程：**

1. **第一次握手（客户端 -> 服务端）：**  
    客户端发送一个带有 `SYN` 标志位的报文给服务端，表示请求建立连接，同时包含一个初始序列号 `seq = x`。  
    **作用：** 客户端发起连接请求。
2. **第二次握手（服务端 -> 客户端）：**  
    服务端收到客户端的 `SYN` 报文后，发送一个 `SYN+ACK` 报文给客户端，表示同意建立连接。
    - `SYN` 表示服务端愿意建立连接。
    - `ACK` 确认客户端的初始序列号，并返回 `ack = x+1`。  
        **作用：** 服务端确认收到连接请求，并向客户端发送自己的连接请求。
3. **第三次握手（客户端 -> 服务端）：**  
    客户端收到服务端的 `SYN+ACK` 报文后，发送一个 `ACK` 报文给服务端，确认服务端的序列号 `ack = y+1`。  
    **作用：** 客户端确认连接建立，双方进入 **ESTABLISHED** 状态。

**总结：** 三次握手的本质是为了确认：
- 双方的发送和接收能力正常。
- 双方的初始序列号已经交换，为后续可靠传输做好准备。
### 2. **TCP 四次挥手（断开连接）**

**目标：** 可靠地释放双方的资源，断开连接。

**过程：**
1. **第一次挥手（客户端 -> 服务端）：**  
    客户端发送一个 `FIN` 报文给服务端，表示数据发送完毕，请求断开连接。  
    **作用：** 客户端进入 **FIN_WAIT_1** 状态，等待服务端的确认。
2. **第二次挥手（服务端 -> 客户端）：**  
    服务端收到 `FIN` 报文后，返回一个 `ACK` 报文，表示收到断开请求。  
    **作用：** 服务端进入 **CLOSE_WAIT** 状态，客户端进入 **FIN_WAIT_2** 状态，等待服务端处理未完成的数据。
3. **第三次挥手（服务端 -> 客户端）：**  
    服务端处理完数据后，发送一个 `FIN` 报文，表示数据发送完毕，请求断开连接。  
    **作用：** 服务端进入 **LAST_ACK** 状态，等待客户端确认。
4. **第四次挥手（客户端 -> 服务端）：**  
    客户端收到服务端的 `FIN` 报文后，返回一个 `ACK` 报文，表示确认断开。
    - 客户端进入 **TIME_WAIT** 状态，等待一段时间（默认 2MSL，约 2 分钟）以保证服务端收到确认后完全关闭。
    - 服务端收到确认后进入 **CLOSED** 状态，释放连接资源。

**总结：** 四次挥手的设计目的是为了保证：
- 双方的数据都被完整传输，不会遗漏或丢失。
- 连接关闭后释放双方的资源。
## 7. 为什么需要三次握手？不能是两次吗？
简单来说，是为了防止超时失效的连接请求报文突然又传送到了TCP服务器，因而导致错误。

>**_The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.防止旧的重复连接初始化造成混乱。_**
## 8. 为什么需要四次挥手？
对于四次挥手，因为 TCP 是**全双工通信**，在主动关闭方发送 FIN 包后，**接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道**，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。

服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，**但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序**：
## 9. 第二次和第三次不能合并吗？
可以合并！当被动关闭方在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**【**捎带确认机制**】
## 10. 为什么TCP客户进程在发送完最后一个确认 报文段后还要等待2MSL才关闭？
假设普通的TCP确认报文段发送后，TCP客户端进入关闭状态。此时**TCP确认报文段在发送过程中丢失，此时TCP服务器会对TCP连接释放报文段进行超时重传，并仍处于最后确认状态**。然而此时由于TCP客户端处于关闭状态，因此无法接收该报文，导致TCP服务器对该报文不断超时重传， 并始终处于最后确认状态，无法进入关闭状态。

总结：2MSL可以**保证TCP服务器能收到最后一个TCP确认报文段并进入关闭状态**
## 11. 若TCP客户端发生故障，TCP服务端是如何发现故障并及时关闭的？
使用保活计时器实现。
- TCP服务器每接收到TCP客户端发送的一条数据，就重新设置并启动保活计时器（2小时）
- 若保活计时器定时周期内未收到TCP客户端发送的数据，则**计时器到时后，TCP服务器进程就会向TCP客户端发送一个探测报文段**，以后每隔75秒发送一次。若**一连发送10个探测报文仍无TCP客户进程的响应**，TCP服务器进程就认为TCP客户进程所在主机发生了故障，就会关闭该连接。
## 12. 为什么SYN=1的报文不可以携带数据？
根据 TCP 协议规范（[RFC 793](https://tools.ietf.org/html/rfc793)），`SYN` 报文用于初始化连接，其序列号占用一个序号位置，但不携带实际数据。如果 `SYN` 报文携带数据，接收方需要在连接完全建立之前处理这些数据，这与 TCP 标准的连接控制逻辑相违背。
## 13. TCP保证可靠传输，如何理解这个可靠性？
网络协议可靠，需要满足以下要求：
1. 数据完整性。
2. 数据顺序。
3. 不能重复。
4. 不能被篡改。
## 14. TCP是如何保证可靠传输的？
#### 可靠性理解
可靠性由以下几个方面：
1. 数据完整性：我发送123，对方接受也得是123，不能是13.
2. 数据顺序性：我发送123，对方接受也得是123，不能是132.
3. 不能重复：我发送123，不能接收成1233.
4. 不被篡改：我发送123，不能被篡改成456。
#### 可靠性保证
TCP将应用数据分割成TCP认为最适合发送的数据块。TCP给发送的每个包进行编号，接收方对数据包进行排序，将有序数据传送到应用层。

- **连接管理**：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。
- **序列号**：TCP将每个字节的数据都进行了编号，这就是序列号。序列号的具体作用如下：能够保证可靠性，既能防止数据丢失，又能避免数据重复。能够保证有序性，按照序列号顺序进行数据包还原。能够提高效率，基于序列号可实现多次发送，一次确认。
- **确认应答**：接收方接收数据之后，会回传ACK报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。在指定时间后，若发送端仍未收到确认应答，就会启动超时重传。
- **流量控制**：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，就会导致接收端的缓冲区溢出，进而导致丢包。为了避免上述情况的发生，TCP支持根据接收端的处理能力，来决定发送端的发送速度。这就是流量控制。流量控制是通过在TCP报文段首部维护一个滑动窗口来实现的。
- **拥塞控制**：拥塞控制就是当网络拥堵严重时，发送端减少数据发送。拥塞控制是通过发送端维护一个拥塞窗口来实现的。可以得出，发送端的发送速度，受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复。
- **超时重传**：超时重传主要有两种场景：数据包丢失：在指定时间后，若发送端仍未收到确认应答，就会启动超时重传，向接收端重新发送数据包。确认包丢失：当接收端收到重复数据(通过序列号进行识别)时将其丢弃，并重新回传ACK报文。

## 15. TCP的拥塞控制方法有哪些？
![[Pasted image 20250409234623.png]]
#### 慢启动
TCP连接刚建立好时，或者发生拥塞时，TCP会以较低的发送速率发送报文。慢启动机制会逐步增大拥塞窗口`CWND`，也就是每次的最大数据量，避免瞬时向网络注入过多数据。

- 初始时，CWND设为1个MSS（最大报文大小）
- 每收到一个ACK，都增加一个MSS；
- 通过指数级增长，慢启动会迅速增加发送速率，直到达到阈值`ssthresh`。
#### 拥塞避免
当cwnd达到慢启动阈值`ssthresh`后，TCP会进入拥塞避免阶段，此时数据发送速率变为线性增长。

- 此时每个RTT才增加一个1MSS，而不是每个ACK都增加。

当发送网络拥塞，进行**超时重传**后，又会进入慢启动阶段，并且将ssthresh设置为原先阈值的一半。
#### 快重传
快重传和快恢复算法是对慢开始和拥塞避免算法的改进，不依赖超时来检测数据包是否丢失，而是通过连续多个冗余的ACK来判断是否丢失。

当未按序接收时，此时只会对已按序接收的报文进行ACK确认。此时，当发送方收到三个连续相同的ACK后，会立即重传该丢失的数据包，而不必等待超时。
#### 快恢复
当检测到数据包丢失后，不会进入慢启动阶段，而是进入快恢复阶段。

- 快恢复阶段，会将`ssthresh`设置为cwnd的一半，同时将cwnd设置为ssthresh的值 + 3。
- 之后，会继续以线性增长的方式调整窗口，直到恢复正常速率。

## 16. 什么是HTTP/3的QUIC协议？
HTTP/2弃用的原因，就是仍然使用TCP协议。因此，HTTP/3的引入必然是要绕开TCP的影响，因此有了基于UDP的QUIC协议。

QUIC协议的特点：
1. 传输层：**基于UDP的传输层协议**。
2. 可靠性：在UDP的基础上做了改造，实现了与TCP类似的可靠性（通过拥塞控制、数据包重传等手段）；
3. 并发无序：实现了无序、并发的字节流。单个数据流传输是按序的，而多个数据流传输的乱序的；
4. 快速握手：提供0-RTT和1-RTT的连接建立；
5. 安全：使用TLS 1.3 传输层安全协议。

## 17. 为什么需要HTTP/2，解决了什么问题？TODO
HTTP/2主要解决了HTTP/1中存在的效率问题，引入了二进制分帧、多路复用、header压缩、以及服务器推送等新特性，大大提高了效率。并且，HTTP/2还解决了一个重要问题，就是HTTP的队头阻塞问题。
### 效率问题
#### 二进制分帧
在应用层和传输层之间引入了一层：二进制分帧层。

二进制分帧层会将所有传输的信息分割为更小的消息和帧（frame），并对其使用二进制形式进行编码。
#### 多路复用
#### header压缩
#### 服务器推送
### 队头阻塞问题
## 18. HTTP/2存在什么问题，为什么需要HTTP/3？
## 19. HTTP和HTTPS的区别是什么？
HTTPS在HTTP的基础上，利用SSL/TLS加密数据包。

区别在以下几点：
1. 安全性：
	- HTTP使用明文传输。
	- HTTPS使用SSL或者TLS进行加密数据传输。
2. 默认端口不同：
	- HTTP默认端口为80；
	- HTTPS默认端口为443.
3. URL地址不同：
	- 前者为HTTP，后者为HTTPS.

SSL各个版本都存在安全漏洞，目前用的比较少
TLS 1.2和TLS 1.3是目前最广泛使用的版本，因为它们提供更高的安全性，引入了更有效的加密算法和协议优化。
## 20. 说说 TCP 和 UDP 的区别？
- **连接**：
	- TCP 是面向连接的传输层协议，传输数据前先要通过三次握手建立连接，并在结束后通过四次握手断开连接；
	- UDP 是不需要连接，即刻传输数据。
- **可靠性**：
	- TCP 是可靠交付数据的，通过确认和重传机制保证数据的正确送达。
	- UDP 是尽最大努力交付，发送数据但不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。
- **拥塞控制、流量控制**：
	- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
	- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
- **传输方式**：
	- TCP 是流式传输，没有边界，但保证顺序和可靠。
	- UDP 是报文传输，一个包一个包的发送，是有边界的，但可能会丢包和乱序。
- **首部开销**：
	- TCP 首部长度较长，最小为20字节，包含更多控制信息。
	- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
- **使用场景**：
	- TCP通常用于高可靠性的应用，如网页浏览、电子邮件、文件传输等；
	- UDP适用于实时应用，如视频流、语音通话等。
## 21. Cookie，Session，Token的区别是什么？
- cookie是存储于浏览器端的一小段文本数据，后续请求中，cookie会随着http请求一同发送到服务端。
- session是一种在服务端保存用户状态信息的机制，可以用于存储用户信息等资源，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。
- token类似一个令牌，是一种用于身份验证的字符串，通常由服务器生成并发送到客户端。用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。
## 22. ⭐浏览器输入`www.baidu.com`回车之后发生了什么？
- **解析URL**：分析 URL 所需要使用的传输协议和请求的资源路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。
- **缓存判断**：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。
- **DNS解析**：如果资源不在本地缓存，首先需要进行DNS解析。浏览器会向本地DNS服务器发送域名解析请求，本地DNS服务器会逐级查询，最终找到对应的IP地址。
- **获取MAC地址**：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
- **建立TCP连接**：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器转发，等路由器转到目标服务器后，服务器回复一个SYN-ACK包，确认连接请求。然后，主机发送一个ACK包，确认已收到服务器的确认，然后 TCP 连接建立完成。
- **HTTPS 的 TLS 四次握手**：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的四次握手。
- **发送HTTP请求**：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。
- **服务器处理请求并返回响应**：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。
## 23. 键入网址到网页显示，期间发生了什么？TODO
#### 1. 解析URL，生成HTTP请求

#### 2. 查询DNS服务器，获取域名对应IP地址
先查浏览器缓存，再查操作系统缓存，再查hosts文件，最后才回去DNS服务器查询。
#### 3. 
## 24. 对称加密和非对称加密有什么区别？
#### 是什么？
- 对称加密，指的是加密和解密使用**相同秘钥**的加密算法。对称加密可以通过加密后的密文，再根据密钥还原出明文。
- 非对称加密，指的是**加密和解密使用不同密钥的加密算法**，也称为公私钥加密。

**HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段**
## 25. 简单介绍一下DNS
DNS全称Domain Name System，域名系统。 DNS是作为一个**将域名和IP地址相互映射的分布式数据库**，使得用户能更方便地访问互联网。

DNS最主要的作用就是**将域名翻译成IP地址**。因为为了方便记忆，都是将IP地址映射成由点分隔的字符组成的域名，用户可以通过直接访问域名来代替IP地址，DNS就是处理域名与IP地址相互映射的工具。
#### DNS污染
>DNS污染是指把自己伪装成DNS服务器，在检查到用户访问某些网站后，使域名解析到错误的IP地址。

是指刻意制造或无意中制造出来的域名服务器数据包，把域名指向不正确的IP地址。

DNS查询是无认证的，并且通常是基于UDP的无连接不可靠协议，因此DNS的查询很容易被篡改。通过对UDP的端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的情况则立即伪装成目标域名的解析服务器，给查询者返回虚假结果。
#### DNS劫持
>DNS劫持指的是通过非法手段，获取DNS服务器的权限，然后把DNS配置进行修改，使域名解析到错误的IP地址。

又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，效果就是对特定的网络不能访问或者访问的是假网址。
#### 二者区别
DNS劫持是劫持了DNS服务器，DNS污染是伪装成DNS服务器。
## 26. 域名结构
因特网采用层次树状结构的域名结构。域名的结构由若干个变量组成，各分量之间"点"隔开，分别代表不同级别的域名。

```
....三级域名.二级域名.顶级域名
```
- 每一级域名都由英文字母和数字组成，不超过63个字符；
- 域名级别从左往右递增。
- 完整域名不超过255个字符。
## 27. 域名服务器
DNS使用分布在各地的域名服务器来存储域名到IP地址的转换。域名服务器一共可划分为4种不同类型：
#### 1. 根域名服务器：
- 每个根域名服务器都知道所有顶级域名服务器和对应IP地址。一共有13个根域名服务器，每个根域名服务器都由服务器集群构成。用户查询时会将请求转发到最近的域名服务器中。
- 根域名服务器不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。
#### 2. 顶级域名服务器：

#### 3. 权威域名服务器
#### 4. 本地域名服务器
不属于上述域名服务器的等级结构，主要起代理作用。当主机发出DNS请求后，首先被送往主机的本地域名服务器，然后本地域名服务器会将报文转发到上述域名服务器中。
## 28. DNS的解析过程是怎样的？
分为递归查询和迭代查询。
先查询本地缓存和HOST绑定，再向本地DNS服务器发送查询请求，最后向根服务器发送请求。
1. 首先在自己的本地缓存或hosts文件中查找域名对应的IP地址（主机和本地域名服务器都有缓存）；
2. 其次会在网络中的某台DNS服务器中查询；

#### 递归查询
![[Pasted image 20250410012144.png|550]]
#### 迭代查询
通过迭代查询，逐步寻找到权威域名服务器，从而获取到域名所对应的IP地址。
![[Pasted image 20250410012217.png|550]]
![[Pasted image 20250409002304.png]]
#### DNS污染
刻意制造或无意中制造的域名服务器数据包，将域名指向不正确的IP地址。
#### DNS劫持

#### DNS劫持与DNS污染的区别？
## 29. Ping的原理是什么？
ping用于探测本机与网络中的另一台主机是否可达。利用Ping命令可以检查网络是否畅通以及网络连接速度。

Ping是基于**ICMP协议**（Internet Control Messages Protocol）来工作的，即**因特网信报控制协议**）。Ping利用了ICMP的两种控制消息：echo request回显请求和echo reply回显应答。主机A执行Ping时，就会发送回显请求，主机B正确接收后会返回回显应答，通过对方回复的数据包来确定两台网络机器是否相同、以及时延是多少。

PING命令本身处于应用层，而ICMP是网络层协议，因此PING命令是一个**应用层直接使用网络层**的例子。
## 30. 为什么ping不需要端口？
因为ping命令是基于ICMP协议，是应用层直接使用网络层的情况，因此不涉及到传输层，所以不需要指定端口号。

>端口号是传输层（TCP/UDP）的一部分，用于区分同一IP地址上的多个服务或应用程序。
## 31. 断网了还能ping通127.0.0.1吗？
可以。

127开头的属于回环地址。
## 32. 如何解决跨域问题？
跨域访问问题（Cross-Origin Resource Sharing，CORS）是由浏览器同源策略引发的，它要求网页中的所有资源必须来自同一个域名、协议和端口，否则浏览器会阻止跨域的资源请求。

#### 解决办法
1. **CORS**：CORS是目前最常见的解决跨域问题的方案，通过在服务端设置相应的响应头来解决跨域问题。服务器在响应中添加Access-Control-Allow-Origin头，指定允许跨域访问的域名或通配符*，使得浏览器可以放行跨域请求。
2. 
3. **代理服务器**：在同源域名下设置代理服务器实现跨域访问。前端将请求发送给代理服务器，通过代理服务器转发给目标服务器，并将响应返回给前端。
## 33. CDN是什么，为什么可以做缓存？
CDN是Content Delivery Network的缩写，翻译成**内容分发网络**。主要通过**将内容存储在全国各地的边缘节点，以就近原则向用户提供内容**。

CDN可以做缓存是因为它在全球范围内部署了多个边缘节点，这些节点分布在不同的地理位置，靠近用户所在的区域。当用户请求某个资源（例如网页、图片、视频等），CDN会根据用户的位置，**将资源从最近的边缘节点提供给用户**。

用户首次访问这些资源的时候，**CDN会将资源从服务器获取到，并将其缓存到边缘节点上**。当其他用户在同一地区请求相同的资源时，CDN会直接从边缘节点返回缓存的副本，而不必再次访问源服务器。这样可以减少网络延迟和带宽消耗，提高内容的传输速度和响应性能。
## 34. 什么是长连接和短连接？
#### 短连接
- 客户端和服务器之间的连接在每次请求完毕后立即关闭，下一次请求重新建立连接。
- 优点：
	- 节约服务器资源，也能避免服务器长时间维护过多连接。
- 缺点：
	- 每次请求都需要重新建立连接，有很多额外的性能开销。
#### 长连接
- 客户端与服务端建立TCP连接后，保持连接状态，允许复用一个连接进行多次请求和响应。
- 优点：
	- 避免频繁建立和关闭TCP连接的开销，提高性能。
- 缺点：
	- 服务器需要维护大量连接，导致资源占用增加；
	- 连接可能因超时而断开，需要心跳检测（KeepAlive机制）来维持连接。   
## 35. 有了HTTP协议，为什么还要有RPC协议？
- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式【远程过程调用】**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员**能像调用本地方法那样去调用远端的服务方法**。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议【基于UDP协议也行】**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## 36. 有了HTTP协议，为什么还要有WebSocket？
- HTTP协议是半双工的，对于需要双向通信，尤其是服务器主动向客户端推送数据的场景不友好；而WebSocket是全双工的，支持建立连接后服务器与客户端的双向通信。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。【本质还是客户端主动请求服务端数据】
	- **【定时轮询】**：基于HTTP协议可以实现**伪推送**模式，就是前端在用户无感知的情况下不断向后端发送请求，服务器收到请求后向客户端返回数据。但是会有延迟，因为前端请求可能是每1~2秒发送。【定时轮询】
	- **【长轮询】**：将HTTP请求的超时时间延长，例如由3秒延长至30秒，此时只要服务器收到了用户的扫码请求，就立刻返回数据给客户端。若超时，则立马再发送请求，建立长轮询。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
## 37. 正向代理和反向代理
#### 正向代理 - 代理用户的请求
位于客户端和服务端之间的服务器（代理服务器），为了从目标服务器获取内容，客户端向代理服务器发送请求，代理会转发请求到目标服务器，并将内容返回给客户端。

- 翻墙就是正向代理技术。
- 通过正向代理，目标服务器不会知道客户端是谁。
#### 反向代理 - 代理服务器接受请求
以代理服务器接收Internet的连接请求，并将连接请求转发到内部网络上的服务器，并服务器上获得的结果返回给Internet上连接的客户端。

- 例如负载均衡就是反向代理，将客户端请求转发到不同的服务器上，再把执行结果返回给客户端。
- 客户端不知道自己访问的是代理服务器，也不知道真正的目标服务器是谁。

#### 二者区别
- 正向代理是客户端的代理；反向代理是服务器的代理。
- 正向代理主要用于解决访问限制；反向代理主要提供负载均衡、安全防护等作用。
