# <font color="#245bdb">MySQL基础</font>
## 1. SQL和NOSQL的区别?
> [!abstract] 摘要
> 1. 存储方式不同

前者是关系型数据库，常见的有MySQL、Oracle、SQL Server等。关系型数据库存储结构化数据，逻辑上以二维列表存在，每一行代表一个数据记录，每一列代表一个数据属性。

后者是非关系型数据库，常见的有Redis、MongoDB等，存储方式可以是JSON文档、哈希表等方式。

## 2. 数据库三大范式是什么?
>[!abstract] 摘要
>1. 原子性；2. 每条记录都可被唯一区分；3. 字段不相互依赖。
1. 数据库表每一列都不可再分，具有原子性，例如地址，可以拆分为省份、市区等。
2. 数据库表中的每个实例或记录都可被唯一区分，即需要有主键。
3. 任何非主属性不依赖于其他非主属性，即非主键外字段必须互不依赖。

**反范式**：例如冗余字段，虽然违反了第三范式，使得非主键外的其他字段形成了相互依赖，但是这样避免了联表查询，用空间换时间，提高了查询效率。


## 3. Char和Varchar的区别?
> [!abstract] 摘要
> 1. 定长与非定长；
> 2. 丢失空格信息。

### char类型:
char是固定长度的字符串类型，定义时指定长度，存储时会在末尾补空格来填充至指定长度。
**优点：** 
1. 适合存储固定长度的数据，例如身份证等。
2. 无需额外的磁盘空间来存储长度信息；
3. **不会产生内存碎片**

**缺点：**
1. char类型会导致末尾空格数据丢失，如`"chanxin   "`会被填充至`"chanxin        "`，导致无法获取原本有几个空格；
2. 会浪费存储空间。
### varchar类型
varchar是可变长度的字符串类型，定义时需要指定最大长度。存储占用空间取决于字符串实际长度。
**优点：**
1. 节约存储空间；

**缺点：**
1. **会产生内存碎片。**
	- varchar(100)，假设存储的数据为51字节（包括50字节的字符串与1字节的长度信息），那么当该数据更新了，导致占用内存增加了，但是此时数据页无法扩展出新空间所以无法覆盖到原来位置，就会发生页分裂。
2. 需要额外1~2个字节(超过255字节则需要2个字节)来存储数据长度信息。
## 4. 什么是隐式类型转换？
当不同数据类型的值进行运算或比较时，会发生隐式数据类型转换。

## 5. 说一下外键约束。
> [!abstract] 摘要
> 1. 是什么？
> 2. 作用：维护一致性和完整性。

外键是用于建立表之间关系的，定义了**表中的某一列或某几个列，这些列的值必须在另一个表中作为主键出现**。作用是维护表中的数据一致性和完整性。

**一致性：** 向表中插入的数据，必须在另一张表中也存在。
**完整性：** 级联删除。

## 6. 为什么不推荐使用外键?
> [!abstract] 摘要
> 1. 需要额外检测；
> 2. 不适用于分库分表。

1. **性能问题**：每次执行DML语句都需要额外检测外键约束的完整性，降低了更新性能；
2. **无法适应分库分表**：分库分表环境中，数据存在于不同的数据库中，外键难以跨越数据库来建立关系。并且，分库分表环境中，数据的一致性更难维护。

## 7. 执行一条SQL请求的过程是什么?
> [!abstract] 摘要
> 1. 连接与鉴权；
> 2. 缓存；
> 3. 解析与预处理；
> 4. 优化；
> 5. 执行。

1. **连接与鉴权**：使用**连接器**，通过客户端/服务器通信协议与MySQL建立连接，并查询判断是否有权限；
2. **缓存**：在MySQL8.0之前，还会查询是否开启缓存，若开启且命中缓存，则直接返回查询结果；
3. **解析与预处理**：由**解析器**进行词法与语法分析，并生成解析树。**预处理器**会根据MySQL规则进一步分析解析树是否合法，如**表或列是否存在**。
4. **优化**：由**优化器**来生成执行计划，并根据索引看看是否能优化，选择查询成本最小的计划。
	- 执行EXPLAIN语句获取的就是执行计划。
5. **执行**：**执行器**来**操作存储引擎执行SQL语句**，获得查询结果并返回。同时，若开启缓存，在返回前还会将结果存储于缓存中。
## 8. 一条update语句是如何执行的?
1. **查询**：首先查询缓冲池buffer pool，判断需要查询的数据是否在缓冲池的内存页中；若在，则直接进行查询，若不在，则需要从磁盘中中读取内存页到缓冲池中；
2. **写Undo log**：在修改操作前，将旧数据写入undo log中，以便后续事务失败时进行回滚获取原数据。undo log是先写入到内存中，后续由Purge线程定时刷新到磁盘中（进行清理）。
3. **更新**：更新buffer pool中的数据，此时数据所在的内存页也被标记为脏页；后续会由Page Cleaner Thread刷脏页，将脏页数据持久化到磁盘中。
4. **写bin log**：至此，更新操作执行完毕，然后会将修改写入binlog，并保存到binlog cache中；（此时尚未持久化到磁盘中）
5. **两阶段提交**：最后是事务的两阶段提交：①写redo log，并将其标记为准备阶段；②然后是将binlog持久化到磁盘中；③最后是写redolog，将redo log持久化到磁盘中并标记为commit状态。

## 9. SQL语句如何实现insertOrUpdate功能?

使用`INSERT INTO ... ON DUPLICATE KEY UPDATE;`，如果数据库中已存在具有相同主键或唯一索引的记录，则更新记录，否则插入记录。

**需要满足以下条件：**
1. 表必须有主键或唯一索引；
2. 插入的数据必须包含主键或唯一索引列；
3. 主键或唯一索引列的值不能为 NULL。

**举例：**
```SQL
INSERT INTO student (id, name, age) VALUES (1, 'Alice', 20)
ON DUPLICATE KEY UPDATE name='Alice', age=20;
```

**实现原理：**
1. 首先尝试插入新行，在插入过程中会检查表中是否存在与新插入的数据相同的主键或者唯一索引；
2. 若无，则直接插入新记录；若存在冲突，则执行更新操作；
3. 根据`ON DUPLIACATE KEY`后面的字段与对应值执行更新操作。

## 10. 说说SQL的语法树解析。
语法树（或抽象语法树，AST）是 SQL 解析过程中的中间表示，它**使用树形结构表示 SQL 语句的层次和逻辑**。

**构成：**
- 根节点：SQL语句的操作，SELECT、UPDATE、DELETE、INSERT等；
- 内部节点：操作符、子查询、连接操作等，如WHERE子句、JOIN操作等
- 叶子节点：具体的标识符，常量、列名、表名等，

## 11. 介绍MySQL的三种存储引擎
> [!abstract] 摘要
> 1. 三种引擎；（发音：My-i-Sam)
> 2. 事务、锁的粒度、外键；
> 3. （可补充）行数保存、清空方式。

|          |     InnoDB     |    MyISAM     |     |
| :------: | :------------: | :-----------: | :-: |
|  **事务**  |       支持       |      不支持      |     |
|  **外键**  |       支持       |      不支持      |     |
| **聚簇索引** |       支持       |      不支持      |     |
| **锁级别**  |   支持行级锁、表级锁    |      表级锁      |     |
| **行数保存** | 不支持<br>需要扫描整张表 | 支持<br>有字段保存行数 |     |
| **清空方式** |      逐行删除      |      重建表      |     |
| **默认版本** |     5.5 之后     |    5.5 之前     |     |
| **全文索引** |    5.6以后支持     |      支持       |     |
InnoDB适合频繁修改以及需要更高安全性的应用；MyISAM则适合查询较多的场景。
## 12. 为什么不建议使用多表join？
因为join使用了**嵌套循环**实现关联查询，因此效率比较低。

**嵌套循环算法：**
- **simple nested loop**：全量扫描两张表作关联；
- **index nested loop**：如果内循环的表中字段有索引，则可以用到索引进行查询然后作关联；
- **block nested loop**：引入buffer，把外循环的一部分结果放到JOIN Buffer中，然后内循环的每一行与buffer数据作比较。因为是基于内存，所以效率更高。

**不用JOIN作关联查询的方法：**
1. **在内存中作关联**：在代码中进行二次查询然后作关联。
2. **数据冗余**：添加冗余字段，避免联表查询。【反范式】![[Pasted image 20241220220334.png]]
![[Pasted image 20241220220156.png]]

## 13. ORDER BY是如何实现的？^

## 14. limit 0,100和limit 10000000,100一样吗？^
不一样！后者是典型的深分页问题。
`LIMIT M N`的原理是读取0~N条数据，然后舍弃前M条，返回M~N条数据。

**优化方法：**
- 

## 15. MySQL一般有几层？能容纳多少数据量？
$存储总记录数=指针数目\times单个叶子节点记录条数$

考虑两层的情况，单页大小（单个节点）为16KB。
- 对于非叶节点，主键大小为bigint（8字节），指针大小默认为6字节，那么单个节点可以存储的指针数为$\frac{16KB\times1024}{14}=1170$ 。
- 对于叶子节点，假设一行记录的大小是1KB，那么1页（1个节点）可以存储16条数据。
- 因此，非叶节点每个指针指向一个叶子节点，则一共可以存储$1170\times16=18720$条数据。
- 则若是三层，可以存储$1170\times1170\times16=21,902,400$条
# <font color="#245bdb">索引</font>
## 1. 索引是什么? 有什么好处?
> [!abstract] 摘要
> 1. 数据结构
> 2. 降低时间复杂度。

索引是一种数据结构，可以减少查询时扫描的数据量，提高查询速度。

## 2. MySQL的索引是怎么实现的?
> [!abstract] 摘要
> 1. B+树；
> 2. B+树结构：叶节点/非叶结点存储、双向链表。
> 3. 好处。

InnoDB引擎采用了B+树作为了索引的数据结构。
- 平衡树，查找效率较高；
- 非叶节点不存储实际数据，因此可以存储更多的索引数据；
- 非叶节点使用前后指针连接
- 叶子节点通过双向链表链接，方便进行范围查询。
B+树是一种多叉树，非叶结点只存储索引，叶子节点存储数据和用于链接节点的前后指针。
由于非叶结点只存储索引，所以相对B树和二叉树，树的高度更低，因此磁盘I/O次数更少，查询效率更更高。

>`千万数据只需要3-4层高度即可满足。`
>1个内存页16KB，假设一个索引键值16字节，那么一个结点（内存页）占用$1024\times16/16=1024$个键值。

## 3. 聚簇索引和非聚簇索引的区别是什么?
> [!abstract] 摘要
> 1. 叶子节点所存储的数据不同；
> 2. 是否能获得完整数据；
> 3. 唯一性。

1. 聚簇索引也叫主键索引，非聚簇索引也叫二级索引。
2. **数据存储**：聚簇索引的叶子结点包含了索引主键和对应的整行数据；而非聚簇索引的叶子结点不包含完整数据，只包含对应指向该行数据的主键值。
3. **索引和数据的关系**：进行查询时，通过聚簇索引可以直接获取完整数据；而通过非聚簇索引查询，若查询了索引字段之外的字段，还需要回表查询。
4. **唯一性**：聚簇索引通常是基于主键构建的，因此每一个表只能有一个聚簇索引；而非聚簇索引，一个表可以有多个。

## 4. 若表中不含主键，会如何构建聚簇索引？
> [!abstract] 摘要
> 1. 不为空的unique索引；
> 2. 隐藏主键rowid

若表中不包含主键，那么首先会使用**①不为空的unique唯一索引**来作为聚簇索引。
若也不存在，则会选择**②隐藏主键rowid**作为聚簇索引。
[[#rowid是什么?]]

### rowid是什么?
> [!abstract] 摘要
> 1. 内部自动生成的隐藏自增列；
> 2. 行的唯一标识符；
> 3. 作用：快速定位。

rowid 是一个特殊的隐藏自增列，**它为表中的每一行分配一个唯一的标识符**。这个标识符是内部生成的，通常用于快速定位和访问表中的具体行，**提供了一个快速访问行的机制**。

## 5. 什么字段适合作为主键?
> [!abstract] 摘要
> 1. 唯一性，非空；
> 2. 自增，减少页分裂和内存碎片。
> 3. （通过自增id引出分布式id）

1. 主键字段具有唯一性，且不能为空。
2. 最好具有递增趋势，这样能减少插入删除带来的页分裂和内存碎片。
3. 不建议使用业务数据作为主键，因为无法预测业务字段未来是否会重用；
4. 通常采用自增id作为主键，但仅限于单机系统。对于分布式系统，需要采用分布式id方案。

## 6. 采用UUID和自增id作为主键，哪个好?/自增id作为主键的优点.
> [!abstract] 摘要
> 1. 占用内存；
> 2. 安全性；
> 3. 查询效率；
> 4. 写入效率：索引重排、页分裂。

### UUID:
UUID 是一个 128 位长的唯一标识符，通常以字符串形式表示。
**优点：**
1. **全局唯一**：采用不同算法生成，几乎可以保证全球范围内唯一，避免了多台机器之间的主键冲突问题，因此也适用于分布式系统。
2. **不可预测性**：随机生成，很难被猜测出来，安全性较高。

**缺点：**
1. **占用空间大**：通常以字符串形式存储，占用空间比较大；
2. **不适合范围查询**：UUID不是自增的，所以不支持范围查询。范围查询通常是依赖于主键的顺序性来快速定位数据，如果主键非自增，通常需要扫描更多的数据来确认数据是否在指定范围内。
3. **效率低**：
	1. **查询效率低**：UUID作为主键创建索引时，因为UUID占用16个字节，相比于主键id，会占用更多的内存空间，导致内存页所能包含的数据更少，因此增加了磁盘I/O的需求，导致查询效率低。
	2. **写入效率低**：由于UUID是随机生成的，不具有自增性。因此新的UUID可能会插入到叶子结点的中间位置，导致索引页分裂和更多的I/O操作，影响了写入性能。（同时，数据分布在不同的内存页，也影响了查询性能。）

### 自增ID:
**优点：**
1. **占用空间小**：自增ID是数字，占用内存远小于UUID，节省存储空间；
2. **顺序插入，减少页分裂**：ID是递增的，新记录一般插入在索引页的末尾，避免了随机写入带来的页分裂和性能开销；
3. **查询效率高**：ID自增，索引中的数据存储顺序和值一致。
	- 因此。进行范围查询时可以更快定位范围的起始点，提高查询效率；
	- 在物理存储上记录也较为连续，减少IO
4. **分页方便**：id连续自增，通过 `id > ? LIMIT ?` 的方式分页可以解决深度分页问题；
5. **索引效率**：保证索引顺序和插入顺序相同，减少了索引重排，提高了插入速度。

**缺点：**
1. **分库分表**：分库分表时，没办法依赖于单表的自增主键来做主键id，因为可能会发生重复；
2. **可预测**：ID是顺序自增的，所以是可预测的；
	- 例如竞对利用自增id获取订单量。
3. **可能用尽**：自增id的数据类型是int(4字节)或者bigint(8字节)，可能会存在用完的情况。

## 7. MySQL主键一定是自增的吗?
不一定。只是一般采用自增id作为主键，这样有几个好处：
1. 自增id是顺序插入的，可以**减少插入删除时的页分裂、页合并等问题**，提高写入性能；
2. 由于是顺序插入的，所以物理存储上也是连续的，因此范围查询时效率更高。


---
## 8. 联合索引的实现原理
> [!abstract] 摘要
> 1. 多字段构建索引；
> 2. 依次排序。

多个字段一起构造一个索引。
联合索引的key值是字段的值，先按首个字段排序，若首字段相等，再按照第二个字段排序。

联合索引遵循最左匹配原则。例如(a,b,c)构建联合索引，则使用索引时必须带a，并且与顺序无关，a可以在后面，因为优化器在构建执行计划时会进行优化。

## 9. 索引失效有哪些?
> [!abstract] 摘要
>1. 模糊查询（不符合前缀）；
>2. 使用了聚合函数；
>3. 不符合最左匹配；
>4. 类型转换。

1. 模糊查询，如`like %xx`或者`like %xx%`；
2. 使用函数；
3. 表达式计算；
4. 字符串类型未带''，导致发生了类型转换；
5. 不遵循最左匹配原则，导致联合索引失效；
6. **WHERE语句中，如果OR前是索引列，而OR后的条件不是索引列，那么条件会失效。**

## 10. 什么是覆盖索引?
> [!abstract] 摘要
> 1. 走非主键索引；
> 2. 无需回表。

覆盖索引是指在使用非主键索引进行查找时，由于**叶子结点中包含所以需要查询的字段**，因此不需要回表查询，减少访问内存页次数，提高查询性能。

## 11. 什么是前缀索引?
> [!abstract] 摘要
> 1. 使用前n个字段作为索引；
> 2. 好处：增加单个结点所能存储的索引数量；
> 3. （如何选择：计算区分度。）
> 4. （缺点：不能用于覆盖索引）

使用前缀索引是取字段的前n个字符作为索引，减少索引字段大小，以增加一个内存页中所能存储的索引数量，提高查询性能。例如存储用户的邮箱，就可以只选择前n个长度的字符作为索引，最终长度可以通过计算区分度来决定
```MySQL
SELECT COUNT(DISTINCT LEFT(email, 4)) AS L4,
       COUNT(DISTINCT LEFT(email, 5)) AS L5,
       COUNT(DISTINCT LEFT(email, 6)) AS L6,
       COUNT(DISTINCT LEFT(email, 7)) AS L7
FROM users;
```

## 12. 什么是索引下推(Index Condition Pushdown)?
> [!abstract] 摘要
> 1. **前提：** 多个查询条件为联合索引，举例Where A = xx And B like xx;
> 2. 将部分条件判断从Server层下推到引擎层。
> 3. 减少回表次数。

允许**在访问索引时对数据进行过滤**，从而减少回表的次数。

people表中（zipcode，lastname，firstname）构成一个联合索引（前提），执行查询语句：
`SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;`
- 若没有索引下推优化机制，首先会通过索引获取`zipcode='95054'`查找到相应记录，并通过**主键回表判断后两个条件是否符合条件；**
- MySQL5.6引入索引下推优化后，MySQL会在查询号zipcode='95054'记录后，立刻**检查WHERE条件是否可以通过索引中的列进行判断**，只有当全部条件满足，才会使用主键定位并回表查询获取完整行记录。

总结，索引下推就是通过**将部分条件判断==从Server层下推到存储引擎层==进行处理**，有效减少回表次数，提高查询性能。
![[Pasted image 20241204200241.png|650]]
![[Pasted image 20241119223926.png|400]]

## 13. 什么是索引跳跃扫描(Index Skip Scan)?  TODO

**MySQL8.0.13**引入的新特性，对于range查询，**支持不符合连锁索引最左前缀匹配的SQL依然能够使用联合索引**，减少不必要的扫描，提高查询效率。

**优化原理：**
构建联合索引(f1,f2)，执行查询语句：`SELECT f1, f2 FROM t1 WHERE f2 = 40;`
通过获取f1字段的所有唯一值，然后进行范围查询，最后合并所有查询结果。
```SQL
SELECT f1, f2 FROM t1 WHERE f1 =1 and f2 = 40
UNION
SELECT f1, f2 FROM t1 WHERE f1 =2 and f2 = 40;
```

但是，当f1字段的区分度比较高时，需要扫描的行数还是会很多，此时查询还是会很慢。

## 14. MySQL为什么会选错索引?^

---
# <font color="#245bdb">事务</font>
## 1. 什么是数据库事务?
>[!abstract] 摘要
>1. 一条或多条SQL组成的执行单元，要么全部成功，要么全部失败；
>2. 四大属性ACID的介绍。

**数据库事务( transaction)是一条或多条SQL组层的执行单元**。事务应该具有四大属性：ACID.Atomic(原子性),Consistency(一致性),Isolation(隔离性),Durability(持久性)。

- Atomic：事务作为整体被执行，要么全部成功，要么全部失败。
- Consistency：数据库总是从一个一致性的状态转换到另一个一致性的状态。
	- 假设有一个订单系统，订单金额必须与库存中的商品价格相匹配。如果在处理订单时**发现价格不一致，则该事务将被回滚**，以保持数据的一致性。
- Isolation：多个事务并发执行时，一个事务的执行不应该影响另外一个事务的执行。
- Durability：一个事务一旦提交，修改应该永久保存到数据库中。

## 2. ACID是如何保证的？

1. 原子性：通过undo log来保证，事务失败时可以回滚。
2. 一致性：其他三个满足了，自然也就满足。
3. 隔离性：通过MVCC+版本号来实现；
4. 持久性：通过redo log和bin log来保证。

## MySQL如何开启事务？
`BEGIN`或`START TRANSACTION;`：开启事务；
`COMMIT`：提交事务；
`ROLLBACK`：回滚事务。
## 3. MySQL可能出现什么并发安全问题?
>[!abstract] 摘要
>均为事务的行为。
### 脏读:
一个事务读取到了另一个事务**未提交的变更**。
### 不可重复读:
在一个事务内多次读取同一个数据，出现**数据前后不一致**的情况。
### 幻读:
在一个事务内多次查询某个符合查询条件的记录数量，出现前后查询的**数量不一致**。
## 4. InnoDB如何解决脏读、不可重复读和幻读的？
- **脏读**：通过MVCC解决。在每一次SELECT语句时都会创建一个Read View，只会读取当前已提交的数据版本。
- **不可重复读**：通过MVCC解决。在第一次SELECT语句时创建Read View，后续所有的快照读都是读的第一次生成的Read View中的数据。
- **幻读**：通过MVCC+间隙锁解决，但不可完全避免。通过Gap Lock锁定索引范围，防止其他事务在范围内插入数据。
## 5. 事务的隔离级别有哪些?都是如何实现的?
>[!abstract] 摘要
>1. 当前读；
>2. Read View（不同时期创建）；
>3. 锁
1. **读未提交**：可以读取到其他事务还未提交的变更。
	- 读取最新版本的数据。
2. **读已提交**：可以读取到其他事务已提交的变更。
	- 通过创建Read View实现，在每个语句执行前都会生成一个Read View。
3. **可重复读**：事务内前后查询的数据保持一致，与事务启动时看到的数据一致。
	- 通过创建Read View实现，在第一个读请求时创建Read View。
4. **串行化**：事务是串行进行，当某个数据被多个事务读写时，后面请求的事务会处于阻塞等待状态。
	- 通过对数据加读写锁实现。

## 6. 可重复读隔离级别下，A提交的事务，B可以看见吗?
>[!abstract] 摘要
>1. MVCC保证：Read View + undo log

看不见。RR级别下，事务启动时会创建一致性视图，即使事务更新了数据并提交，事务B也可以通过undo log进行回滚，读取创建一致性事务时的数据。

## 7. ==解释下RR级别下的幻读问题。==^
RR级别下，通过MVCC和间隙锁避免了大部分的幻读问题，但还是会有小部分幻读问题的发生。

**举例：**
1. RR级别下，事务A开启事务，执行查询语句开启快照读；此时事务B新插入记录并提交；事务A再对新插入的数据进行更新，此时更新成功，说明发生了幻读。
2. RR级别下，事务A开启事务，执行查询语句开启快照读；此时事务B新插入记录并提交；事务A再对新插入的数据进行更新，此时更新成功，说明发生了幻读。

要想彻底解决幻读，只能使用并行化隔离级别。

## 8. 为什么大厂要将默认隔离级别修改为RC？^
>[!abstract] 摘要
>1. **目的**：提高并发！
>2. **如何**：①无间隙锁和临键锁，只有记录锁；②半一致读；

为了提高并发。
1. RC在加锁时，无需添加Gap Lock和Next Key Lock，只会对被修改的记录添加Record Lock，这使得RC级别的并发度会高于RR级别，同时减少死锁的发生；
2. RC支持“半一致读”，可以大大减少更新语句时行锁的冲突；对于不满足更新记录的条件，可以提前释放锁，提高并发度。
	- **半一致读**：RC支持“半一致读”，即在读取数据时，如果该数据被其他事务修改但尚未提交，MySQL会返回该记录最近提交的版本。
3. RC支持三种binlog格式，而RR支持持
## 9. 什么是半一致读？^
MySQL的半一致性读（Semi-Consistent Read）是一种优化机制，主要用于提高在特定事务隔离级别下的并发性能，尤其是在执行更新操作时。以下是对半一致性读的详细解析。

### 半一致性读的定义
半一致性读是一种介于普通读和锁定读之间的读取方式，主要应用于 **READ COMMITTED**（RC）事务隔离级别下。当执行更新操作时，如果需要加锁的行已经被其他事务锁定，MySQL会在InnoDB引擎层再次读取这些行记录，以判断是否真的需要加锁。这种机制可以减少不必要的锁竞争，从而提升系统的并发能力[1][2][5].

### 工作原理
在RC隔离级别下，半一致性读通过以下步骤工作：
1. **行锁判断**：当一个更新语句的 `WHERE` 条件匹配到的记录已被其他事务锁定时，MySQL会首先返回最新已提交版本的记录。
2. **条件判断**：在确认读取到的数据后，再决定是否对该行加锁。如果当前事务持有的锁与要加锁的行不冲突，则可以提前释放锁，从而避免不必要的阻塞[2][4][6].

### 示例
假设有两个事务同时尝试更新表中的数据：
- **事务1**：执行 `UPDATE test SET name='test' WHERE name='a';`
- **事务2**：同时执行 `UPDATE test SET name='test1' WHERE name='b';`

在没有半一致性读的情况下，若这两个更新操作都需要加锁且相互冲突，则可能导致一个事务等待另一个事务释放锁。而使用半一致性读时，如果事务1正在更新某些行，而事务2请求更新的不与之冲突，则可以顺利执行，减少了等待时间[1][2].

### 优势与应用场景
半一致性读的主要优势在于：
- **减少锁冲突**：通过判断是否真正需要加锁，可以降低因行锁引起的阻塞，从而提高并发性能。
- **优化全表扫描**：在全表扫描更新时，只有满足条件的行会被加锁，这样可以避免全表加锁带来的性能瓶颈[1][2][4].

### 适用场景
- 在高并发环境下，特别是涉及大量更新操作且数据访问模式较为复杂时，使用半一致性读可以显著提升系统响应速度和资源利用率。
- 对于低区分度字段的更新操作，可以利用这一特性来优化性能，避免不必要的等待和死锁[1][5].

### 总结
MySQL的半一致性读是一种有效提升数据库并发性能的技术，通过优化行锁机制和减少不必要的阻塞，为高并发场景提供了更好的支持。理解其工作原理及应用场景，有助于数据库管理员和开发者在设计和优化数据库系统时做出更明智的决策。

## 10. ==介绍MVCC实现原理^==
>[!abstract] 摘要
>1. ①多事务读不阻塞；②数据一致；
>2. 版本链 + Read View

MVCC，多版本并发控制，允许多个事务读取同一行数据而不会彼此阻塞，并且每个事务看到的数据版本是该事务开始时的数据版本。

通过**版本链+Read View**实现的。

读提交隔离级别，是在「每个select语句执行前」都会重新生成一个 Read View；
RR隔离级别，在事务开始时会创建一个ReadView，然后整个事务期间都会用这个ReadView。

## 11. 介绍下ReadView
ReadView主要用于解决可见性问题，帮助事务确定哪些版本的行记录是可见的。

RR级别下，ReadView在事务开始时创建，并在事务期间保持不变；
RC级别下，ReadView在每次查询时重新创建，以反映数据库的最新更改。

Read View有四个重要信息：
![[Pasted image 20241204205441.png|650]]


![[Pasted image 20241204205725.png|650]]
## 12. 当前读和快照读有什么区别？
>[!abstract] 摘要：
>1. **区别**：Read View 和 最新数据；
>2. **何时**：DML语句、IN SHARE MODE、FOR UPDATEA。

快照读读取的是快照中，即ReadView中的数据；当前读，读取的是最新的数据，主要用于修改操作，获取数据的最新状态以保持一致性。

快照读：
`SELECT * FROM xx_table WHERE ...;`

当前读：
- 增删改、加锁的select都会进行当前读
```sql
SELECT * FROM xx_table LOCK IN SHARE MODE;

SELECT * FROM xx_table FOR UPDATE;

INSERT INTO xx_table ...

DELETE FROM xx_table ...

UPDATE xx_table ...
```

---
# <font color="#245bdb">锁</font>
## 1. 介绍一下MySQL的锁
![[Pasted image 20241119215143.png]]
## 2. 什么是排他锁和共享锁?
>[!abstract] 摘要
>1. 读锁共享，写锁阻塞。
### 共享锁:
- 共享锁又称读锁、S锁，是读取操作创建的锁。其他用户可以并发读取数据，**但任何事务都不能对数据进行修改**（获取数据上的排他锁），直到已释放所有共享锁。
- 如果事务T对事务A加了共享锁，其他事务只能对A再加共享锁，不能加排他锁。

### 排他锁:
- 排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。获得排他锁的事务既能读数据，又能修改数据。

## 3. 什么是意向锁?
>[!abstract] 摘要
>1. 解决不同锁粒度并发性问题的锁机制；
>2. **申请表锁时，通过意向锁快速判断是否有行锁**。

若事务A对某行记录加了行锁，而事务B申请整张表加表锁，那么就需要判断表中是否有行锁，若通过全表扫描来检测，那么效率很低，因此引入意向锁来快速判断。

所以，**意向锁是数据库管理系统中用于实现锁协议的一种锁机制，是用于处理不同锁粒度之间（主要是表锁与行锁） 的并发性问题。**
	行锁与行锁之间的并发问题通过行级互斥锁实现。

意向锁共有两种：1)意向共享锁；2)意向排他锁。共享+共享√，共享+排他×，排他+排他×.

## 4. binlog, redolog和undolog的区别?
#### binlog:
- binlog主要用于对数据库进行**数据备份、主从复制和崩溃恢复**等操作。binlog是MySQL用于记录所有**DDL语句和DML语句**的一种二进制文件，不会记录查询类操作(如SELECT、SHOW)。
- binlog是追加写形式，当写满一个文件后会创建新文件继续写，不会覆盖以前的日志。
#### redolog:
- redolog是MySQL用于**实现崩溃恢复和数据持久性**的一种机制。在事务进行过程中，MySQL会**将事务做了什么改动**记录到Redo Log中。当系统崩溃或者发生异常情况时，MySQL会利用Redo Log中的记录信息来进行恢复操作，将事务所做的修改持久化到磁盘中。
#### undolog:
Undo Log则用于在**事务回滚或系统崩溃时撤销（回滚）事务所做的修改**。当一个事务执行过程中，MySQL会将**事务修改前的数据**记录到Undo Log中。如果事务需要回滚，则会从Undo Log中找到相应的记录来**撤销事务所做的修改**。
## 5. binlog, redolog和undolog的持久化时间？ TODO
## 6. MySQL中的binlog有几种格式?
共有三种格式：row、statement和mixed.
### statement:
数据库中的SQL语句会原封不动的被记录在binlog中。

使用较少，会导致主从复制不一致的问题。
- 比如说，当我们使用DELETE或者UPDATE的时候，指定了LIMIT，但是并没有使用order by，那么最终这条语句在主库和从库上的执行结果可能是不一样的（即使同一个库上面，你执行多次结果可能也不一样）。
### row:
binlog中会**记录每个数据更改的具体行的细节**，每条日志都会详细记录发生变更的行的内容和修改情况。

缺点是需要记录更多的内容，如批量修改，需要将每条记录的变更细节都记录。因此**数据恢复时需要更长时间**。
### mixed:
两者的结合，自动切换选择合适的格式进行记录。但是在RC级别下，只有row格式可以生效。


## 7. ==什么是事务的两阶段提交?==
![[Pasted image 20241120013145.png|450]]
将事务的更新分为Prepare准备阶段和Commit提交阶段。
- **准备阶段**：MySQL将事务的更新操作记录到redo log中，并将其标记为Prepare状态；紧接着，MySQL将更新操作写入binlog。
- **提交阶段**：MySQL将redo log记录标记为commit提交状态，并确保事务的修改持久化到数据库中。
两阶段提交确保了binlog和redolog的数据一致性，从而保证数据库在崩溃恢复等场景下的可靠性和稳定性。

假设第一阶段提交已完成，binlog已写入，但是第二阶段还未完成，redolog仍未被标记为commit状态，此时数据库宕机崩溃，那么**重启后，事务会回滚还是提交？**

判断回滚还是提交的基本原则：**保证binlog与redolog的一致性，保证binlog能完全恢复数据。**
- 因为binlog已落盘，所以此时会根据redolog中的记录将数据恢复，并提交事务。
	- 若此时将事务回滚，那么binlog中就会多出一条记录(已写入的binlog不能被修改！)，导致数据不一致。

![[Pasted image 20250107125613.png|500]]
![[Pasted image 20250123104540.png]]
## 8. 两阶段提交中，如何判断binlog和redolog是否达成了一致?
当MySQL写完redolog并将它标记为prepare状态时，并且会在redolog中记录一个**XID**，它**全局唯一的标识着这个事务**。而当你设置`sync_binlog=1`时，做完了上面第一阶段写redolog后，mysql就会对应binlog并且会直接将其刷新到磁盘中。

下图就是磁盘上的row格式的binlog记录。binlog结束的位置上也有一个XID。
![[Pasted image 20241120194528.png]]
只要这个XID和redolog中记录的XID是一致的，MySQL就会认为binlog和redolog逻辑上一致。就上面的场景来说就会commit，而如果仅仅是rodolog中记录了XID，binlog中没有，MySQL就会RollBack。

**总结**：通过redolog和binlog中的用于全局唯一标识事务的XID来判断。

>[!IMPORTANT]
>**注意：保持binlog和redolog的一致，需要开启参数innodb_support_xa = 1**
## 9. 什么是WAL技术?
WAL，即Write Ahead Lock，预写日志技术，**利用了磁盘连续写的性能高于随机读写这一特性**。具体而言，是先修改缓冲池中的内存页的数据并将该内存也标记为“脏页”，然后写redo log(事务提交阶段)，磁盘中的数据并不会立刻更新，而是之后在空闲时间、或者连接正常关闭时，由后台线程**Page Cleaner Thread**进行刷脏页操作，将缓冲池中的数据持久化到磁盘中。

---
# <font color="#245bdb">分布式</font>
## 1. ~~分布式id方案^<sup>美团leaf分布式id</sup>~~ TODO


## 2. 读扩散问题是什么？ TODO
查找非分片字段发生的扫描所有分表的问题。
- 假设user表按照user_id分表，那么此时就会有user_0、user_1等多张表，那么此时若按照name字段进行查询，则无法具体定位到某张表，那么就会对所有分表执行！

**解决方案一：**
- 根据name字段建立新表。那么查询过程就会变成先查name表，获取对应主键id，再去查主键id对应的分表。
	- **缺点**：需要维护两套表，并且普通索引列更新，需要同时更新两张表。![[Pasted image 20241220111707.png]]

**解决方案二：**
>倒排索引，通过字段反向查找出含有该字段的数据记录。
- 利用ES的倒排索引功能，内部会以ID分片键进行分片，同时建立name到id，age到id的倒排索引。
- **具体实现**：利用开源工具canal监听MySQL的binlog日志变更，再将数据解析后写入ES。![[Pasted image 20241220112928.png]]

**解决方案三：**
- 使用分布式数据库TiDB。