## 1. CAP是什么？^
Consisten、Availability、Partial Tolerance。

- **一致性**：每次读取都会收到最新的写入数据或错误信息。
- **可用性**：每个请求都会收到（非错误的）响应，但不能保证响应包含最新的写入数据。
- **分区容忍性**：尽管网络节点之间会丢弃（或延迟）任意数量的消息，系统仍然能够继续运行。

- **CP**：用户下单，等待库存扣减操作结束后才返回结果。
	- CP是强一致性的，常用在金融、银行等对一致性要求高的场景。
- **AP**：用户下单，先返回响应结果，库存扣减操作异步处理。
	- AP是快速响应，提高用户体验，但无法保证最终库存扣减成功等，需要后续进行补救。
- AC：不再拆分数据系统，即不存在分布式的场景，回归单体系统。通过一个数据库完成库存校验扣减操作。

![[Pasted image 20250311102600.png]]
## 2. 什么是两阶段提交？

## 3. 什么是三阶段提交？为什么需要？
## 4. TCC是什么？和2PC有什么区别？

## 5. 什么是幂等性？^
同一个接口，多次发出同一个请求，请求的结果是一致的。

幂等性问题：

## 6. 如何解决接口幂等问题？
一锁、二判、三更新。

**一锁**：加互斥锁，如分布式锁、悲观锁。
**二判**：进行幂等性判断，如基于状态机、流水表、唯一性索引等进行重复操作的判断；
**三更新**：进行数据更新，持久化。

一锁非必须，在高并发的情况下才需要。

- **数据库唯一主键**：使用分布式ID充当主键，确保在全局下能保证只存在一条该记录，适用于“插入”操作的幂等性。 
- **唯一索引**：
- **状态机**：执行请求时，更新订单状态，更新成功会返回影响行数1，若更新失败则说明是重复请求，会返回影响行数0，此时直接返回即可，无需执行接下来的业务操作。
- **Token机制**：
## 7. 为什么不建议用数据库唯一性约束做幂等控制？


## 8. 什么是一致性哈希？
一致性哈希（Consistent Hashing）是一种用于分布式系统中数据分片和负载均衡的算法。它的目标是在节点的动态增加或删除时，尽可能地减少数据迁移和重新分布的成本。
## 9. 雪花算法是什么？
分布式ID生成算法，可以生成全局唯一且递增的ID。

核心思想：
将64位ID划分为多个部分，每个部分都有不同的含义，包括时间戳、数据中心标识、机器标识和序列号等。

1. 符号位(1bit)：始终为0，占用1位；
2. 时间戳(41bit)：精确到毫秒级别；
3. 数据中心标识(5bit)：用来区分不同的数据中心；
4. 机器标识(5bit)：区分不同的机器；
5. 序列号(12bit)：生成4096个不同的序列号。

如何保证全局唯一：
- 时间戳是高位，保证了ID的递增；
- 数据中心标识和机器标识是手工设置，保证不同的数据中心和机器生成的标识不同；
- 每次生成ID时序列号都会自增，解决了同一毫秒生成多次ID的问题。
![[Pasted image 20241208195828.png]]

## 10. 什么是负载均衡？有哪些常见算法？


## 11. 讲讲滑动窗口、令牌桶、漏桶三种限流方案的区别。
>参考链接：[这才叫分布式限流算法！](https://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&mid=2247688316&idx=1&sn=163ceb7c773a4d097ae3a0790ffc4b3f&chksm=eb0d3ba602bbdcdd3a93fefecdc14865e68ee4c6f78cb5a050a2ea659fef81e267a31e1c67bf&mpshare=1&scene=1&srcid=0122KNIBvqNYi3KE8vaZAs6L&sharer_shareinfo=7f532247188329953508b2a7719a60a7&sharer_shareinfo_first=7f532247188329953508b2a7719a60a7)、[漏桶算法和令牌桶算法，区别到底在哪里](https://xie.infoq.cn/article/4a0acdd12a0f6dd4a53e0472c)

### 滑动窗口限流
用于控制在一定时间内允许执行的操作数量或请求频率。在一定时间内，请求的数量是固定的。

**优点**：
1. 灵活性：滑动窗口算法可以根据实际情况动态调整窗口的大小，以适应流量的变化。这种灵活性使得算法能够更好地应对突发流量和请求分布不均匀的情况。
2. 实时性：由于滑动窗口算法在每个时间窗口结束时都会进行窗口滑动，它能够更及时地响应流量的变化，提供更实时的限流效果。
3. 精度：相比于固定窗口算法，滑动窗口算法的颗粒度更小，可以提供更精确的限流控制。

**缺点**：
1. 内存消耗：滑动窗口算法需要维护一个窗口内的请求时间列表，随着时间的推移，列表的长度会增长。这可能会导致较大的内存消耗，特别是在窗口大小较大或请求频率较高的情况下。
2. 算法复杂性：相比于简单的固定窗口算法，滑动窗口算法的实现较为复杂。它需要处理窗口滑动、请求计数和过期请求的移除等逻辑，可能需要更多的代码和计算开销。
### 漏桶
维护一个固定容量的漏桶，请求以不定速率流入漏桶，漏桶始终以固定的速率放出请求。如果请求到达时漏桶已满，则拒绝请求。

**优点**：
1. 平滑流量：漏桶算法可以**平滑突发流量**，使得输出流量变得更加平稳，避免了流量的突然增大对系统的冲击。
2. 简单易实现：漏桶算法的原理简单，实现起来也相对容易。
3. 有效防止过载：通过控制流出的流量，漏桶算法可以有效地防止系统过载。

**缺点**：
1. **对突发流量的处理不够灵活**：虽然漏桶算法可以平滑突发流量，但是在某些情况下，我们可能希望能够**快速处理突发流量**。在这种情况下，漏桶算法可能就不够灵活了。
2. 无法动态调整流量：漏桶算法的流出速率是固定的，无法根据系统的实际情况动态调整。
3. 如果输入流量持续大于漏桶的流出速率，那么漏桶会一直满，**新的请求会被丢弃**，可能会导致服务质量下降。
4. 可能会导致流量浪费：如果输入流量小于漏桶的流出速率，那么漏桶的流出速率就会被浪费。


### 令牌桶
令牌桶算法基于一个令牌桶的概念，其中**令牌以固定的速率产生**，并放入桶中。每个令牌代表一个请求的许可。当请求到达时，需要从令牌桶中获取一个令牌才能通过。如果令牌桶中没有足够的令牌，则请求被限制或丢弃。

**优点**：
1. 平滑流量：在流量平稳时，令牌桶算法的功能与漏桶类似，可以平滑流量，使得突发流量在一段时间内均匀地分布，避免了流量的突然高峰对系统的冲击。
2. 灵活性：令牌桶算法可以通过**动态调整令牌生成速率和桶的大小来灵活地控制流量**。
3. 允许突发流量：区别于漏桶，**令牌桶在空闲时间可以积累一定数量的令牌**，因此在流量突然增大时，如果桶中有足够的令牌，可以通过快速消耗令牌来应对这种突发流量。

**缺点**：
1. 实现复杂：相比于其他一些限流算法（如漏桶算法），令牌桶算法的实现稍微复杂一些，需要维护令牌的生成和消耗。
2. 需要精确的时间控制：令牌桶算法需要根据时间来生成令牌，因此需要有精确的时间控制。如果系统的时间控制不精确，可能会影响限流的效果。
3. 可能会有资源浪费：如果系统的流量持续低于令牌生成的速率，那么桶中的令牌可能会一直积累，造成资源的浪费。

## 12. 分布式限流方案
>[这才叫分布式限流算法！](https://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&mid=2247688316&idx=1&sn=163ceb7c773a4d097ae3a0790ffc4b3f&chksm=eb0d3ba602bbdcdd3a93fefecdc14865e68ee4c6f78cb5a050a2ea659fef81e267a31e1c67bf&mpshare=1&scene=1&srcid=0122KNIBvqNYi3KE8vaZAs6L&sharer_shareinfo=7f532247188329953508b2a7719a60a7&sharer_shareinfo_first=7f532247188329953508b2a7719a60a7)
### 基于中心化的限流方案

### 基于分布式协调服务的限流

## 13. 基于本地消息表实现分布式事务保证最终一致性
原本是创建订单后发送消息，这样可能会有以下问题：①消息发送失败；②消息发送成功并且消费成功，但是由于网络问题导致出现错误响应。此时都会回滚当前order方法。但是第二种情况由于消息被成功消费，从而导致了消息不一致。
```java
@Transactional
public void order(OrderDTO orderDTO){

	orderServive.createOrder(orderDTO);
	mqService.send(orderDTO);
	
}
```

引入本地消息表：
![[Pasted image 20250403005743.png|550]]
改造代码，方法中需要创建两条数据库记录，一条是订单的记录，另一条是本地消息记录：
```java
@Transactional
public void order(OrderDTO orderDTO){

	orderServive.createOrder(orderDTO);
	messageService.createMessage(orderDTO);
	
}
```


由于两个方法都是本地创建数据库记录并且在事务内，因此要么同时成功、要么同时失败。本地消息创建后，还需要发送MQ消息，我们可以通过异步定时任务扫表、同步发消息（MQ消息发送需要放到事务外）、或者SpringEvent异步处理都可以。
![[Pasted image 20250403010306.png]]
消息消费成功后，通过回调接口通知修改本地事务消息状态。

若消息消费失败，则依赖MQ的重试机制不断重试即可。

上述可能的失败情况：
1. 操作1和操作2失败的话，由于是事务内，因此会回滚；
2. 操作3失败的话，由于状态没改变，定时任务扫表还是会再次执行；
3. 操作4、5失败的话，就是消息发送或者消费失败，通过MQ的重试机制不断重试即可；
4. 操作6或操作7失败，就是回调通知失败或者修改本地状态失败。此时分布式数据已经一致了，只是状态还没变更，因此通过定时任务重投消息，下游幂等做保障，消费后再重新修改状态即可。 
	- 或者定时任务扫描下游系统状态，若成功，则修改本地消息状态。


##### 缺点：
1. 本地消息多后，定时任务扫表会越来越慢；
	- 可以通过多线程扫表（做好数据隔离）、或者建立索引优化。
2. 若本地消息表在主库，那么集中式扫描会给数据库带来压力（如占满连接数），影响正常业务；
	- 可以通过将本地消息表放到备库中解决。
3. 定时任务存在延迟问题。
	- 可以通过延迟消息解决。
	- 或者通过SpringEvent


## 什么是时间轮算法？
时间轮算法就是定义一个时间轮盘，将轮盘划分出多个槽位，每个槽位代表一个时间段。时间段的单位可以是秒级、分钟级等。

当有定时任务需要执行时，就将其挂在槽位上，多个任务形成链表。

后续会有单独一个线程进行时间盘的轮转，判断该执行哪些任务了。而链表中的任务会交给线程池来执行。
![[Pasted image 20250403084754.png|600]]


上述时间轮有个缺陷，例如将槽位划分为60个，单位为秒，那么就只支持60秒内的定时任务。虽然可以通过划分更多的时间槽来解决，但是较大的时间槽数量会增加时间轮的内存消耗和维护成本，但可以提高任务调度的准确性。
#### 分层时间轮
定义两个时间轮，分别代表不同单位，如下：
![[Pasted image 20250403085455.png|600]]

假设有个任务是3分20秒后执行，那么就将其放在第三分钟。左边每转一轮，就从右边取出当前分钟需要执行的任务，放到秒级时间轮钟准备执行。

分层（多维）时间轮能明显减少相同粒度下多槽位时间轮的时间复杂度。例如同样要支持60分钟的定时任务，多槽位就需要划分3600个槽位（秒级），而分层时间轮就只需要划分2个分别为60个槽位的时间轮即可。