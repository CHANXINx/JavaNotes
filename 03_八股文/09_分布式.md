## 1. CAP是什么？^
Consisten、Availability、Partial Tolerance。

- **一致性**：每次读取都会收到最新的写入数据或错误信息。
- **可用性**：每个请求都会收到（非错误的）响应，但不能保证响应包含最新的写入数据。
- **分区容忍性**：尽管网络节点之间会丢弃（或延迟）任意数量的消息，系统仍然能够继续运行。

- **CP**：用户下单，等待库存扣减操作结束后才返回结果。
	- CP是强一致性的，常用在金融、银行等对一致性要求高的场景。
- **AP**：用户下单，先返回响应结果，库存扣减操作异步处理。
	- AP是快速响应，提高用户体验，但无法保证最终库存扣减成功等，需要后续进行补救。
- AC：不再拆分数据系统，即不存在分布式的场景，回归单体系统。通过一个数据库完成库存校验扣减操作。
## 2. 什么是两阶段提交？

## 3. 什么是三阶段提交？为什么需要？
## 4. TCC是什么？和2PC有什么区别？

## 5. 什么是幂等性？^
同一个接口，多次发出同一个请求，请求的结果是一致的。

幂等性问题：

## 6. 如何解决接口幂等问题？
一锁、二判、三更新。

**一锁**：加互斥锁，如分布式锁、悲观锁。
**二判**：进行幂等性判断，如基于状态机、流水表、唯一性索引等进行重复操作的判断；
**三更新**：进行数据更新，持久化。

一锁非必须，在高并发的情况下才需要。

- **数据库唯一主键**：使用分布式ID充当主键，确保在全局下能保证只存在一条该记录，适用于“插入”操作的幂等性。 
- **唯一索引**：
- **状态机**：执行请求时，更新订单状态，更新成功会返回影响行数1，若更新失败则说明是重复请求，会返回影响行数0，此时直接返回即可，无需执行接下来的业务操作。
- **Token机制**：
## 7. 为什么不建议用数据库唯一性约束做幂等控制？


## 8. 什么是一致性哈希？
一致性哈希（Consistent Hashing）是一种用于分布式系统中数据分片和负载均衡的算法。它的目标是在节点的动态增加或删除时，尽可能地减少数据迁移和重新分布的成本。
## 9. 雪花算法是什么？
分布式ID生成算法，可以生成全局唯一且递增的ID。

核心思想：
将64位ID划分为多个部分，每个部分都有不同的含义，包括时间戳、数据中心标识、机器标识和序列号等。

1. 符号位(1bit)：始终为0，占用1位；
2. 时间戳(41bit)：精确到毫秒级别；
3. 数据中心标识(5bit)：用来区分不同的数据中心；
4. 机器标识(5bit)：区分不同的机器；
5. 序列号(12bit)：生成4096个不同的序列号。

如何保证全局唯一：
- 时间戳是高位，保证了ID的递增；
- 数据中心标识和机器标识是手工设置，保证不同的数据中心和机器生成的标识不同；
- 每次生成ID时序列号都会自增，解决了同一毫秒生成多次ID的问题。
![[Pasted image 20241208195828.png]]

## 10. 什么是负载均衡？有哪些常见算法？


## 11. 讲讲滑动窗口、令牌桶、漏桶三种限流方案的区别。
>参考链接：[这才叫分布式限流算法！](https://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&mid=2247688316&idx=1&sn=163ceb7c773a4d097ae3a0790ffc4b3f&chksm=eb0d3ba602bbdcdd3a93fefecdc14865e68ee4c6f78cb5a050a2ea659fef81e267a31e1c67bf&mpshare=1&scene=1&srcid=0122KNIBvqNYi3KE8vaZAs6L&sharer_shareinfo=7f532247188329953508b2a7719a60a7&sharer_shareinfo_first=7f532247188329953508b2a7719a60a7)、[漏桶算法和令牌桶算法，区别到底在哪里](https://xie.infoq.cn/article/4a0acdd12a0f6dd4a53e0472c)

### 滑动窗口限流
用于控制在一定时间内允许执行的操作数量或请求频率。在一定时间内，请求的数量是固定的。

**优点**：
1. 灵活性：滑动窗口算法可以根据实际情况动态调整窗口的大小，以适应流量的变化。这种灵活性使得算法能够更好地应对突发流量和请求分布不均匀的情况。
2. 实时性：由于滑动窗口算法在每个时间窗口结束时都会进行窗口滑动，它能够更及时地响应流量的变化，提供更实时的限流效果。
3. 精度：相比于固定窗口算法，滑动窗口算法的颗粒度更小，可以提供更精确的限流控制。

**缺点**：
1. 内存消耗：滑动窗口算法需要维护一个窗口内的请求时间列表，随着时间的推移，列表的长度会增长。这可能会导致较大的内存消耗，特别是在窗口大小较大或请求频率较高的情况下。
2. 算法复杂性：相比于简单的固定窗口算法，滑动窗口算法的实现较为复杂。它需要处理窗口滑动、请求计数和过期请求的移除等逻辑，可能需要更多的代码和计算开销。
### 漏桶
维护一个固定容量的漏桶，请求以不定速率流入漏桶，漏桶始终以固定的速率放出请求。如果请求到达时漏桶已满，则拒绝请求。

**优点**：
1. 平滑流量：漏桶算法可以**平滑突发流量**，使得输出流量变得更加平稳，避免了流量的突然增大对系统的冲击。
2. 简单易实现：漏桶算法的原理简单，实现起来也相对容易。
3. 有效防止过载：通过控制流出的流量，漏桶算法可以有效地防止系统过载。

**缺点**：
1. **对突发流量的处理不够灵活**：虽然漏桶算法可以平滑突发流量，但是在某些情况下，我们可能希望能够**快速处理突发流量**。在这种情况下，漏桶算法可能就不够灵活了。
2. 无法动态调整流量：漏桶算法的流出速率是固定的，无法根据系统的实际情况动态调整。
3. 如果输入流量持续大于漏桶的流出速率，那么漏桶会一直满，**新的请求会被丢弃**，可能会导致服务质量下降。
4. 可能会导致流量浪费：如果输入流量小于漏桶的流出速率，那么漏桶的流出速率就会被浪费。


### 令牌桶
令牌桶算法基于一个令牌桶的概念，其中**令牌以固定的速率产生**，并放入桶中。每个令牌代表一个请求的许可。当请求到达时，需要从令牌桶中获取一个令牌才能通过。如果令牌桶中没有足够的令牌，则请求被限制或丢弃。

**优点**：
1. 平滑流量：在流量平稳时，令牌桶算法的功能与漏桶类似，可以平滑流量，使得突发流量在一段时间内均匀地分布，避免了流量的突然高峰对系统的冲击。
2. 灵活性：令牌桶算法可以通过**动态调整令牌生成速率和桶的大小来灵活地控制流量**。
3. 允许突发流量：区别于漏桶，**令牌桶在空闲时间可以积累一定数量的令牌**，因此在流量突然增大时，如果桶中有足够的令牌，可以通过快速消耗令牌来应对这种突发流量。

**缺点**：
1. 实现复杂：相比于其他一些限流算法（如漏桶算法），令牌桶算法的实现稍微复杂一些，需要维护令牌的生成和消耗。
2. 需要精确的时间控制：令牌桶算法需要根据时间来生成令牌，因此需要有精确的时间控制。如果系统的时间控制不精确，可能会影响限流的效果。
3. 可能会有资源浪费：如果系统的流量持续低于令牌生成的速率，那么桶中的令牌可能会一直积累，造成资源的浪费。

## 12. 分布式限流方案
>[这才叫分布式限流算法！](https://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&mid=2247688316&idx=1&sn=163ceb7c773a4d097ae3a0790ffc4b3f&chksm=eb0d3ba602bbdcdd3a93fefecdc14865e68ee4c6f78cb5a050a2ea659fef81e267a31e1c67bf&mpshare=1&scene=1&srcid=0122KNIBvqNYi3KE8vaZAs6L&sharer_shareinfo=7f532247188329953508b2a7719a60a7&sharer_shareinfo_first=7f532247188329953508b2a7719a60a7)
### 基于中心化的限流方案

### 基于分布式协调服务的限流