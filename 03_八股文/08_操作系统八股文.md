## 1. 同步、异步、阻塞、非阻塞怎么理解？
同步、异步描述的是被调用方：
- 同步：被调用方B接收到A的请求后，需要立即处理；
- 异步：被调用方B接收到A的请求后，不必立即执行，但会保证执行，可在做好之后通知A。

阻塞、非阻塞描述的是调用方：
- 阻塞：调用方A发起调用后，需要一直等待B返回结果；
- 非阻塞：不必一直等待B返回结果。


## 2. ⭐什么是AIO、BIO和NIO？
#### BIO（同步阻塞模型）
Blocking I/O，同步阻塞I/O模型。线程发起IO请求后，**一直阻塞，直到缓冲区数据就绪后**，再进入下一步操作。
#### NIO（同步非阻塞模型）
Non Blocking I/O，同步非阻塞I/O。线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要**定时轮询检查IO缓冲区数据是否就绪**即可。
#### AIO（异步非阻塞模型）
Asynchronous I/O，异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，**异步IO操作之后会回调通知调用方**。

>注意：没有异步阻塞模型，想想，都异步了还阻塞等待，那不是浪费时间？

![[Pasted image 20241216161021.png|500]]

## 3. ⭐什么是IO多路复用？
核心思想：让单个线程去监视多个连接，一旦某个连接就绪，触发读写事件，就会通知对应的应用程序去**主动获取就绪的连接**进行读写操作。也就是，在应用程序内可以**实现单个线程同时处理多个客户端连接**，在对系统资源消耗较小的情况下，去提升服务端的连接处理数量。

## 4. ⭐SELECT、POLL和EPOLL有什么区别？
三者都是**Linux系统内提供的IO多路复用机制的实现**，他们能够同时监听多个文件描述符，当任意一个文件描述符就绪时，能够**非阻塞地读写数据**。其中select和poll是**基于轮询的方式**实现，而epoll是**基于事件驱动**的方式实现的。 

**区别1：性能差距**
- 由于select和epoll是**基于轮询**实现的，内核需要不断检查每个文件描述符的状态，因此性能会随着文件描述符数量线性下降；
- epoll是**基于事件通知**的，只需要监控状态变化，不需要遍历整个描述符集合，性能和文件描述符数量无关。

**区别2：**
- select使用固定长度的BitsMap表示文件描述符集合；poll使用动态数组来存储文件描述符，并且多个动态数组以链表的形式连接。二者都使用**线性结构**存储所文件描述符，因此随着连接数变多，性能也会有很大损耗！
- epoll使用红黑树来存储所有待检测的文件描述符，还维护了一个链表用来记录就绪时间。当有事件发生时，就会通过回调函数将其加入到就绪事件列表中，用户调用`epoll_wait()`函数，只会返回链表中的就绪事件，而不会遍历整个socket集合。
## 5. 什么是半双工和全双工？
#### 单工
只允许数据在一个方向传输，通信的一方只能发送数据，另一方只能接收数据。
#### 半双工
数据可以在通信双方双向传输，但不能同时进行。即双方可以交替发送和接收数据。
#### 全双工
数据可以在通信双方双向同时传输。每一方都可以独立地发送和接收数据，并且可以同时进行。
## 6. 为什么工作内存比主存更快？
1. 因为绝大多数运算任务并不能只依靠CPU，还需要与内存进行交互，如读取运算数据、存储运算结果。由于计算机的存储设备与CPU的处理器的运算速度有着几个数量级的差距，所以不得不加入一层或多层读写速度尽可能接近CPU的高速缓存（Cache）来作为CPU与内存之间的缓冲，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样CPU就无需等待缓慢的内存读写了。
2. Cache比内存快的几个原因：
	1. **物理位置差异**：
		- Cache位于CPU内部或紧邻CPU，与内存相比，CPU访问Cache所需要的传输距离更短，因此传输时间更少，延迟更低。而内存位于CPU外部，需要通过总线方法，路径更长。
	2. **存储介质差异**：
		- Cache使用SRAM结构，内存使用DRAM结构，前者读写速度更快；
	3. **局部性原理**：
		- **时间局部性**：CPU倾向于重复访问近期使用过的数据，而Cache会缓存这些数据。
		- **空间局部性**：CPU可能访问相邻数据，而Cache会预存相邻内存块。

Java中的工作内存是一个逻辑概念，可能由CPU Cache或者寄存器实现。那么`为什么工作内存快`就可以转变为 =》`为什么Cache更快`

## 7. 什么是内核态和用户态？
#### 为什么要分两种状态？
为了保护系统的稳定性和安全性，操作系统将运行在不同的特权模式下，即内核态和用户态。

内核是操作系统的核心，负责管理和控制计算机硬件资源，提供系统级服务。假设所有进程都能直接访问硬件资源，可能会导致系统崩溃、数据丢失等问题。因此，操作提供将应用程序和系统内核进行了隔离，分为内核态和用户态，确保不同状态下具有不同的权限，以保证系统的稳定性和安全性。

#### 内核态
操作系统运行在特权模式下的状态，此时具有最高权限，可以访问所有的硬件资源和底层系统资源，如处理器、内存、I/O等。内核态下，系统可以执行所有指令，不受访问权限的控制。

#### 用户态
是指应用程序运行在非特权模式下的状态，此时应用程序只能访问被授权的资源，不能直接操作硬件资源和底层系统资源。

用户态下，应用程序只能执行一些受限的指令集，不能直接执行特权指令。当需要访问系统资源时，需要通过系统调用的方式切换到内核态，请求操作系统提供服务。
#### 如何切换？
二者之间的切换是通过操作系统内核提供的中断或异常机制实现的。有时，应用程序可能需要进行一些系统调用，如读写文件等IO操作，此时就会触发用户态向内核态切换。此时，CPU会暂停当前进程的执行，保存当前进程的状态并切换到内核态执行相应操作。操作执行完毕后，再将控制权切换回用户态，恢复进程的执行。

## 8. 软连接和硬链接的区别是什么？


## 9. IO多路复用和多线程有什么区别？
- IO多路复用主要是提升I/O操作的效率和利用率，适合IO密集型应用；
- 多线程则是提升CPU利用率的方法，所以适合CPU密集型应用。

#### IO多路复用
IO多路复用允许单个线程同时监控多个IO请求。当使用epoll、poll、SELECT等系统调用时，线程可以在不阻塞的情况下，检查多个IO流的状态，并在数据真正准备好时才进行处理。

优点：
- 减少多线程上下文切换的开销；
- 使得单个线程能够高效管理多个并发网络连接。
#### 多线程
多线程允许一个进程并发运行多个线程，每个线程可以独立执行任务。使用多线程能够充分利用多核CPU优势，在处理长时间计算的任务时，可以显著提高效率。
