## 1. ⭐什么是AIO、BIO和NIO？
**AIO**：Asynchronous I/O，异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，**异步IO操作之后会回调通知调用方**。

**BIO**：Blocking I/O，同步阻塞I/O模型。线程发起IO请求后，**一直阻塞，直到缓冲区数据就绪后**，再进入下一步操作。

**NIO**：Non Blocking I/O，同步非阻塞I/O。线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要**定时轮询检查IO缓冲区数据是否就绪**即可。
![[Pasted image 20241216161021.png|500]]

## 2. ⭐什么是IO多路复用？
核心思想：让单个线程去监视多个连接，一旦某个连接就绪，触发读写事件，就会通知对应的应用程序去**主动获取就绪的连接**进行读写操作。也就是，在应用程序内可以**实现单个线程同时处理多个客户端连接**，在对系统资源消耗较小的情况下，去提升服务端的连接处理数量。

## ⭐SELECT、POLL和EPOLL有什么区别？
三者都是Linux系统内提供的IO多路复用机制的实现，其中select和poll是基于轮询的方式实现，而epoll是基于事件驱动的方式实现的。 

**区别1：性能差距**
- 由于select和epoll是基于轮询实现的，内核需要不断检查每个文件描述符的状态，因此性能会随着文件描述符数量线性下降；
- epoll是基于事件通知的，只需要监控状态变化，不需要遍历整个描述符集合，性能和文件描述符数量无关。

**区别2：**
- select使用固定长度的BitsMap表示文件描述符集合；poll使用动态数组来存储文件描述符，并且多个动态数组以链表的形式连接。二者都使用**线性结构**存储所文件描述符，因此随着连接数变多，性能也会有很大损耗！
- epoll使用红黑树来存储所有待检测的文件描述符，还维护了一个链表用来记录就绪时间。当有事件发生时，就会通过回调函数将其加入到就绪事件列表中，用户调用`epoll_wait()`函数，只会返回链表中的就绪事件，而不会遍历整个socket集合。