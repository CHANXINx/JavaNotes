## 1. ⭐什么是AIO、BIO和NIO？
**AIO**：Asynchronous I/O，异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，**异步IO操作之后会回调通知调用方**。

**BIO**：Blocking I/O，同步阻塞I/O模型。线程发起IO请求后，**一直阻塞，直到缓冲区数据就绪后**，再进入下一步操作。

**NIO**：Non Blocking I/O，同步非阻塞I/O。线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要**定时轮询检查IO缓冲区数据是否就绪**即可。
![[Pasted image 20241216161021.png|500]]

## 2. ⭐什么是IO多路复用？
核心思想：让单个线程去监视多个连接，一旦某个连接就绪，触发读写事件，就会通知对应的应用程序去**主动获取就绪的连接**进行读写操作。也就是，在应用程序内可以**实现单个线程同时处理多个客户端连接**，在对系统资源消耗较小的情况下，去提升服务端的连接处理数量。

## 3. ⭐SELECT、POLL和EPOLL有什么区别？
三者都是Linux系统内提供的IO多路复用机制的实现，其中select和poll是基于轮询的方式实现，而epoll是基于事件驱动的方式实现的。 

**区别1：性能差距**
- 由于select和epoll是基于轮询实现的，内核需要不断检查每个文件描述符的状态，因此性能会随着文件描述符数量线性下降；
- epoll是基于事件通知的，只需要监控状态变化，不需要遍历整个描述符集合，性能和文件描述符数量无关。

**区别2：**
- select使用固定长度的BitsMap表示文件描述符集合；poll使用动态数组来存储文件描述符，并且多个动态数组以链表的形式连接。二者都使用**线性结构**存储所文件描述符，因此随着连接数变多，性能也会有很大损耗！
- epoll使用红黑树来存储所有待检测的文件描述符，还维护了一个链表用来记录就绪时间。当有事件发生时，就会通过回调函数将其加入到就绪事件列表中，用户调用`epoll_wait()`函数，只会返回链表中的就绪事件，而不会遍历整个socket集合。

## 4. 为什么工作内存比主存更快？
1. 因为绝大多数运算任务并不能只依靠CPU，还需要与内存进行交互，如读取运算数据、存储运算结果。由于计算机的存储设备与CPU的处理器的运算速度有着几个数量级的差距，所以不得不加入一层或多层读写速度尽可能接近CPU的高速缓存（Cache）来作为CPU与内存之间的缓冲，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样CPU就无需等待缓慢的内存读写了。
2. Cache比内存快的几个原因：
	1. **物理位置差异**：
		- Cache位于CPU内部或紧邻CPU，与内存相比，CPU访问Cache所需要的传输距离更短，因此传输时间更少，延迟更低。而内存位于CPU外部，需要通过总线方法，路径更长。
	2. **存储介质差异**：
		- Cache使用SRAM结构，内存使用DRAM结构，前者读写速度更快；
	3. **局部性原理**：
		- **时间局部性**：CPU倾向于重复访问近期使用过的数据，而Cache会缓存这些数据。
		- **空间局部性**：CPU可能访问相邻数据，而Cache会预存相邻内存块。

Java中的工作内存是一个逻辑概念，可能由CPU Cache或者寄存器实现。那么`为什么工作内存快`就可以转变为 =》`为什么Cache更快`