# 实际业务场景
## **场景1：快速响应用户请求**

**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。

**分析：**
- 为了快速响应，需要将调用封装成任务并行执行，缩短总体响应时间。因此，为了获取最大的响应速度来满足用户，不应设置队列来缓冲并发任务，而是**调高corePoreSize和maxPoolSize去尽可能创建多的线程快速执行任务。**
![[Pasted image 20241217190633.png]]
## **场景2：快速处理批量任务**

**描述**：离线的**大量计算任务**，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。

**分析：**
这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注**如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题**。因此，应该设置队列来缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数，避免过多的线程上下文切换导致性能降低。
![[Pasted image 20241217190954.png|550]]

# 动态化线程池 
主要调整三个参数：①核心线程数；②最大线程数；③队列类型。

动态化线程池具有几个功能：
- **动态调参**：通过ThreadPoolExecutor实例的set方法进行修改。参数修改后会及时生效，平滑修改。
  ![[Pasted image 20241217192211.png]]
- **线程池监控**：
	- **负载监控和告警**：定义线程池活跃度=$\frac{activeCount}{maximumPoolSize}$，代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。告警后，会通知关联负责人。
	- **任务级精细化监控**：动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：
	- **运行时状态实时查看**：通过ThreadPoolExecutor实例的get方法读取当前状态。![[Pasted image 20241217192447.png]]