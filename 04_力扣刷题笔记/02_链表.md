## 203.移除链表元素
### 题目:
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
**输入:head = `[1,2,6,3,4,5,6]`, val = 6 输出：**`[1,2,3,4,5]`
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆

### 思路一：哨兵节点

**涉及到删除操作，一般需要考虑哨兵节点。**

执行删除节点node操作，可以通过修改next指针完成，所以应该在node的前一个节点处执行删除操作。

考虑到头节点没有“前一个节点”，所以必须使用哨兵节点dummy。

**具体如何执行？**
- 从哨兵节点开始遍历，判断其next节点的值是否为val：若是，则删除；若不是，往后遍历；
- 若成功删除，此时无需更新curr指针，因为在删除时已经更新过一次curr指针！若再次更新，则会错过节点。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null){
            if (curr.next.val == val){
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
            
        }
        return dummy.next;
    }
}
```

## 707.设计链表
### 题目:
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路一：
- 定义虚拟头节点，此时无论是添加节点到头部、还是删除头部节点，都会更方便。
- **初始化链表**：因为是无参构造器，所以直接初始化虚拟头节点与size即可。
- 要删除某个节点、添加节点到某个位置，都要注意**健壮性保证**：idx不能小于0，也不能大于等于size。
- **对于index的遍历，`for(int i = 0; i <=index; i++)`会刚好移动到`index`节点上！而对于添加到末尾，则直接`for(int i = 0; i < size; i++)`也会刚好移动到末尾。**
- 注意需要不断维护size的大小。

```java
class ListNode{
    int val;
    ListNode next;

    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
    public ListNode(int val,ListNode next){
        this.val = val;
        this.next = next;
    }
}

class MyLinkedList {
    private ListNode dummy;
    private int size;

    public MyLinkedList() {
        dummy = new ListNode(0);
        size = 0;
    }
    
    public int get(int index) {
        if (index >= size || index < 0) return -1;
        // 将curr移动到需要返回的节点上
        ListNode curr = dummy;
        for (int i = 0; i <= index; i++){
            curr = curr.next;
        }
        return curr.val;
    }
    
    public void addAtHead(int val) {
        ListNode newHead = new ListNode(val);
        // 更换头节点
        newHead.next = dummy.next;
        dummy.next = newHead;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);
        // 移动到末尾节点。
        ListNode curr = dummy;
        for (int i = 0; i < size; i++){
            curr = curr.next;
        }
        curr.next = tail;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        // 超出长度，不会插入
        if (index > size) return;
        // 插入到末尾
        if (index == size) {addAtTail(val);return;}
        
        ListNode newNode = new ListNode(val);
        // 移动到index节点之前。
        ListNode curr = dummy;
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        newNode.next = curr.next;
        curr.next = newNode;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        ListNode curr = dummy;
        // 移动到index前一个节点
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        curr.next = curr.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```
## 206.反转链表
### 题目:
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 单链表的操作,定义三个节点.prev,用于表示前驱节点;curr,表示当前节点;next,用于表示后继节点.next用于保存curr.next,因为反转节点意味着更新curr的指向,所以需要先保存`curr.next`!同时,prev需要一直保存前驱节点,使得能实现反转!
- **1)先保存curr.next; 2)更新curr的指向; 3)更新前驱prev和curr.**
### 关键点:
- **定义next或temp用于保存curr.next!!!!** 
- 操作curr.next时,需要判断curr是否为空.所以循环条件为curr!=null.
### 代码:
```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode prev = null;  
        ListNode cur = head;  
        ListNode next = null;  
        while (cur != null){  
            next = cur.next;  
            cur.next = prev;  
            
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
}
```


## 24.两两交换链表中的节点
### 题目:
- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路一：
定义虚拟头节点，方便对头节点执行交换操作。

注意，在交换过程中，**节点2到节点3的指针**和**节点0到节点1的指针**会断，所以此时必须提前保存节点1和节点3.

为了方便操作，我们可以提前保存`node0``node1``node2``node3`，不过node2的提前保存，是为了操作的便利性与美观，即使不保存也可以完成所有的交换逻辑。（见思路二）

**三步交换：**
1. `node0→node2`（这一步，0到1的指针断了，故需要提前保存）
2. `node2→node1`（在这一步，2到3的指针断掉，故需要提前保存）
3. `node1→node3`（将node1的下一位更新为提前保存好的node3节点）

**node节点更新操作：**
因为节点交换后，链表变为`(0)→2→1→3→4`，所以更新操作为：
1. `node0 = node1`；
2. `node1 = node3`

![[Pasted image 20241206151338.png|400]]
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            ListNode node2 = node1.next;
            ListNode node3 = node2.next;

            node0.next = node2;
            node2.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
### 思路二：
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            // ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node0.next = node1.next;
            node1.next.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
## 19.删除链表的倒数第N个节点 
### 题目:
- 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
### 信息:
- **难度**:medium
- **重要性:** #★★★☆☆
### 思路一：快慢指针
利用快慢指针获取倒数第n个节点。
**证明：**
设链表长度为size，则要到达倒数第n个节点，需要正向遍历size-n次。

所以，先让快指针向右移动n次，然后快慢指针再同时移动。此时快指针只能再向后移动$size-n$次。那么此时，慢指针与快指针同步移动，代表着慢指针也只能移动$size-n$次！

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        ListNode dummy = new ListNode(0,head);
        ListNode r = dummy;
        // r先移动n次
        while (n > 0){
            r = r.next;
            n--;
        }
        ListNode l = dummy;
        while (r.next != null){
            r = r.next;
            l = l.next;
        }
        if (l.next.next != null) l.next = l.next.next;
        else l.next = null;

        return dummy.next;
    }
}
```
### 思路二：两次遍历
第一次遍历，先获取链表尺寸；
第二次遍历，根据sz-n，移动到指定位置进行删除操作。
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 难点在于：如何找到第n个结点？
        // 两次遍历:第一次获取size,第二次遍历size-n次即可.
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        int sz = 0;
        while (curr.next != null){
            curr = curr.next;
            sz++;
        }
        curr = dummy;
        for (int i = 0; i < sz-n; i++){
            curr = curr.next;
        }
        if (curr.next.next != null) curr.next = curr.next.next;
        else curr.next = null;

        return dummy.next;
    }
}
```
## 面试题 02.07. 链表相交
### 题目:
- 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路一：双指针
将两条链表相连，可以使他们走过相同长度的路径。

当指针curr指向null时，切换到另一条链表遍历，最后会出现两种情况：
- 存在相交节点，此时指针currA和currB会指向同一个节点，退出循环；
- 不存在相交节点，此时currA和currB会同时指向null，退出循环。
所以最终直接返回currA或currB即可。
```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode currA = headA;  
        ListNode currB = headB;  
        while (currA != currB){  
            if (currA != null) {  
                currA = currA.next;  
            }else {  
                currA = headB;  
            }  
            if (currB != null) {  
                currB = currB.next;  
            }else {  
                currB = headA;  
            }  
        }  
        return currA;  
    }  
}
```
### 思路二：利用Set判重
利用Set判重：
- 假设有相交节点，那么代表一定会添加重复节点，此时返回该节点即可；
- 利用`change`变量，避免在另一条链表中重复遍历。（假设无change变量判断，那么在更换到另一条链表遍历时，到达null后会再次循环。）
```java 
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode curr = headA;
        boolean change = false;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
                if (curr == null && !change){
                    curr = headB;
                    change = true;
                }    
            }else {
                return curr;
            }
        }
        return null;
    }
}
```
## 142. 环形链表II
### 题目:
- 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。**不允许修改链表。** 
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路一：
- 带有考察数学知识的题目.需要进行细心的推理!**首先**,明确一点,当有环时,可以转化为一个追赶问题,即**步长为2的快指针一定会追赶上步长为1的慢指针**,因为他们之间的距离是以不断减1的!据此,是否有环的逻辑完成,接下来就是判断环的起点!这里用一个图和公式进行说明:![[LinkedListPart2_img2.png]]
当**快慢指针相遇**时,有以下情况:
- 慢指针走过的节点数为$x+y$,快指针走过的节点数为$x+y+n(y+z)$,并且由于慢指针的步长为1,快指针的步长为2,所以有$(x+y)\times2=x+y+n(y+z)$
- 据此可推出→ $x+y=n(y+z)$.即头节点到环形入口节点的节点数目$x=n(y+z)-y$
- 理解一下,当n=1时,此时$x=z$;当n≠1时,此时$x=n(y+z)-y$,即走过了n个环的节点数$n(y+z)$-环形入口到相遇节点的节点数y.
```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        if (head == null || head.next == null) {  
            return null;  
        }  
        ListNode fast = head;  
        ListNode slow = head;  
  
        while (fast != null && fast.next != null){  
            fast = fast.next.next;  
            slow = slow.next;  
  
            if (fast == slow) {  
                slow = head;  
  
                while (fast != slow) {  
                    fast = fast.next;  
                    slow = slow.next;  
                }  
                return fast;  
            }  
        }  
        return null;  
    }  
}

```
### 思路二：O(n)空间复杂度解决
利用Set判重：
- 当set添加失败后，则说明当前节点是入口，返回该节点即可。
- 如果一直添加失败，说明无环，返回null.
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 思路一：O(n)复杂度解决，利用Set判重。
        Set<ListNode> set = new HashSet<>();
        ListNode curr = head;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
            }else {
                return curr;
            }
        }
        return null;
    }
}
```