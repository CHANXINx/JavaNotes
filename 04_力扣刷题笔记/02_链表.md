## 203.移除链表元素
### 题目:
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
**输入:head = `[1,2,6,3,4,5,6]`, val = 6 输出：**`[1,2,3,4,5]`
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆

### 思路一：哨兵节点

**涉及到删除操作，一般需要考虑哨兵节点。**

执行删除节点node操作，可以通过修改next指针完成，所以应该在node的前一个节点处执行删除操作。

考虑到头节点没有“前一个节点”，所以必须使用哨兵节点dummy。

**具体如何执行？**
- 从哨兵节点开始遍历，判断其next节点的值是否为val：若是，则删除；若不是，往后遍历；
- 若成功删除，此时无需更新curr指针，因为在删除时已经更新过一次curr指针！若再次更新，则会错过节点。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null){
            if (curr.next.val == val){
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
            
        }
        return dummy.next;
    }
}
```

## 707.设计链表
### 题目:
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路一：
- 定义虚拟头节点，此时无论是添加节点到头部、还是删除头部节点，都会更方便。
- **初始化链表**：因为是无参构造器，所以直接初始化虚拟头节点与size即可。
- 要删除某个节点、添加节点到某个位置，都要注意**健壮性保证**：idx不能小于0，也不能大于等于size。
- **对于index的遍历，`for(int i = 0; i <=index; i++)`会刚好移动到`index`节点上！而对于添加到末尾，则直接`for(int i = 0; i < size; i++)`也会刚好移动到末尾。**
- 注意需要不断维护size的大小。

```java
class ListNode{
    int val;
    ListNode next;

    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
    public ListNode(int val,ListNode next){
        this.val = val;
        this.next = next;
    }
}

class MyLinkedList {
    private ListNode dummy;
    private int size;

    public MyLinkedList() {
        dummy = new ListNode(0);
        size = 0;
    }
    
    public int get(int index) {
        if (index >= size || index < 0) return -1;
        // 将curr移动到需要返回的节点上
        ListNode curr = dummy;
        for (int i = 0; i <= index; i++){
            curr = curr.next;
        }
        return curr.val;
    }
    
    public void addAtHead(int val) {
        ListNode newHead = new ListNode(val);
        // 更换头节点
        newHead.next = dummy.next;
        dummy.next = newHead;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);
        // 移动到末尾节点。
        ListNode curr = dummy;
        for (int i = 0; i < size; i++){
            curr = curr.next;
        }
        curr.next = tail;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        // 超出长度，不会插入
        if (index > size) return;
        // 插入到末尾
        if (index == size) {addAtTail(val);return;}
        
        ListNode newNode = new ListNode(val);
        // 移动到index节点之前。
        ListNode curr = dummy;
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        newNode.next = curr.next;
        curr.next = newNode;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        ListNode curr = dummy;
        // 移动到index前一个节点
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        curr.next = curr.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```
## 206.反转链表
### 题目
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
不涉及到头节点的增、删，无需使用哨兵节点。
涉及到操作`node.next`，必须使用next变量提前保存节点。

**具体算法流程：**
![[Pasted image 20241213102208.png]]

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode prev = null;  
        ListNode cur = head;  
        ListNode next = null;  
        while (cur != null){  
            next = cur.next;  
            cur.next = prev;  
            
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
}
```
## 25. K 个一组翻转链表
### 题目
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #链表 #递归 
### 思路一：
![[Pasted image 20241215122040.png]]
**具体算法流程：**
1. 获取链表长度，便于判断剩余节点是否大于k；
2. k个一组翻转链表；
3. 翻转后的节点与后续链表的进行连接。
```java hl:23-26
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0,head);
        ListNode p0 = dummy;
        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null;

        int sz = 0;
        while (curr != null){
            curr = curr.next;
            sz++;
        }
        curr = head;
        for (; sz >= k; sz -= k){
            for (int i = 0; i < k; i++){
                next = curr.next;
                curr.next = prev;

                prev = curr;
                curr = next;
            }
            next = p0.next;
            p0.next.next = curr;
            p0.next = prev;
            p0 = next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 24.两两交换链表中的节点
### 题目:
- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路一：
定义虚拟头节点，方便对头节点执行交换操作。

注意，在交换过程中，**节点2到节点3的指针**和**节点0到节点1的指针**会断，所以此时必须提前保存节点1和节点3.

为了方便操作，我们可以提前保存`node0``node1``node2``node3`，不过node2的提前保存，是为了操作的便利性与美观，即使不保存也可以完成所有的交换逻辑。（见思路二）

**三步交换：**
1. `node0→node2`（这一步，0到1的指针断了，故需要提前保存）
2. `node2→node1`（在这一步，2到3的指针断掉，故需要提前保存）
3. `node1→node3`（将node1的下一位更新为提前保存好的node3节点）

**node节点更新操作：**
因为节点交换后，链表变为`(0)→2→1→3→4`，所以更新操作为：
1. `node0 = node1`；
2. `node1 = node3`

![[Pasted image 20241206151338.png|400]]
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            ListNode node2 = node1.next;
            ListNode node3 = node2.next;

            node0.next = node2;
            node2.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
### 思路二：
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            // ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node0.next = node1.next;
            node1.next.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
## 19.删除链表的倒数第N个节点 
### 题目:
- 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
### 信息:
- **难度**:medium
- **重要性:** #★★★☆☆
### 思路一：快慢指针
利用快慢指针获取倒数第n个节点。
**证明：**
设链表长度为size，则要到达倒数第n个节点，需要正向遍历size-n次。

所以，先让快指针向右移动n次，然后快慢指针再同时移动。此时快指针只能再向后移动$size-n$次。那么此时，慢指针与快指针同步移动，代表着慢指针也只能移动$size-n$次！

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        ListNode dummy = new ListNode(0,head);
        ListNode r = dummy;
        // r先移动n次
        while (n > 0){
            r = r.next;
            n--;
        }
        ListNode l = dummy;
        while (r.next != null){
            r = r.next;
            l = l.next;
        }
        // if (l.next.next != null) l.next = l.next.next;
        // else l.next = null;
        l.next = l.next.next;
        

        return dummy.next;
    }
}
```
### 思路二：两次遍历
第一次遍历，先获取链表尺寸；
第二次遍历，根据sz-n，移动到指定位置进行删除操作。
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 难点在于：如何找到第n个结点？
        // 两次遍历:第一次获取size,第二次遍历size-n次即可.
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        int sz = 0;
        while (curr.next != null){
            curr = curr.next;
            sz++;
        }
        curr = dummy;
        for (int i = 0; i < sz-n; i++){
            curr = curr.next;
        }
        if (curr.next.next != null) curr.next = curr.next.next;
        else curr.next = null;

        return dummy.next;
    }
}
```
## 141. 环形链表
### 题目
给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：快慢指针
**弗洛伊德判圈问题**！

定义快慢指针，快指针每次走2步，慢指针每次走1步。若有环，则二者最终会相遇。

**具体算法流程：**
1. 定义slow和fast指针起点相同；
2. 循环退出条件为`fast==null || fast.next ==null`，即存在null节点。（fast.next == null是为了保证接下来更新操作的正确）
3. slow每次走1步，fast每次走2步；
4. 若出现相等，则返回true；若fast出现null，则退出循环，返回false。
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 
## 面试题 02.07. 链表相交
### 题目:
- 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
### 信息:
- **难度：** easy
- **重要性：** #★★★☆☆
### 思路一：双指针
将两条链表相连，可以使他们走过相同长度的路径。

当指针curr指向null时，切换到另一条链表遍历，最后会出现两种情况：
- 存在相交节点，此时指针currA和currB会指向同一个节点，退出循环；
- 不存在相交节点，此时currA和currB会同时指向null，退出循环。
所以最终直接返回currA或currB即可。
```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode currA = headA;  
        ListNode currB = headB;  
        while (currA != currB){  
            if (currA != null) {  
                currA = currA.next;  
            }else {  
                currA = headB;  
            }  
            if (currB != null) {  
                currB = currB.next;  
            }else {  
                currB = headA;  
            }  
        }  
        return currA;  
    }  
}
```
### 思路二：利用Set判重
利用Set判重：
- 假设有相交节点，那么代表一定会添加重复节点，此时返回该节点即可；
- 利用`change`变量，避免在另一条链表中重复遍历。（假设无change变量判断，那么在更换到另一条链表遍历时，到达null后会再次循环。）
```java 
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode curr = headA;
        boolean change = false;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
                if (curr == null && !change){
                    curr = headB;
                    change = true;
                }    
            }else {
                return curr;
            }
        }
        return null;
    }
}
```
## 142. 环形链表II
### 题目
- 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。**不允许修改链表。** 
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- 
### 思路一：快慢指针
- 带有考察数学知识的题目.需要进行细心的推理!**首先**,明确一点,当有环时,可以转化为一个追赶问题,即**步长为2的快指针一定会追赶上步长为1的慢指针**,因为他们之间的距离是以不断减1的!据此,是否有环的逻辑完成,接下来就是判断环的起点!这里用一个图和公式进行说明:![[LinkedListPart2_img2.png]]
当**快慢指针相遇**时,有以下情况:
- 慢指针走过的节点数为$x+y$,快指针走过的节点数为$x+y+n(y+z)$,并且由于慢指针的步长为1,快指针的步长为2,所以有$(x+y)\times2=x+y+n(y+z)$
- 据此可推出→ $x+y=n(y+z)$.即头节点到环形入口节点的节点数目$x=n(y+z)-y$
- 理解一下,当n=1时,此时$x=z$;当n≠1时,此时$x=n(y+z)-y$,即走过了n个环的节点数$n(y+z)$-环形入口到相遇节点的节点数y.
```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        if (head == null || head.next == null) {  
            return null;  
        }  
        ListNode fast = head;  
        ListNode slow = head;  
  
        while (fast != null && fast.next != null){  
            fast = fast.next.next;  
            slow = slow.next;  
  
            if (fast == slow) {  
                slow = head;  
  
                while (fast != slow) {  
                    fast = fast.next;  
                    slow = slow.next;  
                }  
                return fast;  
            }  
        }  
        return null;  
    }  
}

```
### 思路二：O(n)空间复杂度解决
利用Set判重：
- 当set添加失败后，则说明当前节点是入口，返回该节点即可。
- 如果一直添加失败，说明无环，返回null.
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 思路一：O(n)复杂度解决，利用Set判重。
        Set<ListNode> set = new HashSet<>();
        ListNode curr = head;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
            }else {
                return curr;
            }
        }
        return null;
    }
}
```

## 287. 寻找重复数
### 题目
给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

	输入：nums = [1,3,4,2,2]
	输出：2
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #数组 #二分查找 #双指针 
### 思路一：构造链表
思路很牛逼。因为题目所给条件为数组下标由`[0,n+1]`，而数组的值为`0,n`。因此，若根据数组的值与下标构建映射关系，不会出现越界的情况。即不会出现：数组索引为`0,3`，而数组的值出现`nums[i] == 4`的情况。

根据上述推断，我们可以构建`i -> nums[i]`的映射关系。对于`[1,3,4,2,2]`，就可以构建出**环形链表**：![[Pasted image 20250109110043.png]]
既然已经构建出了环形链表，那么就转换为了“**龟兔赛跑问题**”！使用**Floyd判圈算法**求解！！！
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast){
            // slow走一步，fast走两步
            slow = nums[slow];
            fast =nums[nums[fast]];
        }
        // 相遇后，slow从头开始
        slow = 0;
        while (fast != slow){
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 
## 234. 回文链表
### 题目
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：转换为list判回文
将链表判回文**转换为数组判回文**！转换后利用双指针判是否回文即可！！！
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        int n = 0;
        ListNode curr = head;
        List<Integer> nums = new ArrayList<>();
        // 获取值列表
        while (curr != null){
            nums.add(curr.val);
            curr = curr.next;    
        }
        int l = 0;
        int r = nums.size()-1;
        while (l < r){
            if (nums.get(l++) != nums.get(r--)) return false;
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：通过翻转链表转换为两个链表判相等

**具体算法流程：**
- 获取链表长度，将后半部分链表翻转；
- 翻转链表后，转换为两个链表判相等的问题。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode curr1 = head;
        int n = 0;
        // 获取链表长度
        while (curr1 != null){
            n++;
            curr1 = curr1.next;
        }
        // 寻找中间节点
        ListNode curr2 = head;
        for (int i = 0; i < n/2; i++){
            curr2 = curr2.next;
        }
        ListNode prev = null;
        ListNode next = null;
         
        // 翻转后半部分链表
        while (curr2 != null){
            next = curr2.next;
            curr2.next = prev;

            prev = curr2;
            curr2 = next;
            
        }
        // 转换为两个链表判相等
        curr1 = head;
        curr2 = prev;
        while(curr1 != null && curr2 != null){
            if (curr1.val != curr2.val) return false;
            curr1 = curr1.next;
            curr2 = curr2.next;
        }
        return true;
    }
}
```


## 21. 合并两个有序链表
### 题目
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 
### 思路一：双指针
定义dummy节点，便于返回最终头节点。

**具体算法流程：**
- 当$list1$和$list2$均不为空时，比较$list1$和$list2$的值，$curr.next$指向较小一个；然后更新$list1$或$list2$，更新$curr$。
- 若某一个为空，则$curr.next$直接执行不为空的$list$。

>**注意，直接操作list节点即可，无需使用额外curr1指向list1。**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null){
            return list1 == null ? list2 : list1;
        }
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        
        while (list1 != null && list2 != null){
            if (list1.val < list2.val){
                curr.next = list1;
                list1 = list1.next;
            }else {
                curr.next = list2;
                list2 = list2.next;
            }
            curr = curr.next;
        }
        curr.next = list1 == null ? list2 : list1;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(M+N)$ 
**空间复杂度：** $O(1)$

## 2. 两数相加
### 题目
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
利用car变量保存进位；构建新节点时，利用$car\%10$获取个位；利用$car/10$获取十位（**`car>=10`时，进位为1，`car<10`时，进位为0，所以可以通过car/=10获取！**）

**具体算法流程：**
1. 当`l1 != null || l2 != null || car != 0`时进入循环，此时都需要构建新节点；
2. 利用car变量保存`进位+l1+l2`的值；
3. 构建新节点：节点值为$car\%10$；
4. $car/=10$获取进位，开始下一次循环。
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        int car = 0;
        while (l1 != null || l2 != null || car != 0){
            if (l1 != null){
                car += l1.val;
                l1 = l1.next;
            }
            if (l2 != null){
                car += l2.val;
                l2 = l2.next;
            }
            curr.next = new ListNode(car % 10);
            car /= 10;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$，返回值不计入。
### 思路二：递归
递归解决子问题，需要传递进位。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwo(l1,l2,0);
    }
    ListNode addTwo(ListNode l1, ListNode l2, int car){
        if (l1 == null && l2 == null){
            return car == 0 ? null : new ListNode(car);
        }
		// 交换l1和l2，避免后面l1.next的分类讨论，简化代码。
        if (l1 == null){
            l1 = l2;
            l2 = null;
        }
        int sum = l1.val + car + (l2 == null ? 0 : l2.val);

        l1.val = sum % 10;
        l1.next = addTwo(l1.next,l2 == null ? null : l2.next,sum / 10);
        return l1;
    }
}
```
## 138. 随机链表的复制
### 题目
给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
![[Pasted image 20241216113122.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #哈希表 
### 思路一：哈希表
**利用哈希表存储原节点和新节点的对应关系**，之后再遍历原链表，根据链表的顺序连接新链表。

```java
class Solution {
    public Node copyRandomList(Node head) {
        
        Node curr = head;
        Map<Node,Node> map = new HashMap<>();
        while(curr != null){
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }
        curr = head;
        while (curr != null){
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        return map.get(head);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：交错链表
**具体算法流程：**
1. 将原链表更新成交错链表：
![[Pasted image 20241216130441.png|600]]
2. 根据原链表的random，设置新链表的random；
3. 最后恢复原链表！
```java

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        Node curr = head;
        // 1. 设置交错链表
        while (curr != null){
            Node newNode = new Node(curr.val);
            Node tmp = curr.next;
            curr.next = newNode;
            newNode.next = tmp;
			
            // curr.next = new Node(curr.val, curr.next);

            curr = curr.next.next;
        }
        //  2. 根据原节点设置新节点的random
        curr = head;
        while (curr != null){
            if (curr.random != null){
                curr.next.random = curr.random.next;
            }
            curr = curr.next.next;
        }
        // 3. 构建新链表，恢复原链表
        Node newHead = head.next; // 开头保证了head != null
        curr = head;
        while (curr.next.next != null){
            Node copy = curr.next;
            curr.next = copy.next;
			copy.next = copy.next.next;    // 保证curr.next.next != null

            curr = curr.next;
        }
        curr.next = null;
        return newHead;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 23. 合并 K 个升序链表
### 题目
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
### 信息
- **难度：** hard
- **重要性：** #★★★★☆
- **标签：** #链表 #堆（优先级队列） #排序 
### 思路一：小根堆
因为K个链表都是升序的，所以当前的最小值只可能出现在头节点中。因此：
1. 将K个链表的头节点都加入优先队列中；
2. 当某个链表的头节点被弹出后，将其的next节点也加入到链表中；
3. 直至K个链表都为空。
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // 按节点值升序排列
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        // 添加头节点
        for (ListNode node : lists){
            if (node != null) pq.add(node);
        }
        ListNode dummy = new ListNode();
        ListNode curr = dummy;
        while (!pq.isEmpty()){
            // 取最小值
            ListNode min = pq.poll();
            curr.next = min;
            // 将对应链表的下个节点也加入堆中
            if (min.next != null){
                pq.add(min.next);
            }
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$

## 148. 排序链表
### 题目
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 #分治 #排序 #归并排序
### 思路一：优先队列
使用优先队列将链表按值由小到大排序，然后利用哨兵节点连接排序后的节点。最后记得断开末尾节点的next指针。
```java
class Solution {
    public ListNode sortList(ListNode head) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        ListNode curr = head;
        while (curr != null){
            pq.add(curr);
            curr = curr.next;
        }
        ListNode dummy = new ListNode();
        curr = dummy;
        while (!pq.isEmpty()){
            curr.next = pq.poll();
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路二：使用ArrayList进行排序
```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        ListNode curr = head;
        while (curr != null){
            list.add(curr);
            curr = curr.next;
        }
        Collections.sort(list,(a,b) -> a.val - b.val);
        ListNode dummy = new ListNode();
        curr = dummy;
        for (ListNode node : list){
            curr.next = node;
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路三：归并排序

## 146. LRU 缓存
### 题目
请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #链表 #哈希表 
### 思路一：循环双向链表+哈希表
**先明确几个关键点：**
1. 使用的是双向循环链表，便于快速获取尾节点；
2. 链表节点需要存储Key值，是为了在Map中定位节点并删除（`map.remove(lastNode.key)`）；
	- 如果只有value，那么因为value是可能重复的，则无法在map中定位并获取节点。
3. 需要定义三个私有方法：`getNode()`、`remove()`、`pushFront()`；并且每次`getNode()`都需要`remove&pushFront`!
```java
class Node {
    Node next,prev;
    int val,key;
    public Node (){}
    public Node (int key, int value){
        this.key = key;
        this.val = value;
    }

}
class LRUCache {
    private Map<Integer,Node> map;
    private Node dummy;
    private int capacity;
    public LRUCache(int capacity) {
        map = new HashMap<>();
        dummy = new Node(0,0);
        dummy.next = dummy;
        dummy.prev = dummy;
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node curr = getNode(key);
        return curr == null ? -1 : curr.val;
    }
    
    public void put(int key, int value) {
        Node curr = getNode(key);
        if (curr != null){
            curr.val = value;
            return;
        }
        curr = new Node(key,value);
        map.put(key,curr);
        pushFront(curr);
        if (map.size() > capacity){
            Node last = dummy.prev;
            map.remove(last.key);
            remove(last);
        }
    }

    private Node getNode(int key){
        if (!map.containsKey(key)){
            return null;
        }
        Node node = map.get(key);
        remove(node);
        pushFront(node);
        return node;
    }
    private void remove(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    private void pushFront(Node node){
        node.next = dummy.next;
        dummy.next.prev = node;
        dummy.next = node;
        node.prev = dummy;
        
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

```
**时间复杂度：** 
**空间复杂度：** 

