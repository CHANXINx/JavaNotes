## 704. 二分查找
### 信息:
- **难度**:easy
- **重要性:** #★☆☆☆☆ 
### 思路: 
- **定义`head`和`end`节点**, 即二分中的头和尾. **将`index`定义为`(head+end/2)`;
- 此时即判断`nums[index]`与`target`的关系, 若小于`target`, 则说明在二分中的右半部分, 此时将head置为`index+1`. 此时继续在右半部分重复上述判断, 直到找到`target`退出循环或数组中没有等于`target`的值而退出.
### 代码:
```java
class Solution {  
    public int search(int[] nums, int target) {  
        int head = 0;  
        int end = nums.length - 1;  
        while (head <= end){  
            int index = (head + end) / 2;  
            if (nums[index] == target)  
                return index;  
            if (nums[index] < target){  
                head = index + 1;  
            }else if (nums[index] > target)  
                end = index - 1;  
        }  
        return -1;  
    }  
}
```
## 27. 移除元素
### 信息:
- **难度**:easy
- **重要性:** #★★★☆☆ 
### 思路:
>双指针经典题目，与[[移除零]]是一样的。

**使用r指针寻找不等于val的元素**，找到了则直接放置于l指针处。这里注意，我们**只需要关注不等于val的元素**，所以r指针从0遍历到n-1，就可以找到所有不等于val的元素，并正确放置于开头。

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int l = 0, r = 0;
        while (r < nums.length){
            if (nums[r] != val){
                nums[l] = nums[r];
                l++;
            }
            r++;
        }
        return l;
    }
}
```
## 26. 删除有序数组中的重复项
### 信息:
- **难度**:easy
- **重要性:** #★★★★☆
### 思路一：
利用双指针遍历，r指针用于寻找不相等的元素。因为`nums[0]`肯定是不变的，所以赋值的话需要从`nums[1]`开始赋值。

那么如何寻找不重复的元素呢？首先定义l指针为0，r指针从1开始向右寻找，若发现不重复元素，则从`nums[1]`开始赋值：`nums[++l] = nums[r]`。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 1) return 1;
        int l = 0, r = 1;
        while (r < nums.length){
            // 往后找到不等于nums[l]的元素。
            if (nums[l] != nums[r]){
                nums[++l] = nums[r];
            }
            r++;
        }
        return l+1;
    }
}
```

### 思路二：
依旧是从下标1开始赋值，从下标1开始遍历，因为`nums[0]`的值肯定不变。

从`nums[1]`开始判断：
- 若`nums[i]==num[i-1]`，则此时说明是重复元素，往后继续判断；
- 若`nums[i]!=num[i-1]`，则说明出现了不重复元素，赋值到`nums[l]`。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int l = 1;
        for (int i = 1; i < nums.length; i++){
            if (nums[i] != nums[i-1]){
                nums[l] = nums[i];
                l++;
            }
        }
        return l;
    }
}
```



## 283. 移动零
### 题目:
- 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意, 必须在不复制数组的情况下原地对数组进行操作。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 注意,原地操作,故不能定义新数组.定义快慢指针,当出现非0元素时,则赋值给慢指针处. 最后多定义一个循环,将`slow+1-nums.leng-1`索引处的所有元素都赋0!
### 关键点:
- 较简单,略.
### 代码:
```
class Solution {  
    public void moveZeroes(int[] nums) {  
        int slow = 0,fast = 0;  
  
        while (fast < nums.length){  
            if (nums[fast] != 0){  
                nums[slow] = nums[fast];  
                slow++;  
            }  
            fast++;  
        }  
        for (int i = slow;i < nums.length;i++)  
            nums[i] = 0;  
    }  
}
```
## 844. 比较含退格的字符串
### 题目
- 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。注意：如果对空文本输入退格字符，文本继续为空。
### 信息
- **难度：** easy
- **重要性：** #★★★★★
### 思路一：
使用“栈”进行模拟退格。遇到"#"则弹出顶部元素！

注意健壮性保证：若开头就是"#"，则需要直接跳过。
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        return build(s).equals(build(t));
    }
    String build(String s){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++){
	        // 使用StringBuilder模拟退格
            if (s.charAt(i) == '#' ){
	            // 健壮性保证，避免开头就是'#'导致的错误。
                if (sb.length() > 0) sb.deleteCharAt(sb.length()-1);
                else continue;
            }else {
                sb.append(s.charAt(i));

            }
        }
        return sb.toString();
    }
}

```
>时间复杂度：$O(N+M)$
>空间复杂度：$O(N+M)$

### 思路二：
还有种思路，就是边模拟，边判断。
由于"#"是会删除前一个元素，对其后一个元素无影响，所以可以从后向前遍历。

从后往前遍历只会遇到三种情况：
1. 遇到字母且skip为0，退出循环比较该字符；
2. 遇到字母且skip不为0，那么需要消耗一个skip，并且继续往前遍历；
3. 遇到"#"，需要累加skip，并继续向前遍历。

比较字符时，也只会出现三种情况：
1. i和j均大于0：此时需要判断字符是否相等；
2. i和j其中一个小于0，另一个大于0：此时代表长度不相等，返回false；
3. i和j均小于0：此时元素全部被退格了，直接退出，返回true。
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] t1 = t.toCharArray();

        int i = s1.length-1;
        int j = t1.length-1;
        int skipS = 0;
        int skipT = 0;
        while (i >= 0 || j >= 0){
            while (i >= 0){
                if (s1[i] == '#'){
                    skipS++;
                    i--;
                }else if (skipS > 0){
                    skipS--;
                    i--;
                }else{
                    break;
                }
            }
            while (j >= 0){
                if (t1[j] == '#'){
                    skipT++;
                    j--;
                }else if (skipT > 0){
                    skipT--;
                    j--;
                }else{
                    break;
                }
            }
            // 一个大于0，一个小于0，此时返回false。
            if ((i >=0) != (j >= 0)) return false;
            if (i >= 0 && j >= 0 && s1[i] != t1[j]) return false;

            i--;
            j--;
        }
        return true;
    }
}
```
## 977.有序数组的平方
### 题目
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #数组 #双指针 #排序
### 思路一：库函数排序
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        for (int i = 0; i < nums.length; i++){
            nums[i] = nums[i] * nums[i];
        }
        Arrays.sort(nums);
        return nums;
    }
}
```
**时间复杂度：**$O(NlogN)$
**空间复杂度：**$O(1)$
### 思路二：相向双指针
最大值肯定出现在$nums[0]$和$nums[1]$ 之间，所以由大到小填入$ans$。

	如果从小到大放置元素，那么首先还得遍历到中间寻找最小的元素，思路较复杂。
 
**具体算法流程：**
1. 定义相向双指针$l$和$r$，分别指向左右两侧；
2. 计算平方结果，比较更大元素，存储在$ans$结果数组中，更大一侧的指针向中间移动；
3. 退出循环条件为$l$与$r$指向同一个元素。
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int idx = nums.length - 1;
        int l = 0;
        int r =idx;
        while (l <= r){
            int lPow = nums[l] * nums[l];
            int rPow = nums[r] * nums[r];
            if (lPow <= rPow){
                ans[idx] = rPow;
                r--;
            }else {
                ans[idx] = lPow;
                l++;
            }
            idx--;
        }
        return ans;
    }
}
```
**时间复杂度：$O(N)$**
**空间复杂度：$O(N)$**
## 209.长度最小的子数组
### 题目
给定一个含有 `n` 个正整数的数组和一个正整数 `target`.
找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ,并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #滑动窗口 #数组 
### 思路一：滑动窗口
寻找最小子数组问题，滑动窗口是常见思路，因为能遍历所有可能满足要求的子数组。

**具体算法流程：**
1. $r$指针向右移动，让窗口能满足要求，记录可能的$ans$；
2. $l$指针向右移动，使窗口不断缩小，若缩小后仍满足要求，则继续记录答案；否则继续移动$r$指针；
3. 循环上述操作。

若最终结果$ans == n+1$，说明不存在满足要求的子数组，返回0.
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int l = 0;
        int sum = 0;
        int ans = n+1;
        for (int r = 0; r < n; r++){
            sum += nums[r];
            while (sum >= target){
                ans = Math.min(r-l+1,ans);
                sum -= nums[l++];
            }
        }
        return ans == n + 1 ? 0 : ans;
    }
}
```
## 54. 螺旋矩阵
### 题目
给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #模拟  
### 思路一：
记住算了，I和II都可以套用这个模板，注意这几个要点即可：
1. while循环和for循环都是取`<=`；
2. t++和r--后，要进行健壮性判断，避免$t>b$或$r<l$。
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new ArrayList<>();
        int m = matrix.length;
        int n = matrix[0].length;
        int l = 0;
        int r = n-1;
        int t = 0;
        int b = m-1;
        
        while (l <= r && t <= b){
            for (int i = l; i <= r; i++){
                ans.add(matrix[t][i]);
            }
            t++;
            for (int i = t; i <= b; i++){
                ans.add(matrix[i][r]);
            }
            r--;
            if (t <= b){
                for (int i = r; i >= l; i--){
                    ans.add(matrix[b][i]);
                }
                b--;
            }
            if (r >= l){
                for (int i = b; i >= t; i--){
                    ans.add(matrix[i][l]);
                }
                l++;
            }
        }
        return ans;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 
## 59.螺旋矩阵II
### 题目:
- 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
- ![[ArrayPart2_img1.png]]
### 信息:
- **难度：**:Medium
- **重要性：** #★★★★★
- **标签：** #数组 #模拟  
### 思路一：
>这道题目可以说在面试中出现频率较高的题目，**本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。**
- 确认每次画一条线,然后明确边界条件.建议以4×4矩阵为例子.
- 循环不变量:遵循一个规则来处理每一条边.
- 此模拟方法只能对应模拟偶数矩阵，而对于奇数矩阵，需要额外赋值中间的。
```java
class Solution {  
    public int[][] generateMatrix(int n) {  
        int[][] matrix = new int[n][n];  
        int start = 0;  
        int end = n-1;  
        int count = 1;  
        while (start <= end) {  
            for (int i = start; i < end; i++) {  
                matrix[start][i] = count;  
                count++;  
            }  
            for (int i = start; i < end; i++) {  
                matrix[i][end] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[end][i] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[i][start] = count;  
                count++;  
            }  
            if (start == end)  
                matrix[start][end] = count;  
            start++;  
            end--;  
        }  
        return matrix;  
    }  
}  
```
## 15. 三数之和 
### 题目:
- 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
**注意：**答案中不可以包含重复的三元组。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
- **标签：** #数组 #双指针
### 思路一：相向双指针
对于有序数组求目标和问题，可以使用相向双指针。

三数之和，考虑将固定$nums[i]$，此时就可以**转换为两数之和问题**。基本思路确定，接下来确定具体算法流程。

具体算法流程：
1. 固定$nums[i]$，此时利用相向双指针，获取所有和为0的结果，指针移动逻辑为
	1) 若和大于0，则指针$k$左移；
	2) 若和小于0，在指针$j$右移；
	3) 若和等于0，则添加结果，并继续移动指针寻找对于$nums[i]$可能成立的三元组。

到这里，基本的寻找三元组问题已经完成，接下来考虑“去重”：
- 若$nums[i]==nums[i-1]$，则说明若有三元组，必然成对，因此应该跳过此时的$nums[i]$；
- 对于$nums[i]$，若找到三元组，则会执行`j++;k--;`，继续寻找可能的三元组。因此此时也需要去重逻辑：
	- 若$nums[j]==nums[j-1]$，则需要跳过当前$nums[j]$；
	- 若$nums[k] == nums[k+1]$，则需要跳过当前$nums[k]$；
	- 【即不与已经遍历过的$j/k$重复。】
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        
        List<List<Integer>> ans = new ArrayList<>();

        for (int i = 0; i < nums.length-2; i++){
            int x = nums[i];
            if (i > 0 && nums[i-1] == x) continue;
            int j = i+1;
            int k = nums.length-1;
            
            while (j < k){
                int sum = nums[i] + nums[j] + nums[k];
                if (sum > 0){
                    k--;
                }else if(sum < 0){
                    j++;
                }else {
                    ans.add(List.of(nums[i],nums[j],nums[k]));
                    j++;
                    while (j < k && nums[j] == nums[j-1]) j++;
                    k--;
                    while (k > j && nums[k] == nums[k+1]) k--;
                }
            }
        }
        return ans;
    }
}
```

## 18. 四数之和

### 题目:
给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 **任意顺序** 返回答案 。
### 信息:
- **难度**: medium
- **重要性：** #★★★★★
- **标签：** #数组 #双指针 
### 思路一：相向双指针
类似于三数字之和，本题使用嵌套循环固定住$nums[i]$和$nums[j]$，再使用相向双指针找到所有可能的四元组。

对于`nums[j]`的去重逻辑：除首个元素外，若出现$nums[j] == nums[j-1]$，则跳过。
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < nums.length-3; i++){
            // 1. 剪枝(1)
            if (nums[i] > 0 && nums[i] > target) break;

            if (i > 0 && nums[i] == nums[i-1]) continue;
            for (int j = i+1; j < nums.length-2; j++){
                // 2. 剪枝(2)
                if (nums[i] + nums[j] > 0 && nums[i] + nums[j] > target) break;

                if (j > (i+1) && nums[j] == nums[j-1]) continue;
                int k = j + 1;
                int l = nums.length-1;
                while (k < l){
                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum > target){
                        l--;
                    } else if (sum < target){
                        k++;
                    } else {
                        ans.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));
                        k++;
                        l--;
                        while (k < l && nums[k] == nums[k-1]) k++;
                        while (k < l && nums[l] == nums[l+1]) l--;
                    }
                }
            }
        }
        return ans;

    }
}
```

## 303. 区域和检索 - 数组不可变
### 题目
给定一个整数数组  `nums`，处理以下类型的多个查询:

1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #前缀和
### 思路一：
前缀和模板题，利用$sum$数组保存前$i$个元素和。此时若需要返回$[left,right]$的和，使用$sum[right]-sum[left]+nums[left]$即可。
```java
class NumArray {
    private int[] nums;
    private int[] sum;
    public NumArray(int[] nums) {
        this.nums = nums;
        this.sum = new int[nums.length];
        for (int i = 1; i < nums.length; i++){
            sum[i] = sum[i-1] + nums[i];
        }
    }
    
    public int sumRange(int left, int right) {
        return sum[right] - sum[left] + nums[left];    
    }
}
```
**查询时间复杂度：** $O(1)$

## 560. 和为 K 的子数组
### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 _该数组中和为 `k` 的子数组的个数_ 。

子数组是数组中元素的连续非空序列。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #前缀和 #数组 #哈希表 
### 思路一：
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int[] sums = new int[nums.length+1];
        for (int i = 0; i < nums.length; i++){
            sums[i+1] = sums[i] + nums[i];
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int s : sums){
            ans += map.getOrDefault(s-k,0);
            map.merge(s,1,Integer::sum);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 189. 轮转数组
### 题目
给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #双指针 #数学
### 思路一：分段翻转
灵神提供的思路，翻转模拟即可。
![[Pasted image 20241211153256.png|400]]
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        reverse(0,n-1,nums);
        reverse(0,k-1,nums);
        reverse(k,n-1,nums);

    }
    void reverse(int i, int j,int[] nums){
        while (i < j){
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
            i++;j--;
        }
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

### 思路二：额外空间复杂度
注意，需要使用`System.arraycopy()`函数进行复制！
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; i++){
            ans[(i+k)%n] = nums[i];
        }
        System.arraycopy(ans, 0, nums, 0, n);
    }
}
```

## 238. 除自身以外的数组乘积
### 题目
给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #前缀和 
### 思路一：
可以分3种情况：
1. 没有0：正常处理；
1. 只有1个0：为0的位置不为0，不为0的位置为0！
2. 有2个或以上个0：全为0！
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int zeroCnt = 0;
        int times = 1;
        for (int num : nums){
            if (num == 0) zeroCnt++;
            else {
                times *= num;
            }
        }
        if (zeroCnt == 0){
            for (int i = 0; i < nums.length; i++){
                nums[i] = times / nums[i];
            }   
        }else if (zeroCnt == 1){
            for (int i = 0; i < nums.length; i++){
                if (nums[i] == 0){
                    nums[i] = times;
                }else {
                    nums[i] = 0;
                }
            }
        }else {
            for (int i = 0; i < nums.length; i++){
                nums[i] = 0;
            }
        }
        return nums;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

### 思路二：前缀和
题目规定不能用除法，那么就使用前缀和进行求解。分别定义前缀和后缀，则$nums[i] = 前缀 \times 后缀$.
![[Pasted image 20241211161144.png|400]]

定义前缀为$pre[i]$，代表前i-1个数的乘积；后缀为$suf[i]$，代表$i \sim n-1$的乘积。

对两个边界的理解：
	这里的$pre[0]=1$和$suf[n-1]=1$其实就是前缀和中的=0，是一个作用。
$nums[0]=pre[0]\times suf[0]$：代表`nums[1]~nums[n-1]`的乘积，因为没有左乘积，所以应该置$pre[0]=1$来保证$suf[i]$ 不变。
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n];
        pre[0] = 1;
        for (int i = 1; i < n; i++){
            pre[i] = pre[i-1] * nums[i-1];
        }
        int[] suf = new int[n];
        suf[n-1] = 1;
        for (int i = n-2; i >= 0; i--){
            suf[i] = suf[i+1] * nums[i+1]; 
        }
        for (int i = 0; i < n; i++){
            nums[i] = pre[i] * suf[i];
        }
        return nums;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

### 思路三：前缀的继续优化
![[Pasted image 20241211163454.png|300]]
因为从前往后遍历，前面的前缀不会被再使用，因此可以使用pre变量来不停更新最新的前缀！

**具体算法流程：**
1. 先计算后缀；
2. 从头开始遍历，利用$pre$变量不断累乘更新前缀，并与后缀相乘获取结果。
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;

        int[] suf = new int[n];
        suf[n-1] = 1;
        for (int i = n-2; i >= 0; i--){
            suf[i] = suf[i+1] * nums[i+1]; 
        }
        int pre = 1;
        for (int i = 0; i < n; i++){
            suf[i] *= pre;
            pre *= nums[i]; 
        }
        return suf;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$，根据题意，suf为输出数组，不计入空间复杂度。

## 74. 搜索二维矩阵
### 题目
给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #模拟 
### 思路一：行列排除法
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int i = 0;
        int j = n-1;
        while (i < m && j >= 0 && matrix[i][j] != target){
            if (matrix[i][j] > target){
                j--;
            }else {
                i++;
            }
        }
        return i < m && j >= 0;
    }
}

```
**时间复杂度：** $O(M+N)$
**空间复杂度：** $O(1)$
## 240. 搜索二维矩阵 II
### 题目
编写一个高效的算法来搜索 `_m_ x _n_` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #模拟 
### 思路一：行列排除法
![[Pasted image 20241212151851.png|300]]
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int i = 0;
        int j = n-1;
        while (i < m && j >= 0){
            if (matrix[i][j] > target){
                j--;
            }else if (matrix[i][j] < target){
                i++;
            }else {
                return true;
            }
        }
        return false;
    }
}
```
**时间复杂度：** $O(M+N)$ 
**空间复杂度：** $O(1)$

## 48. 旋转图像
### 题目
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #数组 #模拟 
### 思路一：水平+对角线翻转
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n/2; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] = tmp;
            }
        }
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n-1-i; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n-1-j][n-1-i];
                matrix[n-1-j][n-1-i] = tmp;
            }
        }
    }
}
```
**时间复杂度：** $O(N^2)$
**空间复杂度：** $O(1)$

## 1847. 最近的房间
### 题目
一个酒店里有 `n` 个房间，这些房间用二维整数数组 `rooms` 表示，其中 `rooms[i] = [roomIdi, sizei]` 表示有一个房间号为 `roomIdi` 的房间且它的面积为 `sizei` 。每一个房间号 `roomIdi` 保证是 **独一无二** 的。

同时给你 `k` 个查询，用二维数组 `queries` 表示，其中 `queries[j] = [preferredj, minSizej]` 。第 `j` 个查询的答案是满足如下条件的房间 `id` ：

- 房间的面积 **至少** 为 `minSizej` ，且
- `abs(id - preferredj)` 的值 **最小** ，其中 `abs(x)` 是 `x` 的绝对值。

如果差的绝对值有 **相等** 的，选择 **最小** 的 `id` 。如果 **没有满足条件的房间** ，答案为 `-1` 。

请你返回长度为 `k` 的数组 `answer` ，其中 `answer[j]` 为第 `j` 个查询的结果。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #数组 #排序 #有序集合 #离线算法
### 思路一：
将queries按照$minSize$降序排列，rooms也按照房间size降序排列。

根据minSIze从大到小遍历query，将rooms中比minSize大的房间都放入有序集合中。
```java
class Solution {
    public int[] closestRoom(int[][] rooms, int[][] queries) {
        Arrays.sort(rooms, (a, b) -> (b[1] - a[1]));
        
        int q = queries.length;
        Integer[] queryIds = new Integer[q];
        Arrays.setAll(queryIds, i -> i);
        Arrays.sort(queryIds, (i,j) -> queries[j][1] - queries[i][1]);
        
        int[] ans = new int[q];
        Arrays.fill(ans,-1);

        TreeSet<Integer> roomIds = new TreeSet<>();
        
        int idx = 0;
    
        for (int i : queryIds){
            int preId = queries[i][0];
            int minSz = queries[i][1];

            while (idx < rooms.length && minSz <= rooms[idx][1]){
                roomIds.add(rooms[idx][0]);
                idx++;
            }
            int diff = Integer.MAX_VALUE;

            Integer floor = roomIds.floor(preId);
            Integer ceil = roomIds.ceiling(preId);

            if (floor != null){
                diff = Math.min(preId - floor,diff);
                ans[i] = floor;
            }
            if (ceil != null){
                if ((ceil - preId) < diff){
                    ans[i] = ceil;
                }
            }
        }

        return ans;
    }
}
```
## 1387. 将整数按权重排序
### 题目
我们将整数 `x` 的 **权重** 定义为按照下述规则将 `x` 变成 `1` 所需要的步数：

- 如果 `x` 是偶数，那么 `x = x / 2`
- 如果 `x` 是奇数，那么 `x = 3 * x + 1`

比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

给你三个整数 `lo`， `hi` 和 `k` 。你的任务是将区间 `[lo, hi]` 之间的整数按照它们的权重 **升序排序** ，如果大于等于 2 个整数有 **相同** 的权重，那么按照数字自身的数值 **升序排序** 。

请你返回区间 `[lo, hi]` 之间的整数按权重排序后的第 `k` 个数。

注意，题目保证对于任意整数 `x` `（lo <= x <= hi）` ，它变成 `1` 所需要的步数是一个 32 位有符号整数。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #排序 #记忆化搜索
### 思路一：
```java
class Solution {
    private static final Map<Integer, Integer> memo = new HashMap<>();

    public int getKth(int lo, int hi, int k) {
        Integer[] nums = new Integer[hi - lo + 1];
        Arrays.setAll(nums, i -> i + lo);
        Arrays.sort(nums, (x, y) -> dfs(x) - dfs(y)); // 稳定排序
        return nums[k - 1];
    }

    private int dfs(int i) {
        if (i == 1) {
            return 0;
        }
        if (memo.containsKey(i)) { // 之前计算过
            return memo.get(i);
        }
        if (i % 2 == 1) {
            memo.put(i, dfs((i * 3 + 1) / 2) + 2);
        } else {
            memo.put(i, dfs(i / 2) + 1);
        }
        return memo.get(i);
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
## 35. 搜索插入位置
### 题目
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。
### 信息
- **难度：** easy
- **重要性：** #★☆☆☆☆
- **标签：** #二分查找 #数组  
### 思路一：二分查找模板题
- 定义左右指针：`l=0,r=n-1`；
- 闭区间循环判断：`while(l <= r)`
- 条件判断：`nums[m] < target`
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        while (l <= r){
            int m = l + (r-l) / 2;
            if (nums[m] < target){
                l = m + 1;
            }else{
                r = m - 1;
            }
        }
        return l;
    }
}
```
**时间复杂度：** $O(logN)$
**空间复杂度：** $O(1)$
## 34. 在排序数组中查找元素的第一个和最后一个位置
### 题目
给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #二分查找 
### 思路一：
```java


```
**时间复杂度：** 
**空间复杂度：** 

## 729. 我的日程安排表 I
### 题目
实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成 **重复预订** ，则可以存储这个新的日程安排。

当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 **重复预订** 。

日程可以用一对整数 `startTime` 和 `endTime` 表示，这里的时间是半开区间，即 `[startTime, endTime)`, 实数 `x` 的范围为，  `startTime <= x < endTime` 。

实现 `MyCalendar` 类：
- `MyCalendar()` 初始化日历对象。
- `boolean book(int startTime, int endTime)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #线段树 
### 思路一：遍历判断
利用List存储订阅区间，需要加入区间时，遍历list判断是否有交叉。
因为是订阅区间是左闭右开，因此在判断时：①`startTime ≥ book[1]`时，可放入区间，因为`book[1]`是开区间；②`endTime <= book[0]`也满足，因为endTime是开区间。
```java
class MyCalendar {
    List<int[]> cal;
    public MyCalendar() {
        cal = new ArrayList<>();
    }
    
    public boolean book(int startTime, int endTime) {
        for (int[] book : cal){
            if (startTime >= book[1] || endTime <= book[0]){
                continue;
            }else {
                return false;
            }
        }
        cal.add(new int[]{startTime,endTime});
        return true;
    }
}
```
**时间复杂度：** $O(N^2)$
**空间复杂度：** $O(N)$
### 思路二：类B树
使用二叉树来减少遍历次数。节点存储区间，左侧子树存储根节点左侧的区间，右侧子树存储根节点右侧的区间。
- 当发现树为空，此时还未订阅，则直接将当前订阅作为根节点；
- 若树不为空，则调用insert方法递归插入到树中：
	- 若区间有重叠，则直接返回false；
	- 若区间在节点左侧，则递归插入到左树中；
	- 若区间在节点右侧，则递归插入到右树中。
```java
class TreeNode{
    TreeNode left;
    TreeNode right;
    int[] val;
    
    public TreeNode(int[] val){
        this.val = val;
    }
}
class MyCalendar {
    TreeNode root;
    public MyCalendar() {
        root = null;
    }
    
    public boolean book(int startTime, int endTime) {
        if (root == null){
            root = new TreeNode(new int[]{startTime,endTime});
            return true;
        }else {
            return insert(root, startTime, endTime);
        }
    }

    private boolean insert(TreeNode root, int startTime , int endTime){
        int l = root.val[0];
        int r = root.val[1];
        if (startTime < l && endTime > r){
            return false;
        }
        if (endTime <= l){
            if (root.left == null){
                root.left = new TreeNode(new int[]{startTime,endTime});
                return true;
            }else {
                return insert(root.left, startTime, endTime);
            }
        }
        if (startTime >= r){
            if (root.right == null){
                root.right = new TreeNode(new int[]{startTime,endTime});
                return true;
            }else {
                return insert(root.right, startTime, endTime);
            }
        }
        return false;
    }
}
```
**时间复杂度：** $O(logN)$
**空间复杂度：** $O(N)$

## 2274. 不含特殊楼层的最大连续楼层数
### 题目
Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 **特殊楼层** ，仅用于放松。

给你两个整数 `bottom` 和 `top` ，表示 Alice 租用了从 `bottom` 到 `top`（含 `bottom` 和 `top` 在内）的所有楼层。另给你一个整数数组 `special` ，其中 `special[i]` 表示  Alice 指定用于放松的特殊楼层。

返回不含特殊楼层的 **最大** 连续楼层数。

	输入：bottom = 2, top = 9, special = [4,6]
	输出：3
	解释：下面列出的是不含特殊楼层的连续楼层范围：
	- (2, 3) ，楼层数为 2 。
	- (5, 5) ，楼层数为 1 。
	- (7, 9) ，楼层数为 3 。
	因此，返回最大连续楼层数 3 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #排序 
### 思路一：排序+计算
连续楼层只存在三种可能：
1. bottom到最低特殊楼层之间；
2. top到最高特殊楼层之间；
3. 特殊楼层的间隔。

因此，只要将特殊楼层进行排序，就可通过计算上面三个间隔并取最大值来获取结果。
```java
class Solution {
    public int maxConsecutive(int bottom, int top, int[] special) {
        Arrays.sort(special);
        int n = special.length;
        int ans = Math.max(special[0] - bottom, top - special[n-1]);
        for (int i = 1; i < n; i++){
            ans = Math.max(ans,special[i] - special[i-1] - 1);
        }
        return ans;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(1)$