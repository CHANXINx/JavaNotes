## 704. 二分查找
### 信息:
- **难度**:easy
- **重要性:** #★☆☆☆☆ 
### 思路: 
- **定义`head`和`end`节点**, 即二分中的头和尾. **将`index`定义为`(head+end/2)`;
- 此时即判断`nums[index]`与`target`的关系, 若小于`target`, 则说明在二分中的右半部分, 此时将head置为`index+1`. 此时继续在右半部分重复上述判断, 直到找到`target`退出循环或数组中没有等于`target`的值而退出.
### 代码:
```
class Solution {  
    public int search(int[] nums, int target) {  
        int head = 0;  
        int end = nums.length - 1;  
        while (head <= end){  
            int index = (head + end) / 2;  
            if (nums[index] == target)  
                return index;  
            if (nums[index] < target){  
                head = index + 1;  
            }else if (nums[index] > target)  
                end = index - 1;  
        }  
        return -1;  
    }  
}
```
## 27. 移除元素
### 信息:
- **难度**:easy
- **重要性:** #★★★☆☆ 
### 思路:
>双指针经典题目，与[[移除零]]是一样的。

**使用r指针寻找不等于val的元素**，找到了则直接放置于l指针处。这里注意，我们**只需要关注不等于val的元素**，所以r指针从0遍历到n-1，就可以找到所有不等于val的元素，并正确放置于开头。

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int l = 0, r = 0;
        while (r < nums.length){
            if (nums[r] != val){
                nums[l] = nums[r];
                l++;
            }
            r++;
        }
        return l;
    }
}
```
## 26. 删除有序数组中的重复项
### 信息:
- **难度**:easy
- **重要性:** #★★★★☆
### 思路一：
利用双指针遍历，r指针用于寻找不相等的元素。因为`nums[0]`肯定是不变的，所以赋值的话需要从`nums[1]`开始赋值。

那么如何寻找不重复的元素呢？首先定义l指针为0，r指针从1开始向右寻找，若发现不重复元素，则从`nums[1]`开始赋值：`nums[++l] = nums[r]`。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 1) return 1;
        int l = 0, r = 1;
        while (r < nums.length){
            // 往后找到不等于nums[l]的元素。
            if (nums[l] != nums[r]){
                nums[++l] = nums[r];
            }
            r++;
        }
        return l+1;
    }
}
```

### 思路二：
依旧是从下标1开始赋值，从下标1开始遍历，因为`nums[0]`的值肯定不变。

从`nums[1]`开始判断：
- 若`nums[i]==num[i-1]`，则此时说明是重复元素，往后继续判断；
- 若`nums[i]!=num[i-1]`，则说明出现了不重复元素，赋值到`nums[l]`。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int l = 1;
        for (int i = 1; i < nums.length; i++){
            if (nums[i] != nums[i-1]){
                nums[l] = nums[i];
                l++;
            }
        }
        return l;
    }
}
```



## 283. 移动零
### 题目:
- 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意, 必须在不复制数组的情况下原地对数组进行操作。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 注意,原地操作,故不能定义新数组.定义快慢指针,当出现非0元素时,则赋值给慢指针处. 最后多定义一个循环,将`slow+1-nums.leng-1`索引处的所有元素都赋0!
### 关键点:
- 较简单,略.
### 代码:
```
class Solution {  
    public void moveZeroes(int[] nums) {  
        int slow = 0,fast = 0;  
  
        while (fast < nums.length){  
            if (nums[fast] != 0){  
                nums[slow] = nums[fast];  
                slow++;  
            }  
            fast++;  
        }  
        for (int i = slow;i < nums.length;i++)  
            nums[i] = 0;  
    }  
}
```
## 844. 比较含退格的字符串
### 题目
- 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。注意：如果对空文本输入退格字符，文本继续为空。
### 信息
- **难度：** easy
- **重要性：** #★★★★★
### 思路一：
使用“栈”进行模拟退格。遇到"#"则弹出顶部元素！

注意健壮性保证：若开头就是"#"，则需要直接跳过。
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        return build(s).equals(build(t));
    }
    String build(String s){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++){
	        // 使用StringBuilder模拟退格
            if (s.charAt(i) == '#' ){
	            // 健壮性保证，避免开头就是'#'导致的错误。
                if (sb.length() > 0) sb.deleteCharAt(sb.length()-1);
                else continue;
            }else {
                sb.append(s.charAt(i));

            }
        }
        return sb.toString();
    }
}

```
>时间复杂度：$O(N+M)$
>空间复杂度：$O(N+M)$

### 思路二：
还有种思路，就是边模拟，边判断。
由于"#"是会删除前一个元素，对其后一个元素无影响，所以可以从后向前遍历。

从后往前遍历只会遇到三种情况：
1. 遇到字母且skip为0，退出循环比较该字符；
2. 遇到字母且skip不为0，那么需要消耗一个skip，并且继续往前遍历；
3. 遇到"#"，需要累加skip，并继续向前遍历。

比较字符时，也只会出现三种情况：
1. i和j均大于0：此时需要判断字符是否相等；
2. i和j其中一个小于0，另一个大于0：此时代表长度不相等，返回false；
3. i和j均小于0：此时元素全部被退格了，直接退出，返回true。
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] t1 = t.toCharArray();

        int i = s1.length-1;
        int j = t1.length-1;
        int skipS = 0;
        int skipT = 0;
        while (i >= 0 || j >= 0){
            while (i >= 0){
                if (s1[i] == '#'){
                    skipS++;
                    i--;
                }else if (skipS > 0){
                    skipS--;
                    i--;
                }else{
                    break;
                }
            }
            while (j >= 0){
                if (t1[j] == '#'){
                    skipT++;
                    j--;
                }else if (skipT > 0){
                    skipT--;
                    j--;
                }else{
                    break;
                }
            }
            // 一个大于0，一个小于0，此时返回false。
            if ((i >=0) != (j >= 0)) return false;
            if (i >= 0 && j >= 0 && s1[i] != t1[j]) return false;

            i--;
            j--;
        }
        return true;
    }
}
```
## 977.有序数组的平方
### 题目
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #数组 #双指针 #排序
### 思路一：库函数排序
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        for (int i = 0; i < nums.length; i++){
            nums[i] = nums[i] * nums[i];
        }
        Arrays.sort(nums);
        return nums;
    }
}
```
**时间复杂度：**$O(NlogN)$
**空间复杂度：**$O(1)$
### 思路二：相向双指针
最大值肯定出现在$nums[0]$和$nums[1]$ 之间，所以由大到小填入$ans$。

	如果从小到大放置元素，那么首先还得遍历到中间寻找最小的元素，思路较复杂。
 
**具体算法流程：**
1. 定义相向双指针$l$和$r$，分别指向左右两侧；
2. 计算平方结果，比较更大元素，存储在$ans$结果数组中，更大一侧的指针向中间移动；
3. 退出循环条件为$l$与$r$指向同一个元素。
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int idx = nums.length - 1;
        int l = 0;
        int r =idx;
        while (l <= r){
            int lPow = nums[l] * nums[l];
            int rPow = nums[r] * nums[r];
            if (lPow <= rPow){
                ans[idx] = rPow;
                r--;
            }else {
                ans[idx] = lPow;
                l++;
            }
            idx--;
        }
        return ans;
    }
}
```
**时间复杂度：$O(N)$**
**空间复杂度：$O(N)$**
## 209.长度最小的子数组
### 题目
给定一个含有 `n` 个正整数的数组和一个正整数 `target`.
找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ,并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #滑动窗口 #数组 
### 思路一：滑动窗口
寻找最小子数组问题，滑动窗口是常见思路，因为能遍历所有可能满足要求的子数组。

**具体算法流程：**
1. $r$指针向右移动，让窗口能满足要求，记录可能的$ans$；
2. $l$指针向右移动，使窗口不断缩小，若缩小后仍满足要求，则继续记录答案；否则继续移动$r$指针；
3. 循环上述操作。

若最终结果$ans == n+1$，说明不存在满足要求的子数组，返回0.
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int l = 0;
        int sum = 0;
        int ans = n+1;
        for (int r = 0; r < n; r++){
            sum += nums[r];
            while (sum >= target){
                ans = Math.min(r-l+1,ans);
                sum -= nums[l++];
            }
        }
        return ans == n + 1 ? 0 : ans;
    }
}
```
## 59.螺旋矩阵II
### 题目:
- 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
- ![[ArrayPart2_img1.png]]
### 信息:
- **难度**: Medium
- **重要性:** #★★★★★
### 思路一:
>这道题目可以说在面试中出现频率较高的题目，**本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。**
- 确认每次画一条线,然后明确边界条件.建议以4×4矩阵为例子.
- 循环不变量:遵循一个规则来处理每一条边.
- 此模拟方法只能对应模拟偶数矩阵，而对于奇数矩阵，需要额外赋值中间的。
```java
class Solution {  
    public int[][] generateMatrix(int n) {  
        int[][] matrix = new int[n][n];  
        int start = 0;  
        int end = n-1;  
        int count = 1;  
        while (start <= end) {  
            for (int i = start; i < end; i++) {  
                matrix[start][i] = count;  
                count++;  
            }  
            for (int i = start; i < end; i++) {  
                matrix[i][end] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[end][i] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[i][start] = count;  
                count++;  
            }  
            if (start == end)  
                matrix[start][end] = count;  
            start++;  
            end--;  
        }  
        return matrix;  
    }  
}  
```
## 15. 三数之和 
### 题目:
- 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
**注意：**答案中不可以包含重复的三元组。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
- **标签：** #数组 #双指针
### 思路一：相向双指针
对于有序数组求目标和问题，可以使用相向双指针。

三数之和，考虑将固定$nums[i]$，此时就可以**转换为两数之和问题**。基本思路确定，接下来确定具体算法流程。

具体算法流程：
1. 固定$nums[i]$，此时利用相向双指针，获取所有和为0的结果，指针移动逻辑为
	1) 若和大于0，则指针$k$左移；
	2) 若和小于0，在指针$j$右移；
	3) 若和等于0，则添加结果，并继续移动指针寻找对于$nums[i]$可能成立的三元组。

到这里，基本的寻找三元组问题已经完成，接下来考虑“去重”：
- 若$nums[i]==nums[i-1]$，则说明若有三元组，必然成对，因此应该跳过此时的$nums[i]$；
- 对于$nums[i]$，若找到三元组，则会执行`j++;k--;`，继续寻找可能的三元组。因此此时也需要去重逻辑：
	- 若$nums[j]==nums[j-1]$，则需要跳过当前$nums[j]$；
	- 若$nums[k] == nums[k+1]$，则需要跳过当前$nums[k]$；
	- 【即不与已经遍历过的$j/k$重复。】
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        
        List<List<Integer>> ans = new ArrayList<>();

        for (int i = 0; i < nums.length-2; i++){
            int x = nums[i];
            if (i > 0 && nums[i-1] == x) continue;
            int j = i+1;
            int k = nums.length-1;
            
            while (j < k){
                int sum = nums[i] + nums[j] + nums[k];
                if (sum > 0){
                    k--;
                }else if(sum < 0){
                    j++;
                }else {
                    ans.add(List.of(nums[i],nums[j],nums[k]));
                    j++;
                    while (j < k && nums[j] == nums[j-1]) j++;
                    k--;
                    while (k > j && nums[k] == nums[k+1]) k--;
                }
            }
        }
        return ans;
    }
}
```

## 18. 四数之和

### 题目:
给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 **任意顺序** 返回答案 。
### 信息:
- **难度**: medium
- **重要性：** #★★★★★
- **标签：** #数组 #双指针 
### 思路一：相向双指针
类似于三数字之和，本题使用嵌套循环固定住$nums[i]$和$nums[j]$，再使用相向双指针找到所有可能的四元组。

对于`nums[j]`的去重逻辑：除首个元素外，若出现$nums[j] == nums[j-1]$，则跳过。
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < nums.length-3; i++){
            // 1. 剪枝(1)
            if (nums[i] > 0 && nums[i] > target) break;

            if (i > 0 && nums[i] == nums[i-1]) continue;
            for (int j = i+1; j < nums.length-2; j++){
                // 2. 剪枝(2)
                if (nums[i] + nums[j] > 0 && nums[i] + nums[j] > target) break;

                if (j > (i+1) && nums[j] == nums[j-1]) continue;
                int k = j + 1;
                int l = nums.length-1;
                while (k < l){
                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum > target){
                        l--;
                    } else if (sum < target){
                        k++;
                    } else {
                        ans.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));
                        k++;
                        l--;
                        while (k < l && nums[k] == nums[k-1]) k++;
                        while (k < l && nums[l] == nums[l+1]) l--;
                    }
                }
            }
        }
        return ans;

    }
}
```

## 303. 区域和检索 - 数组不可变
### 题目
给定一个整数数组  `nums`，处理以下类型的多个查询:

1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #前缀和
### 思路一：
前缀和模板题，利用$sum$数组保存前$i$个元素和。此时若需要返回$[left,right]$的和，使用$sum[right]-sum[left]+nums[left]$即可。
```java
class NumArray {
    private int[] nums;
    private int[] sum;
    public NumArray(int[] nums) {
        this.nums = nums;
        this.sum = new int[nums.length];
        for (int i = 1; i < nums.length; i++){
            sum[i] = sum[i-1] + nums[i];
        }
    }
    
    public int sumRange(int left, int right) {
        return sum[right] - sum[left] + nums[left];    
    }
}
```
**查询时间复杂度：** $O(1)$

## 560. 和为 K 的子数组
### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 _该数组中和为 `k` 的子数组的个数_ 。

子数组是数组中元素的连续非空序列。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #前缀和 #数组 #哈希表 
### 思路一：
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int[] sums = new int[nums.length+1];
        for (int i = 0; i < nums.length; i++){
            sums[i+1] = sums[i] + nums[i];
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int s : sums){
            ans += map.getOrDefault(s-k,0);
            map.merge(s,1,Integer::sum);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$