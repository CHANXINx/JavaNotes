# 二叉树


## 前中后序遍历的迭代写法
### 题目:

### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:

#![[二叉树中序遍历（迭代法）.gif|400]]
### 关键点:
- 
### 代码:
```java


```


## 102. 二叉树的层序遍历
### 题目:
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public List<List<Integer>> levelOrder(TreeNode root) {  
  
        List<List<Integer>> res = new ArrayList<>();  
        Queue<TreeNode> que = new LinkedList<>();  
  
        if (root != null) que.offer(root);  
        while (!que.isEmpty()) {  
            int size = que.size();  
            List<Integer> temp = new ArrayList<>();  
//                 以size循环,即对本层节点进行遍历.  
            for (int i = 0; i < size; i++){  
//                 队顶出队,并存储到该层结果中.  
                TreeNode tempNode = que.poll();  
                temp.add(tempNode.val);  
//                存储子节点,由于队列是先进先出,所以子节点会在本层节点遍历完后才遍历.  
                if (tempNode.left != null) que.offer(tempNode.left);  
                if (tempNode.right != null) que.offer(tempNode.right);  
            }  
//            一层结束,存储该层结果.  
            res.add(temp);  
        }  
        return res;  
    }  
}
```

# 贪心算法

## 55. 合并区间
### 题目:
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 记录start和end区间,分几种情况讨论:
	1) end区间与下一个区间的左边界有重叠,则合并区间->即更新end为目前最远的右边界;
	2) end区间与下一个区间的左边界无重叠,则将区间加入到res结果中.并且要更新start和end为下一个区间的左右边界.
	3) 最后还需将最后的区间加入到res结果中.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int[][] merge(int[][] intervals) {  
        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);  
        // 存放当前最右区间  
        int start = intervals[0][0];  
        int end = intervals[0][1];  
        // 存放二维数组  
        List<int[]> res = new ArrayList<>();  
        // 存放区间  
        //List<Integer> temp = new LinkedList<>();  
  
        for (int i = 1; i < intervals.length; i++) {  
            // 没重叠, 则放入集合中  
            if (intervals[i][0] > end){  
                res.add(new int[]{start,end});  
                start = intervals[i][0];  
                end = intervals[i][1];  
            }else {  
                // 有重叠, 则合并  
                end = Math.max(intervals[i][1],end);  
            }  
        }  
        res.add(new int[]{start,end});  
  
        return res.toArray(new int[res.size()][]);  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 738. 单调递增的数字
### 题目: 
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 将int通过`String.valueOf().toCharArray()`转换为char数组,便于比较.
- 分为两种情况进行讨论: (从后向前遍历)
	1) 若`[i-1] <= [i]`,则满足条件,继续遍历;
	2) 若`[i-1] > [i]`, 则记录此时位置idx,并将`[i-1]--`.
- 遍历直到起始为止,持续更新idx,最后将idx及后面的数字全部更新为9.
### 关键点:
- 从后向前遍历是关键,这样才能反复利用更新后的`[i-1]`.
- 必须使用idx记录后统一更新,若遍历时更新,无法保证全是递增.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int monotoneIncreasingDigits(int n) {  
        if (n >= 0 && n <= 9) return n;  
        // 转换为char数组，便于操作  
        char[] c = String.valueOf(n).toCharArray();  
        // 记录开始变9的位置  
        int idx = c.length;  
        for (int i = c.length-1; i > 0; i--) {  
            if (c[i-1] > c[i]){  
                c[i-1]--;  
                idx = i;  
            }  
        }  
        for (int i = idx; i < c.length;i++){  
            c[i] = '9';  
        }  
        return Integer.parseInt(String.valueOf(c));  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 968. 监控二叉树
### 题目:
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {
    int res = 0;
    public int minCameraCover(TreeNode root) {
        if (dfs(root) == 0) { // root 无覆盖
            res++;
        }
        return res;
    }

    int dfs(TreeNode root){
        // 标记状态：2为有覆盖 1为有摄像头 0为无覆盖
        if (root == null) return 2;

        int left = dfs(root.left);
        int right = dfs(root.right);

        // 都有覆盖，则父节点应该是0
        if (left == 2 && right == 2) return 0

        if (left == 0 || right == 0) {
            res++;
            return 1;
        }
        if (left == 1 || right == 1) return 2;

        return -1;

    }

}
```