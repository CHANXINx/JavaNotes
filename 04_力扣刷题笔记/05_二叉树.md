## 94. 二叉树的中序遍历
### 题目
给定一个二叉树的根节点 `root` ，返回 _它的 **中序** 遍历_ 。
### 信息
- **难度：** easy
- **重要性：** #★☆☆☆☆
- **标签：** #二叉树 #DFS 
### 思路一：
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        dfs(root,path);
        return path;
    }
    void dfs(TreeNode root,List<Integer> path){
        if (root == null){
            return;
        }
        dfs(root.left,path);
        path.add(root.val);
        dfs(root.right,path);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 104. 二叉树的最大深度
### 题目
给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #二叉树 #递归 #DFS #BFS 
### 思路一：层序遍历获取深度
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        Deque<TreeNode> que = new ArrayDeque<>();
        que.add(root);
        int depth = 0;
        while (!que.isEmpty()){
            int sz = que.size();
            for (int i = 0; i < sz; i++){
                TreeNode curr = que.poll();
                if (curr.left != null) que.add(curr.left);
                if (curr.right != null) que.add(curr.right);
            }
            depth++;
        }
        return depth;
    }
    
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：DFS递归获取深度
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        return Math.max(lDepth,rDepth) + 1;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：DFS递推获取思路
```java
class Solution {
    private int ans = 0;
    public int maxDepth(TreeNode root) {
        dfs(root,0);
        return ans;
    }
    void dfs(TreeNode root, int dep){
        if (root == null){
            return;
        }
        dep++;
        ans = Math.max(ans,dep);
        dfs(root.left,dep);
        dfs(root.right,dep);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 543. 二叉树的直径
### 题目
给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。
### 信息
- **难度：** easy
- **重要性：** #★★★★★
- **标签：** #二叉树  #DFS #递归 
### 思路一：递归
核心思路：最大直径可能出现在每一个节点上，并且**肯定为某一个节点的左右子树高度和**。
**具体算法流程：**
1. **结束递归**：遇到空节点，返回-1，代表当前子树的根节点的深度为0.
2. **处理逻辑**：获取当前节点的左右子树的深度，计算直径，更新ans；
3. **返回条件**：返回当前节点的左右子树的最大深度，以保证当前节点的根节点能获取这一子树的最大深度。
```java
class Solution {
    private int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDep(root);
        return ans;
    }
    int maxDep(TreeNode root){
        // 代表当前根节点的左/右子树深度为0.
        if (root == null) {
            return -1;
        }
        // 获取左子树深度
        int left = maxDep(root.left)+1;
        // 获取右子树深度
        int right = maxDep(root.right)+1;
        // 当前根节点的最大直径=左+右
        ans = Math.max(left+right,ans);
        // 返回根节点的最大深度
        return Math.max(left,right);
    }
}
```
**时间复杂度：** $O(N)$ 
**空间复杂度：** $O(N)$
## 102. 二叉树的层序遍历
### 题目:
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public List<List<Integer>> levelOrder(TreeNode root) {  
  
        List<List<Integer>> res = new ArrayList<>();  
        Queue<TreeNode> que = new LinkedList<>();  
  
        if (root != null) que.offer(root);  
        while (!que.isEmpty()) {  
            int size = que.size();  
            List<Integer> temp = new ArrayList<>();  
//                 以size循环,即对本层节点进行遍历.  
            for (int i = 0; i < size; i++){  
//                 队顶出队,并存储到该层结果中.  
                TreeNode tempNode = que.poll();  
                temp.add(tempNode.val);  
//                存储子节点,由于队列是先进先出,所以子节点会在本层节点遍历完后才遍历.  
                if (tempNode.left != null) que.offer(tempNode.left);  
                if (tempNode.right != null) que.offer(tempNode.right);  
            }  
//            一层结束,存储该层结果.  
            res.add(temp);  
        }  
        return res;  
    }  
}
```
## 226. 翻转二叉树

### 题目
给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #二叉树 #DFS #BFS 
### 思路一：BFS实现翻转二叉树
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        Deque<TreeNode> que = new ArrayDeque<>();
        que.add(root);
        while (!que.isEmpty()){
            int sz = que.size();
            for (int i = 0; i < sz; i++){
                TreeNode curr = que.poll();
                TreeNode left = curr.left;
                TreeNode right = curr.right;
                if (left != null) que.add(left);
                if (right != null) que.add(right);
            
                curr.right = left;
                curr.left = right;
            }
        }
        return root;
    }
}
```
**时间复杂度：** $O(N)$ 
**空间复杂度：** $O(N)$
### 思路二：DFS实现翻转二叉树
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        return dfs(root);
    }
    TreeNode dfs(TreeNode root){
        if (root == null) {
            return null;
        }
        TreeNode left = dfs(root.left);
        TreeNode right = dfs(root.right);
        root.right = left;
        root.left = right;
        
        return root;
    }
}
```
**时间复杂度：** $O(N)$ 
**空间复杂度：** $O(N)$

## 101. 对称二叉树
### 题目
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #二叉树 #BFS #DFS 
### 思路一：BFS递推判断对称
在每一层遍历时，判断左右子树是否相等。注意，需要使用LinkedList实现类与offer方法。
>[!关于Deque中LinkedList和offer方法]-
>LinkedList实现类可以插入null值，而ArrayDeque实现类无法插入null值。
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;

        Deque<TreeNode> que = new LinkedList<>();
        que.offer(root.left);
        que.offer(root.right);

        while (!que.isEmpty()){
            TreeNode left = que.poll();
            TreeNode right = que.poll();
            if (left == null && right == null) continue;
            if (left == null || right == null) return false;
            if (left.val != right.val) return false;

            que.offer(left.left);
            que.offer(right.right);
            
            que.offer(left.right);
            que.offer(right.left);
        }
        return true;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：DFS递归判断对称
递归判断左右子树：
- **递归参数**：左右子树；
- **结束递归**：遇到空节点，则需要判断是否对称；
- **处理逻辑**：判断当前左右子树的val是否相等；
- **递归深入**：继续递归判断`当前左子树的左子树与右子树的右子树`、`左子树的右子树和右子树的左子树`是否对称。
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isSymmetric(root.left,root.right);
    }
    boolean isSymmetric(TreeNode left, TreeNode right){
        if (left == null || right == null) {
            return left == right;
        }
        if (left.val != right.val) return false;
		return isSymmetric(left.right,right.left) && isSymmetric(left.left,right.right);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 103. 二叉树的锯齿形层序遍历
### 题目
给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #二叉树 #BFS
### 思路一：
正常的二叉树层序遍历，只不过在层数为偶数时，进行一次$path$的翻转操作即可。
**具体算法流程：**
1. 利用path变量，在每一层遍历时保存该层的节点值；每一层遍历结束后，若为偶数层，则翻转path后再添加到ans中。
2. 遍历每一层，获取最终ans。

>[!错误思路]-
> 我初步的思路是利用一个flag在添加元素时进行“先左再右”和“先右再左”的变化，但是不行！因为只是进行了左子树的左右子树和右子树的左右子树翻转，未实现整层的翻转！
> ![[Pasted image 20241212011643.png|450]]
```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        Deque<TreeNode> que = new ArrayDeque<>();
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        que.add(root);
        int idx = 0;

        while (!que.isEmpty()){
            int sz = que.size();
            List<Integer> path = new ArrayList<>();
            for (int i = 0; i < sz; i++){
                TreeNode curr = que.poll();

                path.add(curr.val);
                if (curr.left != null) que.add(curr.left);
                if (curr.right != null) que.add(curr.right);   
            }
            idx++;
            if (idx % 2 == 0) Collections.reverse(path);
            ans.add(path);
        }
        return ans;
    }
}

```
**时间复杂度：** 
**空间复杂度：** 
## 108. 将有序数组转换为二叉搜索树
### 题目
给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **平衡** 二叉搜索树。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #二叉树 #分治 #DFS 
### 思路一：
以中序遍历升序输入为例：`[-10,-3,0,5,9]`，若要构建**平衡**搜索树，则根节点必定为中点，以中点为边界的左侧就是当前左子树，右侧就是右子树。
**具体算法流程：**
- **递归参数**：节点值数组、左右边界；
- **结束递归**：
	- `left == right`，此时无法再构建子树，返回null节点。
	- 正常处理，返回当前根节点。
- **处理逻辑**：根据当前左右边界构造根节点（中点）；
- **递归深入**：构建当前根节点的左右子树；
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
       return dfs(nums,0,nums.length);
    }
    private TreeNode dfs(int[] nums, int left, int right){
        if (left == right){
            return null;
        }
        int m = (left + right) / 2;
        
        // 构建当前根节点，递归构建左右子树
        TreeNode root = new TreeNode(nums[m]);
        root.left = dfs(nums,left,m);
        root.right = dfs(nums,m+1,right);
        return root;
        // return new TreeNode(nums[m],dfs(nums,left,m),dfs(nums,m+1,right));
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 98. 验证二叉搜索树

### 题目
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #二叉树 #DFS #递归 
### 思路一：前序遍历
判断每一个节点是否满足小于右子树，大于左子树，因此递归所需参数就是当前节点所需要满足的最小值与最大值。
**具体算法流程：**
- **递归参数**：节点、最小值、最大值；
- **处理逻辑**：判断当前节点值是否在范围内；
- **递归深入**：继续递归判断当前节点的左右子树是否满足条件，并需要更新最小最大值。
  ![[Pasted image 20241218110053.png|200]]
- **结束递归**：
	- 节点值为null；
	- 节点值不满足搜索树。

>[!错误思路]-
>递归判断当前子树的左右子树是否满足条件，此时虽然可以保证子树与当前根节点满足搜索树条件，却不能保证子树的值与根节点的父节点满足条件！![[Pasted image 20241218105814.png]]
```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        long min = Long.MIN_VALUE;
        long max = Long.MAX_VALUE;
        return isValidBST(root,min,max);
    }
    boolean isValidBST(TreeNode root, long min, long max){
        if (root == null) {
            return true;
        }
        if (root.val <= min || root.val >= max) return false;

        return isValidBST(root.left,min,root.val) &&
                isValidBST(root.right,root.val,max);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：中序遍历
使用中序遍历，那么如果是二叉搜索树，则一定满足遍历结果是单调递增的！

```java
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }    
        if (!isValidBST(root.left)) return false;
        
        // 此时节点值已被上面的左子树遍历更新。
        if (root.val <= pre) return false;

        // 更新节点值
        pre = root.val;        
        if (!isValidBST(root.right)) return false;
        
        return true;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

### 思路三：后序遍历
```java

```
**时间复杂度：** 
**空间复杂度：** 

## 
### 题目

### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #二叉树 #DFS 
### 思路一：中序遍历保存节点值
```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> path = new ArrayList<>();
        dfs(root,path);
        return path.get(k-1);
    }
    void dfs(TreeNode root, List<Integer> path){
        if (root == null) return;

        dfs(root.left,path);
        path.add(root.val);
        dfs(root.right,path);
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：中序遍历，利用全局变量
```java
class Solution {
    private int k;
    private int result;

    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return result;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        // 先遍历左子树
        dfs(root.left);

        // 访问当前节点
        k--;  // 每访问一个节点，减小 k
        if (k == 0) {
            result = root.val;  // 找到第 k 小的元素
            return;  // 找到后立即返回
        }

        // 遍历右子树
        dfs(root.right);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
# 贪心算法

## 55. 合并区间
### 题目:
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 记录start和end区间,分几种情况讨论:
	1) end区间与下一个区间的左边界有重叠,则合并区间->即更新end为目前最远的右边界;
	2) end区间与下一个区间的左边界无重叠,则将区间加入到res结果中.并且要更新start和end为下一个区间的左右边界.
	3) 最后还需将最后的区间加入到res结果中.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int[][] merge(int[][] intervals) {  
        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);  
        // 存放当前最右区间  
        int start = intervals[0][0];  
        int end = intervals[0][1];  
        // 存放二维数组  
        List<int[]> res = new ArrayList<>();  
        // 存放区间  
        //List<Integer> temp = new LinkedList<>();  
  
        for (int i = 1; i < intervals.length; i++) {  
            // 没重叠, 则放入集合中  
            if (intervals[i][0] > end){  
                res.add(new int[]{start,end});  
                start = intervals[i][0];  
                end = intervals[i][1];  
            }else {  
                // 有重叠, 则合并  
                end = Math.max(intervals[i][1],end);  
            }  
        }  
        res.add(new int[]{start,end});  
  
        return res.toArray(new int[res.size()][]);  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 738. 单调递增的数字
### 题目: 
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 将int通过`String.valueOf().toCharArray()`转换为char数组,便于比较.
- 分为两种情况进行讨论: (从后向前遍历)
	1) 若`[i-1] <= [i]`,则满足条件,继续遍历;
	2) 若`[i-1] > [i]`, 则记录此时位置idx,并将`[i-1]--`.
- 遍历直到起始为止,持续更新idx,最后将idx及后面的数字全部更新为9.
### 关键点:
- 从后向前遍历是关键,这样才能反复利用更新后的`[i-1]`.
- 必须使用idx记录后统一更新,若遍历时更新,无法保证全是递增.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int monotoneIncreasingDigits(int n) {  
        if (n >= 0 && n <= 9) return n;  
        // 转换为char数组，便于操作  
        char[] c = String.valueOf(n).toCharArray();  
        // 记录开始变9的位置  
        int idx = c.length;  
        for (int i = c.length-1; i > 0; i--) {  
            if (c[i-1] > c[i]){  
                c[i-1]--;  
                idx = i;  
            }  
        }  
        for (int i = idx; i < c.length;i++){  
            c[i] = '9';  
        }  
        return Integer.parseInt(String.valueOf(c));  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 968. 监控二叉树
### 题目:
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {
    int res = 0;
    public int minCameraCover(TreeNode root) {
        if (dfs(root) == 0) { // root 无覆盖
            res++;
        }
        return res;
    }

    int dfs(TreeNode root){
        // 标记状态：2为有覆盖 1为有摄像头 0为无覆盖
        if (root == null) return 2;

        int left = dfs(root.left);
        int right = dfs(root.right);

        // 都有覆盖，则父节点应该是0
        if (left == 2 && right == 2) return 0

        if (left == 0 || right == 0) {
            res++;
            return 1;
        }
        if (left == 1 || right == 1) return 2;

        return -1;

    }

}
```

