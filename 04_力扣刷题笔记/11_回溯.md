## 46. 全排列
### 题目
给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #回溯
### 思路一：DFS回溯
**关键算法思路：**
- 记录已选过的元素，避免重复选择；
	- **利用memo数组保存已选择过的元素，递归时遇到`memo[j]`已被选择，就会跳过。**
- 记得恢复现场，否则会影响下一次选择；
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] memo = new boolean[nums.length];
        dfs(nums,memo);
        return ans;
    }
    void dfs(int[] nums,boolean[] memo){
        // 已选择所有元素，添加结果。
        if (path.size() == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            // 跳过已选择元素（避免重复选择）
            if (memo[i]) continue;
            // 选择元素
            path.add(nums[i]);
            // 标记已选择的元素
            memo[i] = true;
            // 递归选择下一个元素
            dfs(nums,memo);
            // 恢复现场
            memo[i] = false;
            path.remove(path.size()-1);
        }
        return;
    }
}
```
## 78. 子集
### 题目
给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的
子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #位运算 #数组 #回溯
### 思路一：选或不选
参数i表示当前的nums\[i]是否选择，也可以理解为i表示当前递归深度。
![[Pasted image 20241225171816.png|450]]
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0,nums);
        return ans;
    }
    void dfs(int i,int[] nums){
        // 子集构造完毕
        if (i == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        // 不选择元素
        dfs(i+1,nums);

        // 选择元素
        path.add(nums[i]);
        // 递归继续选择下一个元素
        dfs(i+1,nums);
        // 恢复现场
        path.remove(path.size()-1);
    }
}
```
**时间复杂度：** $O(N2^N)$
**空间复杂度：** $O(N)$
### 思路二：枚举选哪个
- 每一次递归时，先将当前路径添加到答案中；
- 下一次递归，不能选择当前已选择过的元素，因此for循环的起始条件是`j=i`，并且递归的参数是j+1，代表不能选择当前及之前的已选择元素。
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0,nums);
        return ans;
    }
    void dfs(int i,int[] nums){
        ans.add(new ArrayList<>(path));
        for (int j = i; j < nums.length; j++){
            path.add(nums[j]);
            dfs(j+1,nums);
            path.remove(path.size()-1);
        }
    }
}
```
## 17. 电话号码的字母组合
### 题目
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
![[Pasted image 20241225152648.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #哈希表 #回溯 
### 思路一：
**具体算法流程：**
1. 利用String数组作为哈希表，保存数字到字母的映射；
2. 递归回溯：
	- 利用i表示递归深度，当`i==digits.length()`，说明已经遍历了所有数字；
	- 可以理解为N个`String[]`数组的排列问题，并且只考虑正序；
```java
class Solution {
    private static final String[] MAPPING = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    List<String> ans = new ArrayList<>();
    StringBuilder path = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) return ans;
        dfs(0,digits);
        return ans;
    }
    void dfs(int i,String digits){
        if (i == digits.length()){
            ans.add(new String(path));
            return;
        }
        for (char str : MAPPING[digits.charAt(i)-'0'].toCharArray()){
            path.append(str);
            dfs(i+1,digits);
            path.deleteCharAt(path.length()-1);
        }
    }
}
```
**时间复杂度：** $O(N4^N)$，其中N为digits的长度。
**空间复杂度：** $O(N)$

## 39. 组合总和
### 题目
给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #回溯 #数组 
### 思路一：选或不选
递归函数签名：
- `candidates` 是候选数字数组。
- `target` 是当前递归需要达到的目标值。
- `i` 是当前递归正在处理的数组索引。

**选：**
- 选择第i个元素，并且下一次递归仍能选择该元素，因此递归参数为`i`；

**不选：**
- 跳过当前元素，直接考虑下一个元素，因此参数为`i+1`。【若为`i`，则陷入死循环了】
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int sum = 0;
        dfs(candidates,target,0,0);
        return ans;
    }
    void dfs(int[] candidates,int target,int sum,int k){
        if (sum == target){
            ans.add(new ArrayList<>(path));
            return;
        }
        
        if (sum > target || k == candidates.length) {
            return;
        }
		// 不选该元素
        dfs(candidates,target,sum,k+1);
		
		// 选择该元素
        path.add(candidates[k]);
        // sum增加
        dfs(candidates,target,sum+candidates[k],k);
        // 恢复现场
        path.remove(path.size() - 1);
    }
}
```
### 思路二：枚举选哪个
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates,target,0);
        return ans;
    }
    void dfs(int[] candidates, int target, int i){
        if (target == 0){
            ans.add(new ArrayList<>(path));
            return;
        }
        // 越界，或者和大于target：返回
        if (target < 0 || i == candidates.length){
            return;
        }

        for (int j = i; j < candidates.length; j++){
            // 已选择过的元素可以再选一次
            path.add(candidates[j]);
            dfs(candidates,target-candidates[j],j);
            // 恢复现场
            path.remove(path.size()-1);
        }
    }
}
```

## 22. 括号生成
### 题目
数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #回溯 
### 思路一：
**有效括号**：两两能构成`()`，而不会出现`)(`这样的组合。

根据有效括号的定义，我们在递归过程中，保证`(`的出现次数时刻大于等于`)`的出现次数即可！
**具体算法流程：**
- 利用`cnt[2]`数组表示括号的剩余个数。
- 在递归过程中，出现`(`的剩余个数小于等于`)`的剩余个数，说明不符合条件，回溯；
- 在递归过程中，若`字符串长度==2n`或`cnt[0]与cnt[1]`都用完，则到达递归重点，添加结果。
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        int[] cnt = new int[2];
        cnt[0] = n;
        cnt[1] = n;
        List<String> ans = new ArrayList<>();
        StringBuilder path = new StringBuilder();
        dfs(ans,path,cnt,n);
        return ans;
    }
	
    void dfs(List<String> ans, StringBuilder path, int[] cnt,int n){
	    // 当)出现次数大于(，则说明不符合正确括号！退出循环！
        if (cnt[1] < cnt[0]){
            return;
        }
        if (path.length() == 2*n){
	    // if (cnt[0] == cnt[1] && cnt[0] == 0){
            ans.add(new String(path));
            return;
        }
        if (cnt[0] > 0) {
            path.append("(");
            cnt[0]--;
            dfs(ans,path,cnt,n);
            cnt[0]++;
            path.deleteCharAt(path.length()-1);
        }
        if (cnt[1] > 0){
            path.append(")");
            cnt[1]--;
            dfs(ans,path,cnt,n);
            cnt[1]++;
            path.deleteCharAt(path.length()-1);
        }
    }
}

```
## 79. 单词搜索
### 题目
给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #回溯 #图论 
### 思路一：
```java
class Solution {
    private static final int[][] DIRS = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};

    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;

        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                boolean[][] visited = new boolean[m][n];
                if (board[i][j] == word.charAt(0) && dfs(i,j,0,word,board,visited)){
                    return true;
                }
            }
        }   
        return false;
    }
    boolean dfs(int i, int j, int k, String word, char[][] board,boolean[][] visited){
        if (k == word.length()){
            return true;
        }
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j]){
            return false;
        }
        
        if (word.charAt(k) != board[i][j]){
            return false;
        }
        visited[i][j] = true;
        
        for (int[] dir : DIRS){
            int x = i + dir[0];
            int y = j + dir[1];
            if (dfs(x,y,k+1,word,board,visited))
                return true;
        }
        visited[i][j] = false;
        return false;
    }
}

```

## 131. 分割回文串
### 题目
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #回溯 #字符串 
### 思路一：
枚举每一个子串，判断是否回文：
- **回文则添加，并递归继续添加后面的子串**，利用start变量表示下一个子串的起始位置。
- **不回文的话则判断下一个子串是否回文**，在循环中用i++表示。
```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> ans = new ArrayList<>();
        List<String> path = new ArrayList<>();
        dfs(ans,path,0,s);
        return ans;        
    }
    void dfs(List<List<String>> ans, List<String> path, int start, String s){
        if (start == s.length()){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = start; i < s.length(); i++){
            if (isPalindrome(start,i,s)){
                path.add(s.substring(start,i+1));
                dfs(ans,path,i+1,s);
                path.remove(path.size()-1);
            }
        }

    }
    private boolean isPalindrome(int l,int r,String s){
        while (l < r){
            if (s.charAt(l) != s.charAt(r)){
                return false;
            }
            l++;r--;
        }
        return true;
    }
}

```

## 51. N 皇后
### 题目
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #回溯 
### 思路一：排列型回溯
何时不能放置？①行已经被放置；②列已经被放置；③对角已经被放置：行+列相同/行-列相同
针对上述三种不能放置的条件，定义如下形参判断：
1. **行**：定义形参r，每一次递归都放置一行，这样就做到不会在某行重复放置；
2. **列**：每一次递归都遍历所有c，并利用`col[n]`数组标记已放置过的列；
3. **对角**：利用`diag1`与`diag2`保存已放置过的位置；
	- 对于$N×N$的棋盘，行+列的范围为`[0,N-1+N-1]`，行-列的范围为`[-(N-1),N-1]`。因此，diag1应该为2N-1大小的数组；行-列的范围可以通过`+(N-1)`来平移至`[0,2N-2]`，因此diag2也是2N-1大小！

**基本思路：**
- 从第0行开始进入递归，判断每一行中**每一列的是可能的放置结果的可能性**：
	- 若该行放置成功，则递归进入下一行开始放置，并标记放置过的行、列；
	- 若放置失败，则尝试下一列；
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        // 标记行号+列号
        boolean[] diag1 = new boolean[n*2-1];
        // 标记行号-列号
        boolean[] diag2 = new boolean[n*2-1];
        // 记录每行放置的皇后的列号
        int[] queens = new int[n];
        // 记录已放置过的列号
        boolean[] col = new boolean[n];
        List<List<String>> ans = new ArrayList<>();
        dfs(0,queens,col,diag1,diag2,ans);
        return ans;
    }
    void dfs(int r, int[] queens, boolean[] col, boolean[] diag1, boolean[] diag2, List<List<String>> ans){
        int n = queens.length;
        // 已选择n行，构造答案:
        if (r == n){
            List<String> path = new ArrayList<>();
            for (int c : queens){
                char[] row = new char[n];
                Arrays.fill(row,'.');
                row[c] = 'Q';
                path.add(new String(row));                
            }
            ans.add(path);
            return;
        }
        for (int c = 0; c < n; c++){
            // +(n-1)：(-n,n)->(0,2*n)
            int rc = r - c + n - 1;
            // 符合放置条件
            if (!col[c] && !diag1[r+c] && !diag2[rc]){
                queens[r] = c;
                col[c] = diag1[r+c] = diag2[rc] = true;
                dfs(r+1,queens,col,diag1,diag2,ans);
                col[c] = diag1[r+c] = diag2[rc] = false;
            }
        }
    }
}
```