## 46. 全排列
### 题目
给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #数组 #回溯
### 思路一：DFS回溯
**关键算法思路：**
- 记录已选过的元素，避免重复选择；
	- **利用memo数组保存已选择过的元素，递归时遇到`memo[j]`已被选择，就会跳过。**
- 记得恢复现场，否则会影响下一次选择；
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] memo = new boolean[nums.length];
        dfs(nums,memo);
        return ans;
    }
    void dfs(int[] nums,boolean[] memo){
        // 已选择所有元素，添加结果。
        if (path.size() == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            // 跳过已选择元素（避免重复选择）
            if (memo[i]) continue;
            // 选择元素
            path.add(nums[i]);
            // 标记已选择的元素
            memo[i] = true;
            // 递归选择下一个元素
            dfs(nums,memo);
            // 恢复现场
            memo[i] = false;
            path.remove(path.size()-1);
        }
        return;
    }
}
```
## 78. 子集
### 题目
给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的
子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #位运算 #数组 #回溯
### 思路一：选或不选
参数i表示当前的nums\[i]是否选择，也可以理解为i表示当前递归深度。
![[Pasted image 20241225171816.png|450]]
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0,nums);
        return ans;
    }
    void dfs(int i,int[] nums){
        // 子集构造完毕
        if (i == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        // 不选择元素
        dfs(i+1,nums);

        // 选择元素
        path.add(nums[i]);
        // 递归继续选择下一个元素
        dfs(i+1,nums);
        // 恢复现场
        path.remove(path.size()-1);
    }
}
```
**时间复杂度：** $O(N2^N)$
**空间复杂度：** $O(N)$
### 思路二：枚举选哪个
- 每一次递归时，先将当前路径添加到答案中；
- 下一次递归，不能选择当前已选择过的元素，因此for循环的起始条件是`j=i`，并且递归的参数是j+1，代表不能选择当前及之前的已选择元素。
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0,nums);
        return ans;
    }
    void dfs(int i,int[] nums){
        ans.add(new ArrayList<>(path));
        for (int j = i; j < nums.length; j++){
            path.add(nums[j]);
            dfs(j+1,nums);
            path.remove(path.size()-1);
        }
    }
}
```
## 17. 电话号码的字母组合
### 题目
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
![[Pasted image 20241225152648.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #哈希表 #回溯 
### 思路一：
**具体算法流程：**
1. 利用String数组作为哈希表，保存数字到字母的映射；
2. 递归回溯：
	- 利用i表示递归深度，当`i==digits.length()`，说明已经遍历了所有数字；
	- 可以理解为N个`String[]`数组的排列问题，并且只考虑正序；
```java
class Solution {
    private static final String[] MAPPING = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    List<String> ans = new ArrayList<>();
    StringBuilder path = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) return ans;
        dfs(0,digits);
        return ans;
    }
    void dfs(int i,String digits){
        if (i == digits.length()){
            ans.add(new String(path));
            return;
        }
        for (char str : MAPPING[digits.charAt(i)-'0'].toCharArray()){
            path.append(str);
            dfs(i+1,digits);
            path.deleteCharAt(path.length()-1);
        }
    }
}
```
**时间复杂度：** $O(N4^N)$，其中N为digits的长度。
**空间复杂度：** $O(N)$

## 39. 组合总和
### 题目
给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #回溯 #数组 
### 思路一：选或不选
递归函数签名：
- `candidates` 是候选数字数组。
- `target` 是当前递归需要达到的目标值。
- `i` 是当前递归正在处理的数组索引。

**选：**
- 选择第i个元素，并且下一次递归仍能选择该元素，因此递归参数为`i`；

**不选：**
- 跳过当前元素，直接考虑下一个元素，因此参数为`i+1`。【若为`i`，则陷入死循环了】
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int sum = 0;
        dfs(candidates,target,0,0);
        return ans;
    }
    void dfs(int[] candidates,int target,int sum,int k){
        if (sum == target){
            ans.add(new ArrayList<>(path));
            return;
        }
        
        if (sum > target || k == candidates.length) {
            return;
        }
		// 不选该元素
        dfs(candidates,target,sum,k+1);
		
		// 选择该元素
        path.add(candidates[k]);
        // sum增加
        dfs(candidates,target,sum+candidates[k],k);
        // 恢复现场
        path.remove(path.size() - 1);
    }
}
```
### 思路二：枚举选哪个
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates,target,0);
        return ans;
    }
    void dfs(int[] candidates, int target, int i){
        if (target == 0){
            ans.add(new ArrayList<>(path));
            return;
        }
        // 越界，或者和大于target：返回
        if (target < 0 || i == candidates.length){
            return;
        }

        for (int j = i; j < candidates.length; j++){
            // 已选择过的元素可以再选一次
            path.add(candidates[j]);
            dfs(candidates,target-candidates[j],j);
            // 恢复现场
            path.remove(path.size()-1);
        }
    }
}
```