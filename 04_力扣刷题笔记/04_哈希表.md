## 242. 有效的字母异位词
### 题目:
- 给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。
- **字母异位词** 是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。
### 信息:
- **难度**:Easy
- **重要性:** #★★★☆☆
### 思路一：ASCII哈希表
ASCII码的范围为0~127，所以定义一个128长度的哈希表$cnt[128]$即可。

**具体算法流程：**
- 遍历字符串s，获取每个字母出现次数；
- 遍历字符串t，扣减每个字母出现次数；若扣减后出现次数小于0，说明不符合条件，返回false。

通过先判特例：`s.length()!=t.length()`，可以避免多一次循环判断cnt是否全为0.
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] cnt = new int[128];
        if (s.length() != t.length()) return false;
        for (int i = 0; i < s.length(); i++){
            cnt[s.charAt(i)]++; 
        }
        for (int i = 0; i < t.length(); i++){
            cnt[t.charAt(i)]--; 
            if (cnt[t.charAt(i)] < 0) return false;
        }
        return true;
    }
}
```
**不判特例，多一次循环判断。**
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] cnt = new int[128];
        // if (s.length() != t.length()) return false;
        for (int i = 0; i < s.length(); i++){
            cnt[s.charAt(i)]++; 
        }
        for (int i = 0; i < t.length(); i++){
            cnt[t.charAt(i)]--; 
            if (cnt[t.charAt(i)] < 0) return false;
        }
        for (int i : cnt){
            if (i != 0) return false;
        }
        return true;
    }
}
```
## 349. 两个数组的交集
### 题目:
- 给定两个数组 `nums1` 和 `nums2`,返回它们的交集。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路一：利用`cnt[]`数组
遍历数组1，使用cnt数组存储元素出现次数；再次遍历数组2，因为要找到相同元素，则遇到`cnt[num]!=0`，说明遇到了相同元素，添加到结果集中。

为了避免结果集出现重复元素，可以采用两种方式：①set集合保存结果；②使用cnt2数组保存数组2出现的元素，只有`cnt1[num] != 0 && cnt2[num] == 0`，才将元素添加到结果集。

>[!集合→数组]
>利用stream流：`list.stream().mapToInt(Integer::intValue).toArray();`

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] cnt1 = new int[1001];
        int[] cnt2 = new int[1001];

        for (int num : nums1){
            cnt1[num]++;
        }
        List<Integer> list = new ArrayList<>();
        for (int num : nums2){
            if (cnt1[num] != 0 && cnt2[num] == 0){
                list.add(num);
            }
            cnt2[num]++;
        }
        return list.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

## 202. 快乐数
### 题目:
- 编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路一：利用哈希表判重
注意，题目说明：无限循环但始终变不到1，那么说明会有重复元素！故可以采用哈希表判重，出现重复时说明不是快乐数。
>[!获取各位数技巧]-
获取各位数的通用方法：
当n为个位数后，`n/10`等于0，就会退出循环。
>```java
>while(n != 0){
>	x = n % 10;
>	n /=10;
>}
>```

```java
class Solution {
    public boolean isHappy(int n) {
        // 取各位数，将其平方后累加，直到累加和为0。 
        // 如何判断无限循环但始终不为1呢？
        Set<Integer> set = new HashSet<>();
	    // 获取各位平方和
        while (n > 0){
            if (!set.add(n)) return false;
            int sum = 0;
            while (n != 0){
                sum += Math.pow(n % 10,2);
                n /= 10; 
            }
            if (sum == 1) return true;
            else {
                n = sum;}
        }
        return false;
    }
    
}
```
### 思路二：快慢指针
因为若不存在，则会有无限循环，那么说明会有一个"隐藏的环形链表"，故可以使用**快慢指针查找法**来找到交点。
**具体算法流程：**
1. slow指针走一步，fast指针走两步；
2. 最终会出现两种情况：
	1. fast指针先到达快乐数；
	2. slow和fast指针相交，此时说明不是快乐数。

这里使用了do-while循环，用于确保至少先前进一/两步，以便能进入`while(slow!=fast)`的循环。
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = n,fast = n;
        do{
            slow = sum(slow);
            fast = sum(sum(fast));
        }while(slow != fast);
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```
或者也可以先手动走一/两步，让其能进入循环：
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = sum(n),fast = sum(sum(n));
        while (slow != fast){
            slow = sum(slow);
            fast = sum(sum(fast));
        }
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```

## 1. 两数之和
### 题目
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #哈希表 #数组 
### 思路一：哈希表寻找符合要求的两个数
对于这类**无序数组**，且要求寻找符合要求的两个数时，非常适合用哈希表来进行优化。如果直接遍历寻找则需要$O(N^2)$的复杂度，而使用哈希表相当于「空间换时间」，将时间复杂度变成了$O(N)$。

具体算法流程：
- 构建Map存储`Key=nums[i],Value=i;`，利用哈希表的`containsKey()`判断另一个数是否已存在；
- 若已存在，则直接返回答案；
- 若不存在，则存储当前元素，继续往后遍历。
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target - nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 454. 四数相加II

### 题目:
- 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
	- `0 <= i, j, k, l < n`
	- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路一：暴力搜索【超时】
暴力回溯，通过map映射每个数组，通过k选取数组。

此解法会超时。
```java
class Solution {
    private int ans;
    private int[][] map;
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        map = new int[][]{nums1,nums2,nums3,nums4};
        dfs(0,0);
        return ans;
        
    }
    void dfs(int k,int sum){
        if (k == 4){
            if (sum == 0){
                ans++;
            }
            return;
        }
        for (int i = 0; i < map[k].length; i++){
            sum += map[k][i];
            dfs(k+1,sum);
            sum -= map[k][i];
        }
        
    }
}
```
**时间复杂度：** $O(n^4)$
**空间复杂度：** $O(1)$
### 思路二：哈希表
对应四个数组，那么暴力一般都会超时！那么如何避免超时呢？首先想到的就是“记忆化搜索”！

**如何记忆化呢？**
将4层嵌套循环遍历数组 变为 分别遍历两个数组。首先遍历$nums1+nums2$，利用map保存所有的相加结果；然后再遍历$nums3+nums4$，判断相加结果是否出现在哈希表中，若出现了则累加结果$ans$.

通过分别遍历，可以降低时间复杂度。
```java
class Solution {  
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
        int count = 0;  
        HashMap<Integer, Integer> map1 = new HashMap<>();  
        for (int i : nums1) {  
            for (int j : nums2) {  
                map1.put(i+j,map1.getOrDefault(i+j, 0) + 1);  
            }  
        }  
//        ArrayList<Integer> sum2 = new ArrayList<>();  
        for(int i :nums3) {  
            for (int j : nums4) {  
//                a+b+c+d=0  
//                sum1存储了a+b,判断是0-(c+d)的值是否存在  
                if (map1.containsKey(-(i+j))) {  
                    count += map1.get(-(i+j));  
                }  
            }  
        }  
        return count;  
    }  
}
```
**时间复杂度：** $O(n^2)$
**空间复杂度：** $O(n^2)$，最差情况下，需要$n^2$来保存所有$i+j$.
## 383. 赎金信
### 题目:
- 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路一：
利用`cnt[]`数组存储字符出现次数。遍历另一个数组，出现相同字符则扣减，扣减后小于0，则返回false。
```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] cnt = new int[128];
        for (int i = 0; i < magazine.length(); i++){
            cnt[magazine.charAt(i)]++;
        }
        for (int i = 0; i < ransomNote.length(); i++){
            if (--cnt[ransomNote.charAt(i)] < 0){
                return false;
            }
        }
        return true;

    }
}
```
## 49. 字母异位词分组 
### 题目
给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #排序 
### 思路一：
如何判断是否是异位词是本题的关键。
- 如果每次判断都通过逐个判断来进行，那么是个大工程。

但是，如果将字符串按照ASCII码顺序进行排列，那么异位词最终都会是相同的顺序！因此，可以先转换为$char$类型数组进行排序。

第二个问题，是保存异位词相同的对应字符串，可以通过哈希表实现，其中$Key$为排序后的异位词，$Value$为原单词构成的集合。这样就能保证不同异位词对应同一个$Entry$，并且通过$List<String>$可以很方便获取结果。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length; i++){
            char[] str = strs[i].toCharArray();
            Arrays.sort(str);
            String tmp = new String(str);
            // 获取每个idx对应的排序后字符串
            map.computeIfAbsent(tmp, j -> new ArrayList<>()).add(strs[i]);
        }         
        return new ArrayList<>(map.values());
    }
}
```

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length; i++){
            char[] str = strs[i].toCharArray();
            Arrays.sort(str);
            String tmp = new String(str);
            // 获取每个idx对应的排序后字符串
            if (map.containsKey(tmp)){
                map.get(tmp).add(strs[i]);
            }else {
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                map.put(tmp,list);
            }
        }         
        List<List<String>> ans = new ArrayList<>();
        for (List<String> value : map.values()){
            ans.add(value);
        }

        return ans;
    }
}
```
**时间复杂度：** $O(N \times klogk)$，遍历所有$strs$的时间复杂度$O(N)$，每个字符排序的时间复杂度为$O(klogK)$。
**空间复杂度：** $O(N\times k)$

## 128. 最长连续序列
### 题目
给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：
如果排序后，就转换为最长连续子序列问题，不过时间复杂度为$O(NlogN)$，因此本题不适用。

采用$O(N)$的方式，就要求只能一层循环遍历数组。因此，考虑使用哈希表，存储所有元素并去重。然后，对于集合中的数，通过$contains()$方法来寻找其下一个数是否存在，直到下一个数不存在，更新长度。

在这要注意避免大量重复计算：若对于某个$num$，$num-1$也存在，那说明以$num-1$作为起点开始计算的长度肯定大于以$num$作为起点开始计算的长度，因此可以跳过！
```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            set.add(num);
        }
        int ans = 0;
        for (int num : set){
            if (set.contains(num - 1)) {
                continue;
            }

            int y = num+1;
            while (set.contains(y)){
                y++;
            }
            ans = Math.max(ans,y-num);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 438. 找到字符串中的所有字母异位词
### 题目
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #哈希表 #滑动窗口 #字符串 
### 思路一：定长滑动窗口+哈希表
异位词的意思是相同长度的字符串，字母出现次数相等。因此，使用$cnt$数组记录元素出现次数，并通过`Arrays.equals()`方法判断两个数组是否相等来判断是否为异位词。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] sCnt = new int[26];
        int[] pCnt = new int[26];

        for (char c : p.toCharArray()){
            pCnt[c-'a']++;
        }
        int l = 0;
        List<Integer> ans = new ArrayList<>();
        for (int r = 0; r < s.length(); r++){
            char cur = s.charAt(r);
            sCnt[cur-'a']++;
            if (r < p.length()-1) continue;

            if (Arrays.equals(sCnt,pCnt)){
                ans.add(l);
            }
            
            sCnt[s.charAt(l)-'a']--;
            l++;
        }
        return ans;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 

## 76. 最小覆盖子串
### 题目
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #字符串 #哈希表 #滑动窗口 
### 思路一：滑动窗口+哈希表
获取最小子串，那么就是使用滑动窗口。并且需要比较字母出现次数，那么就使用哈希表！

具体算法流程：
1. 初始化最小子串为$ansL=-1,ansR=m$；
2. 不断移动右窗口，直到窗口内包含所有$t$中的字符；
3. 若窗口内已包含t内所有字符，则不断移动左窗口，并最小子串！
4. 若最后ansL被更新了，说明存在最小子串，否则返回空字符串""。

具体的比对是否包含所有的$t$子串，可以定义一个$isCovered$函数来实现。
```java
class Solution {
    public String minWindow(String s, String t) {
        int[] cntS = new int[128];
        int[] cntT = new int[128];

        int m = s.length();
        int n = t.length();

        for (char c : t.toCharArray()){
            cntT[c]++;
        }
        int ansR = m;
        int ansL = -1;
        int l = 0;
        for (int r = 0; r < m; r++){
            cntS[s.charAt(r)]++;
            while (isCovered(cntS,cntT)){
                if (r - l < ansR - ansL){
                    ansL = l;
                    ansR = r;
                }
                cntS[s.charAt(l)]--;
                l++;
            }
        }
        return ansL < 0 ? "" : s.substring(ansL,ansR+1);
    }
    boolean isCovered(int[] cntS, int[] cntT){
        for (int i = 'A'; i <= 'Z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        for (int i = 'a'; i <= 'z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(52m + n)$
**空间复杂度：** $O(128)$

## 3298. 统计重新排列后包含另一个字符串的子字符串数目 II
### 题目
给你两个字符串 `word1` 和 `word2` 。

如果一个字符串 `x` 重新排列后，`word2` 是重排字符串的 前缀 ，那么我们称字符串 `x` 是 **合法的** 。

请你返回 `word1` 中 **合法** 子字符串 的数目。

**注意** ，这个问题中的内存限制比其他题目要 **小** ，所以你 **必须** 实现一个线性复杂度的解法。
### 信息
- **难度：** hard
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #滑动窗口 
### 思路一：
```java
class Solution {
    public long validSubstringCount(String word1, String word2) {
        int[] cnt = new int[26];
        int less = 0;
        for (char c : word2.toCharArray()){
            cnt[c-'a']++;
            if (cnt[c-'a']==1) less++;
        }

        int l = 0;
        long ans = 0;
        for (int r = 0; r < word1.length(); r++){
            char c = word1.charAt(r);
            // 移入窗口内的元素
            cnt[c-'a']--;
            // 若为0，说明原本为1
            if (cnt[c-'a'] == 0){
                less--;
            }
            while (less == 0){
                char out = word1.charAt(l);
                if (cnt[out-'a'] == 0){
                    less++;
                }
                l++;
                cnt[out-'a']++;
            }
            ans += l;
        }
        return ans;
    }

}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 41. 缺失的第一个正数
### 题目
给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #数组 #哈希表 
### 思路一：原地哈希
总体思路就是：让每个索引$i$上的数都等于$i+1$。因此，可以通过遍历并不断交换来实现。

**具体算法流程：**
1. 遍历$i$从$0\sim n-1$，目的是让当前i上的索引回到其应在的位置上；
	- 每遍历一个索引，都会保证有$nums[i]==nums[nums[i]-1]$，或者$nums[i]<=0 || nums[i]>n$（即非法）。
2. 再次遍历，判断位置不符的元素；若所以位置都相符，则返回$n+1$。
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++){
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i]){
                int tmp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = tmp;
            }
        }
        for (int i = 0; i < n; i++){
            if (nums[i] != i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 1338. 数组大小减半
### 题目
给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。

返回 至少 能删除数组中的一半整数的整数集合的最小大小。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #贪心 #堆（优先级队列） #排序 
### 思路一：Map哈希表
1. 利用Map作哈希表，保存元素数量；
2. 利用`values()`方法获取每个元素对应的数量，并调用`list.sort()`方法进行倒排；
3. 贪心获取元素数量，若ans已超过$\frac{n}{2}$，则直接返回。
```java
class Solution {
    public int minSetSize(int[] arr) {
        int n = arr.length;
        Map<Integer,Integer> map = new HashMap<>();
        for (int num : arr){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        List<Integer> cnt = new ArrayList<>(map.values());
        cnt.sort((a,b) -> b-a);
        int ans = 0;
        for (int i = 0; i < cnt.size(); i++){
            ans += cnt.get(i);
            if (ans >= n/2){
                return i+1;
            }
        }
        return -1;
    }
}
```
**时间复杂度：** $O(NlogN)$，瓶颈在于排序。
**空间复杂度：** $O(N)$
### 思路二：数组哈希表
获取$arr$的最大值$mx$，通过
```java
class Solution {
    public int minSetSize(int[] arr) {
        int n = arr.length;
        int mx = 0;
        for (int num : arr){
            mx = mx >= num ? mx : num;
        }
        int[] cnt = new int[mx+1];
        for (int num : arr){
            cnt[num]++;
        }
        Arrays.sort(cnt);
        int ans = 0;
        for (int i = cnt.length-1; i >= 0; i--){
            ans += cnt[i];
            if (ans >= n/2){
                return cnt.length-i;
            }
        }
        return -1;
    }
}
```
**时间复杂度：** $O(N+UlogU)$，其中U为arr的最大值
**空间复杂度：** $O(U)$

## 3159. 查询数组中元素的出现位置
### 题目
给你一个整数数组 `nums` ，一个整数数组 `queries` 和一个整数 `x` 。

对于每个查询 `queries[i]` ，你需要找到 `nums` 中第 `queries[i]` 个 `x` 的位置，并返回它的下标。如果数组中 `x` 的出现次数少于 `queries[i]` ，该查询的答案为 -1 。

请你返回一个整数数组 `answer` ，包含所有查询的答案。
### 信息
- **难度：** medium
- **重要性：** #★☆☆☆☆
- **标签：** #数组 #哈希表 
### 思路一：Map哈希表
queries数组给出的第i次出现，i是从1开始的，所以我们保存时应该也要从1开始，故使用哈希表是从idx=1开始。
获取结果时，遍历queries数组，若`queries[i]`作为Key在map中出现，则直接赋值；否则令`queries[i]=-1`。
```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        // 记录第i次出现x的位置
        Map<Integer, Integer> map = new HashMap<>();
        int idx = 1;
        for (int i = 0; i < nums.length; i++){
            // 存储x出现的位置
            if (nums[i] == x){
                map.put(idx,i);
                idx++;
            }
        }
        for (int i = 0; i < queries.length; i++){
            // 存在
            if (map.containsKey(queries[i])){
                queries[i] = map.get(queries[i]);
            }else{
                queries[i] = -1;
            }
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$
### 思路二：数组哈希表
思路一致，只不过采用数组作为哈希表，利用数组下标作为出现次数。

```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        int[] position = new int[nums.length+1];
        int idx = 1;
        // 找到所有x出现的位置
        Arrays.fill(position,-1);
        for (int i = 0; i < nums.length; i++){
            if (nums[i] == x){
                position[idx] = i;
                idx++;
            }
        }       
        
        for (int i = 0; i < queries.length; i++){
            int curr = queries[i];
            if (curr < position.length && position[curr] != -1){
                queries[i] = position[curr];
            }else {
                queries[i] = -1;
            }
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$

### 思路二：List哈希表
最佳思路，既避免了使用HashMap需要计算哈希值造成的效率偏低一丢丢；也避免了数组造成的初始化空间过大。

**具体算法流程：**
- 初始化ArrayList，遍历nums数组，存储所有x出现的位置。
- 遍历queries：
	- 若出现`queries[i]`的位置大于list的大小，说明不存在；
	- 若`queries[i]`小于size，说明存在，直接`get(queries[i]-1)`获取第`queries[i]`次出现的位置。
```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        List<Integer> pos = new ArrayList<>();
        for (int i = 0; i < nums.length; i++){
            if (nums[i] == x){
                pos.add(i);
            }
        }
        for (int i = 0; i < queries.length; i++){
            queries[i] = queries[i] > pos.size() ? -1 : pos.get(queries[i]-1);
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$

## 3046. 分割数组
### 题目
给你一个长度为 **偶数** 的整数数组 `nums` 。你需要将这个数组分割成 `nums1` 和 `nums2` 两部分，要求：
- `nums1.length == nums2.length == nums.length / 2` 。
- `nums1` 应包含 **互不相同** 的元素。
- `nums2`也应包含 **互不相同** 的元素。

如果能够分割数组就返回 `true` ，否则返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★☆☆☆
- **标签：** #数组 #哈希表 
### 思路一：
因为数组是偶数的，并且nums1和nums2的长度相同，因此我们对每个元素计数，若出现元素的个数大于2，说明不能正常分割，否则可以。
```java
class Solution {
    public boolean isPossibleToSplit(int[] nums) {
        int[] cnt = new int[101];
        for (int num : nums){
            cnt[num]++;
            if (cnt[num] > 2){
                return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 1366. 通过投票对团队排名
### 题目
现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。

排名规则如下：

- 参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。
- 如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。

给你一个字符串数组 `votes` 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。

请你返回能表示按排名系统 **排序后** 的所有团队排名的字符串。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #哈希表 #排序 
### 思路一：哈希表+计数
这题的基本思路就是：利用哈希表存储每个队伍的得票数，然后再根据票数排序。根据题意，队伍为26个字母，最多只有26个，故定义二维数组：`第一维维度=26`，`第二维维度=str.length()`。
**具体算法流程：**
1. 定义二维数组`cnt[26][teamNum+1]`，第一维表示队伍，第二维表示票数；
2. 将cnt数组中的`cnt[teamNum]`设为对应字母，便于后续票数相同时根据字母排序，以及最后的结果构造；
3. 遍历votes数组，更新每个队伍的票数；
4. 数组排序，自定义排序规则：先按照票数排序，最后才按照字母排序。由于票数有多个，因此需要使用for循环，相当于选票1相同，按照选票2排序，选票2相同，按照选票3排序等等等；
5. 构造答案。
```java
class Solution {
    public String rankTeams(String[] votes) {
        // 投票人数
        int peopleNum = votes.length;
        // 队伍数
        int teamNum = votes[0].length();
        // 第一维用于表示队伍
        // 第二维用于表示获取的投票数
        int[][] cnt = new int[26][teamNum+1];

        for (int i = 0; i < 26; i++){
            cnt[i][teamNum] = i;
        }

        for (String vote : votes){
            // 遍历String，更新排名
            char[] tmp = vote.toCharArray();
            for (int i = 0; i < teamNum; i++){
                cnt[tmp[i]-'A'][i]++;
            }
        }
        StringBuilder ans = new StringBuilder();
        // 自定义排序，按照1,2
        Arrays.sort(cnt, (a,b) -> {
            for (int i = 0; i < teamNum; i++){
                if (a[i] != b[i]){
                    return b[i] - a[i];
                }
            }
            return a[teamNum] - b[teamNum];
        });
        // 根据排名构造答案
        for (int i = 0; i < teamNum; i++){
            ans.append((char)(cnt[i][teamNum] + 'A'));
        }
        return ans.toString();
    }
}
```
**时间复杂度：** $O(N^2logN)$
**空间复杂度：** $O(26\times N)$

## 347. 前 K 个高频元素
### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #数组 #哈希表 #排序 #堆（优先级队列） #桶排序
### 思路一：优先队列
使用Map作为哈希表存储每一个元素的出现次数。之后在将每一个Key放入优先队列中，根据其频次进行排序。最后出队k个元素，存入结果。
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        PriorityQueue<Integer> pq = new PriorityQueue((a,b) -> map.get(b) - map.get(a));
        for (int num : nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        for (int key : map.keySet()){
            pq.add(key);
        }
        
        int[] ans = new int[k];
        for (int i = 0; i < k; i++){
            ans[i] = pq.poll();
        }
        
        return ans;
    }
}

```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$

### 思路二：桶排序
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 存储出现频次
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        // 创建桶
        List<Integer>[] freqList = new List[nums.length+1];
        for (int i = 0; i < freqList.length; i++){
            freqList[i] = new ArrayList<>();
        }
        for (int num : map.keySet()){
            freqList[map.get(num)].add(num);
        }
        int[] ans = new int[k];
        int idx = 0;
        for (int freq = freqList.length-1; freq > 0; freq--){
            for (int num : freqList[freq]){
                ans[idx++] = num;
                if (idx == k){
                    return ans;
                }
            }
        }
        return ans;
    }
}
```
**时间复杂度：** $O(N)$ 
**空间复杂度：** $O(N)$