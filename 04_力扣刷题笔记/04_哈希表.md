## 242. 有效的字母异位词
### 题目:
- 给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。
- **字母异位词** 是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。
### 信息:
- **难度**:Easy
- **重要性:** #★★★☆☆
### 思路一：ASCII哈希表
ASCII码的范围为0~127，所以定义一个128长度的哈希表$cnt[128]$即可。

**具体算法流程：**
- 遍历字符串s，获取每个字母出现次数；
- 遍历字符串t，扣减每个字母出现次数；若扣减后出现次数小于0，说明不符合条件，返回false。

通过先判特例：`s.length()!=t.length()`，可以避免多一次循环判断cnt是否全为0.
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] cnt = new int[128];
        if (s.length() != t.length()) return false;
        for (int i = 0; i < s.length(); i++){
            cnt[s.charAt(i)]++; 
        }
        for (int i = 0; i < t.length(); i++){
            cnt[t.charAt(i)]--; 
            if (cnt[t.charAt(i)] < 0) return false;
        }
        return true;
    }
}
```
**不判特例，多一次循环判断。**
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] cnt = new int[128];
        // if (s.length() != t.length()) return false;
        for (int i = 0; i < s.length(); i++){
            cnt[s.charAt(i)]++; 
        }
        for (int i = 0; i < t.length(); i++){
            cnt[t.charAt(i)]--; 
            if (cnt[t.charAt(i)] < 0) return false;
        }
        for (int i : cnt){
            if (i != 0) return false;
        }
        return true;
    }
}
```
## 349. 两个数组的交集
### 题目:
- 给定两个数组 `nums1` 和 `nums2`,返回它们的交集。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路一：利用`cnt[]`数组
遍历数组1，使用cnt数组存储元素出现次数；再次遍历数组2，因为要找到相同元素，则遇到`cnt[num]!=0`，说明遇到了相同元素，添加到结果集中。

为了避免结果集出现重复元素，可以采用两种方式：①set集合保存结果；②使用cnt2数组保存数组2出现的元素，只有`cnt1[num] != 0 && cnt2[num] == 0`，才将元素添加到结果集。

>[!集合→数组]
>利用stream流：`list.stream().mapToInt(Integer::intValue).toArray();`

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] cnt1 = new int[1001];
        int[] cnt2 = new int[1001];

        for (int num : nums1){
            cnt1[num]++;
        }
        List<Integer> list = new ArrayList<>();
        for (int num : nums2){
            if (cnt1[num] != 0 && cnt2[num] == 0){
                list.add(num);
            }
            cnt2[num]++;
        }
        return list.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

## 202. 快乐数
### 题目:
- 编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路一：利用哈希表判重
注意，题目说明：无限循环但始终变不到1，那么说明会有重复元素！故可以采用哈希表判重，出现重复时说明不是快乐数。
>[!获取各位数技巧]-
获取各位数的通用方法：
当n为个位数后，`n/10`等于0，就会退出循环。
>```java
>while(n != 0){
>	x = n % 10;
>	n /=10;
>}
>```

```java
class Solution {
    public boolean isHappy(int n) {
        // 取各位数，将其平方后累加，直到累加和为0。 
        // 如何判断无限循环但始终不为1呢？
        Set<Integer> set = new HashSet<>();
	    // 获取各位平方和
        while (n > 0){
            if (!set.add(n)) return false;
            int sum = 0;
            while (n != 0){
                sum += Math.pow(n % 10,2);
                n /= 10; 
            }
            if (sum == 1) return true;
            else {
                n = sum;}
        }
        return false;
    }
    
}
```
### 思路二：快慢指针
因为若不存在，则会有无限循环，那么说明会有一个"隐藏的环形链表"，故可以使用**快慢指针查找法**来找到交点。
**具体算法流程：**
1. slow指针走一步，fast指针走两步；
2. 最终会出现两种情况：
	1. fast指针先到达快乐数；
	2. slow和fast指针相交，此时说明不是快乐数。

这里使用了do-while循环，用于确保至少先前进一/两步，以便能进入`while(slow!=fast)`的循环。
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = n,fast = n;
        do{
            slow = sum(slow);
            fast = sum(sum(fast));
        }while(slow != fast);
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```
或者也可以先手动走一/两步，让其能进入循环：
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = sum(n),fast = sum(sum(n));
        while (slow != fast){
            slow = sum(slow);
            fast = sum(sum(fast));
        }
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```

## 1. 两数之和
### 题目:
- 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_ 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路1:
- 这题最简单的方法就是利用两个for循环实现!
#### 思路2:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public int[] twoSum(int[] nums, int target) {  
//        解法1: 使用数组遍历  
        int sum = 0;  
        for (int i = 0; i < nums.length - 1; i++)  
            for (int j = i+1; j < nums.length; j++){  
                sum = nums[i] + nums[j];  
                if (sum == target)  
                    return new int[]{i,j};  
            }  
        return null;  
```


## 454. 四数相加II

### 题目:
- 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
	- `0 <= i, j, k, l < n`
	- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路一：暴力搜索【超时】
暴力回溯，通过map映射每个数组，通过k选取数组。

此解法会超时。
```java
class Solution {
    private int ans;
    private int[][] map;
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        map = new int[][]{nums1,nums2,nums3,nums4};
        dfs(0,0);
        return ans;
        
    }
    void dfs(int k,int sum){
        if (k == 4){
            if (sum == 0){
                ans++;
            }
            return;
        }
        for (int i = 0; i < map[k].length; i++){
            sum += map[k][i];
            dfs(k+1,sum);
            sum -= map[k][i];
        }
        
    }
}
```
**时间复杂度：** $O(n^4)$
**空间复杂度：** $O(1)$
### 思路二：哈希表
对应四个数组，那么暴力一般都会超时！那么如何避免超时呢？首先想到的就是“记忆化搜索”！

**如何记忆化呢？**
将4层嵌套循环遍历数组 变为 分别遍历两个数组。首先遍历$nums1+nums2$，利用map保存所有的相加结果；然后再遍历$nums3+nums4$，判断相加结果是否出现在哈希表中，若出现了则累加结果$ans$.

通过分别遍历，可以降低时间复杂度。
```java
class Solution {  
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
        int count = 0;  
        HashMap<Integer, Integer> map1 = new HashMap<>();  
        for (int i : nums1) {  
            for (int j : nums2) {  
                map1.put(i+j,map1.getOrDefault(i+j, 0) + 1);  
            }  
        }  
//        ArrayList<Integer> sum2 = new ArrayList<>();  
        for(int i :nums3) {  
            for (int j : nums4) {  
//                a+b+c+d=0  
//                sum1存储了a+b,判断是0-(c+d)的值是否存在  
                if (map1.containsKey(-(i+j))) {  
                    count += map1.get(-(i+j));  
                }  
            }  
        }  
        return count;  
    }  
}
```
**时间复杂度：** $O(n^2)$
**空间复杂度：** $O(n^2)$，最差情况下，需要$n^2$来保存所有$i+j$.
## 383. 赎金信
### 题目:
- 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路一：
利用`cnt[]`数组存储字符出现次数。遍历另一个数组，出现相同字符则扣减，扣减后小于0，则返回false。
```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] cnt = new int[128];
        for (int i = 0; i < magazine.length(); i++){
            cnt[magazine.charAt(i)]++;
        }
        for (int i = 0; i < ransomNote.length(); i++){
            if (--cnt[ransomNote.charAt(i)] < 0){
                return false;
            }
        }
        return true;

    }
}
```
## 49. 字母异位词分组 
### 题目
给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #排序 
### 思路一：
如何判断是否是异位词是本题的关键。
- 如果每次判断都通过逐个判断来进行，那么是个大工程。

但是，如果将字符串按照ASCII码顺序进行排列，那么异位词最终都会是相同的顺序！因此，可以先转换为$char$类型数组进行排序。

第二个问题，是保存异位词相同的对应字符串，可以通过哈希表实现，其中$Key$为排序后的异位词，$Value$为原单词构成的集合。这样就能保证不同异位词对应同一个$Entry$，并且通过$List<String>$可以很方便获取结果。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length; i++){
            char[] str = strs[i].toCharArray();
            Arrays.sort(str);
            String tmp = new String(str);
            // 获取每个idx对应的排序后字符串
            map.computeIfAbsent(tmp, j -> new ArrayList<>()).add(strs[i]);
        }         
        return new ArrayList<>(map.values());
    }
}
```

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length; i++){
            char[] str = strs[i].toCharArray();
            Arrays.sort(str);
            String tmp = new String(str);
            // 获取每个idx对应的排序后字符串
            if (map.containsKey(tmp)){
                map.get(tmp).add(strs[i]);
            }else {
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                map.put(tmp,list);
            }
        }         
        List<List<String>> ans = new ArrayList<>();
        for (List<String> value : map.values()){
            ans.add(value);
        }

        return ans;
    }
}
```
**时间复杂度：** $O(N \times klogk)$，遍历所有$strs$的时间复杂度$O(N)$，每个字符排序的时间复杂度为$O(klogK)$。
**空间复杂度：** $O(N\times k)$

## 128. 最长连续序列
### 题目
给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：
如果排序后，就转换为最长连续子序列问题，不过时间复杂度为$O(NlogN)$，因此本题不适用。

采用$O(N)$的方式，就要求只能一层循环遍历数组。因此，考虑使用哈希表，存储所有元素并去重。然后，对于集合中的数，通过$contains()$方法来寻找其下一个数是否存在，直到下一个数不存在，更新长度。

在这要注意避免大量重复计算：若对于某个$num$，$num-1$也存在，那说明以$num-1$作为起点开始计算的长度肯定大于以$num$作为起点开始计算的长度，因此可以跳过！
```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            set.add(num);
        }
        int ans = 0;
        for (int num : set){
            if (set.contains(num - 1)) {
                continue;
            }

            int y = num+1;
            while (set.contains(y)){
                y++;
            }
            ans = Math.max(ans,y-num);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 438. 找到字符串中的所有字母异位词
### 题目
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #哈希表 #滑动窗口 #字符串 
### 思路一：定长滑动窗口+哈希表
异位词的意思是相同长度的字符串，字母出现次数相等。因此，使用$cnt$数组记录元素出现次数，并通过`Arrays.equals()`方法判断两个数组是否相等来判断是否为异位词。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] sCnt = new int[26];
        int[] pCnt = new int[26];

        for (char c : p.toCharArray()){
            pCnt[c-'a']++;
        }
        int l = 0;
        List<Integer> ans = new ArrayList<>();
        for (int r = 0; r < s.length(); r++){
            char cur = s.charAt(r);
            sCnt[cur-'a']++;
            if (r < p.length()-1) continue;

            if (Arrays.equals(sCnt,pCnt)){
                ans.add(l);
            }
            
            sCnt[s.charAt(l)-'a']--;
            l++;
        }
        return ans;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 

## 76. 最小覆盖子串
### 题目

### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #字符串 #哈希表 #滑动窗口 
### 思路一：滑动窗口+哈希表
获取最小子串，那么就是使用滑动窗口。并且需要比较字母出现次数，那么就使用哈希表！

具体算法流程：
1. 初始化最小子串为$ansL=-1,ansR=m$；
2. 不断移动右窗口，直到窗口内包含所有$t$中的字符；
3. 若窗口内已包含t内所有字符，则不断移动左窗口，并最小子串！
4. 若最后ansL被更新了，说明存在最小子串，否则返回空字符串""。

具体的比对是否包含所有的$t$子串，可以定义一个$isCovered$函数来实现。
```java
class Solution {
    public String minWindow(String s, String t) {
        int[] cntS = new int[128];
        int[] cntT = new int[128];

        int m = s.length();
        int n = t.length();

        for (char c : t.toCharArray()){
            cntT[c]++;
        }
        int ansR = m;
        int ansL = -1;
        int l = 0;
        for (int r = 0; r < m; r++){
            cntS[s.charAt(r)]++;
            while (isCovered(cntS,cntT)){
                if (r - l < ansR - ansL){
                    ansL = l;
                    ansR = r;
                }
                cntS[s.charAt(l)]--;
                l++;
            }
        }
        return ansL < 0 ? "" : s.substring(ansL,ansR+1);
    }
    boolean isCovered(int[] cntS, int[] cntT){
        for (int i = 'A'; i <= 'Z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        for (int i = 'a'; i <= 'z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(52m + n)$
**空间复杂度：** $O(128)$


## 41. 缺失的第一个正数
### 题目
给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #数组 #哈希表 
### 思路一：原地哈希
总体思路就是：让每个索引$i$上的数都等于$i+1$。因此，可以通过遍历并不断交换来实现。

**具体算法流程：**
1. 遍历$i$从$0\sim n-1$，目的是让当前i上的索引回到其应在的位置上；
	- 每遍历一个索引，都会保证有$nums[i]==nums[nums[i]-1]$，或者$nums[i]<=0 || nums[i]>n$（即非法）。
2. 再次遍历，判断位置不符的元素；若所以位置都相符，则返回$n+1$。
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++){
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i]){
                int tmp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = tmp;
            }
        }
        for (int i = 0; i < n; i++){
            if (nums[i] != i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$