如果某一问题有很多重叠子问题，使用动态规划是最有效的。
所以动态规划中**每一个状态一定是由上一个状态推导出来的**，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

- **重叠子问题**：通过递归的方式解决同样的子问题，很多次计算相同的子问题。
- **最优子结构**：大问题的最优解可以通过子问题的最优解来递推。

**动态规划五部曲:**
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# 01背包问题

## 问题描述:
有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。
## 解决思路:
### 1. **确定dp数组以及下标的含义:**
- 有两个维度的数据: 1)物品; 2)背包容量(重量). 
- 物品的重量以及价值如下图所示
![[Pasted image 20241016144113.png]]
#### **填充物品dp数组:**
>因为要获取最大价值,所以表格内的数据应当是**当前情况下所能取得的最大价值.**

考虑**仅有物品1**的情况,遍历所有背包容量,此时可以填充第一行:
![[Pasted image 20241016143756.png|450]]

继续填充第二行,即物品0和物品1,遍历所有的背包容量: (注意,物品1的重量为3!)
![[Pasted image 20241016143924.png|450]]

继续填充第三行,此时有3个物品,遍历所有背包容量:
![[Pasted image 20241016144741.png|450]]
>[!注意:]
>**明确dp[i][j]的含义:在物品0~i中选择物品,在不超过容量j的情况下,使得背包总价值最大!**

最终,我们要获取的结果即为`dp[2][4]`!

### 2. 确定递推公式:
以`dp[1][4]`举例,分为两种情况:**放物品1或不放物品1.**
	放物品1时,需要保留物品1的容量,并且考虑到物品1的重量为3,所以可由"**`dp[0][1]`+物品1**"获得.
	不放物品1时,此时由`dp[0][4]`获得.

**上述情况可抽象为:**
- 不放物品i: 背包容量为j,不放物品i的最大价值为`dp[i-1][j]`.
- 放物品i: 最大价值为`dp[i-1][j-weight[i]]+value[i]`.
所以,要获取`dp[i][j]`的最大价值,即取上述两种情况的较大值:
`dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])`

### 3. dp数组的初始化:
即考虑上述表格的边界条件: i=0/j=0的情况:
![[Pasted image 20241016150727.png|450]]

### 4. 确定遍历顺序:
>一般来说,先遍历物品,或者先遍历背包容量都可以.

根据我的思维,一般喜欢先遍历物品,然后遍历背包容量,即i=0时,j从0~4;i=1,j从0~4;i=2,j从0~4.\
```java
for (int i = 1; i < weight.size();i++){
	for (int j = 0; j <= bagWeight; j++){
		if (j < weight[i]) dp[i][j] = dp[i-1][j];
		else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]]);
	}
}
```
## 滚动数组优化:
>在01背包问题中,可以用一维滚动数组来代替二维数组,进行时间,空间复杂度上的优化.
![[Pasted image 20241017085159.png|450]]
1. dp数组的定义: `dp[j]`表示容量为j的背包,所背的物品最大价值为`dp[j]`.
2. ==**递推公式:**== `dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i])`;
3. 初始化:`dp[j]`表示**容量为j的背包**,所背的物品最大价值为`dp[j]`,所以初始化`dp[0]=0`;
4. ==**遍历顺序:**== 
	正序遍历时,情况如下,可以看到`dp[2]`实质上是将物品0放入了2次!
	`dp[1] = max(dp[1],dp[1-1]+15) = max(dp[1],dp[0]+15)=15`;
	`dp[2] = max(dp[2],dp[2-1]+15 = max(dp[2],dp[1]+15)=30`;
	逆序遍历:
	`dp[2] = max(dp[2],dp[2-1]+15) = max(dp[2],dp[1]+15)=15` (此时`dp[0]`为初始化的0)
	`dp[1] = max(dp[1],dp[1-1]+15 = max(dp[1],dp[0]+15)=15`

```java
for (int i = 0; i < size; i++){
	for (int j = bagWeight; j >= weight[i]; j--){
		dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])
	}
}
```

## 416. 分割等和子集
### 题目
给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #动态规划 #数组 #01背包
### 思路一：递归+记忆化搜索

**问题解答：**
1. 本题如何进行记忆化搜索？
	- 使用`int[i][target]`数组记录元素`[0,i]`中目标和为target，是否被计算过。若被计算过，则用`0和1`存储，0代表无法获得当前目标和的正确子集，1代表可获得正确子集。
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        int n = nums.length;
        for (int num : nums){
            sum += num;
        }
        if (sum % 2 != 0) return false;
        int[][] memo = new int[n][sum / 2 + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dfs(n-1,sum/2,nums,memo);
    }
    // 目的：从[0,i]选择元素
    boolean dfs(int i, int target, int[] nums,int[][] memo){
        if (i < 0) {
            return target == 0;
        }    
        if (memo[i][target] != -1) return memo[i][target] == 1;
        boolean res = (target >= nums[i] && dfs(i-1,target-nums[i],nums,memo) || dfs(i-1,target,nums,memo));
        memo[i][target] = res ? 1 : 0;
        return res;
    }
}
```
**时间复杂度：** $O(N\times S)$
**空间复杂度：** $O(N\times S)$
### 思路二：动态规划（递推）
- **dp数组定义**：`dp[i][j]`表示能否从前i个元素中选择和为target的子集。
- **dp数组初始化**：因为要从`dp[i-1]`开始递推，所以需要初始化`dp[0][j]`，即`dp[0][target] = nums[0]==target`；
- **递推公式**：两种情况，选或不选`nums[i]`，故`dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]`
- **遍历顺序**：想象一个i行j列的表格，需要获取最右下角元素，因此正序遍历即可。
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums){
            sum += num;
        }
        if (sum % 2 != 0) return false;

        int n = nums.length;
        int target = sum / 2;
        boolean[][] dp = new boolean[n][target+1];
        dp[0][0] = true;  // 不选任何元素时和为0是可能的

        // 初始化第一行：若 target 为 nums[0]，则为true
        for (int j = 1; j <= target; j++) {
            dp[0][j] = (j == nums[0]);
        }

        for (int i = 1; i < n; i++){
            for (int j = 0; j <= target; j++){
                dp[i][j] = dp[i-1][j] || (j >= nums[i] && dp[i-1][j-nums[i]]); 
            }
        }
        return dp[n-1][target];
    }
}
```
**时间复杂度：** $O(N\times S)$
**空间复杂度：** $O(N\times S)$
# 完全背包问题:
>**与01背包的区别在于:完全背包中某个物品可以添加多次.**

回想前面01背包问题的正序遍历,会导致物品被重复添加,而这正是完全背包需要的效果,所以在完全背包问题中,遍历代码为:
>	这里遍历时从`weight[i]`开始,**是保证最少能取一个物品**,毕竟容量小于物品重量时,无太大意义.

```java
for (int i = 0; i < weight.size(); i++){ // 遍历物品
	for (int j = weight[i]; j <= bagWeight; j++){   //遍历背包容量(正序)
		dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);
	}
}
```
>对于下面的求解"最少个数"的问题,遍历一般如下:
>	1. 首先要先初始化;
>	2. 先遍历物品,再遍历容量,并且注意物品是可以重复使用的(所以内层循环也是正序);
>	3. 注意对于某些问题,判断`dp[j-coins[i]]`是否可达!
```java
Arrays.fill(dp,Integer.MAX_VALUE);
dp[0]=0;

for (int i = 0; i < n; i++) {   // 物品  
    for (int j = coins[i]; j <= amount; j++) {   // 容量  
        if (dp[j - coins[i]] != Integer.MAX_VALUE) {  
            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);  
        }  
    }  
}
```

## 518. 零钱兑换II
### 题目:
给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。

题目数据保证结果符合 32 位带符号整数。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 硬币可以重复选择,所以是完全背包问题.
- `dp[j] += dp[j-coins[i]]`:是一直在**更新(累加)**`dp[j]`的可能性
![[Pasted image 20241017140738.png|500]]
### 代码:
```java
class Solution {  
    public int change(int amount, int[] coins) {  
        int n = coins.length;  
        // dp[j]表示容量为j的背包的最大价值,在这里,物品价值与重量一样  
        int[] dp = new int[amount+1];  
        dp[0] = 1;  
        for (int i = 0; i < n; i++) {  
            for (int j = coins[i]; j <= amount; j++) {  
                dp[j] += dp[j-coins[i]];  
            }  
        }  
        return dp[amount];  
    }  
}  
```

## 377. 组合总数IV
### 题目:
给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素**组合的个数**。

题目数据保证答案符合 32 位整数范围。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 与[[#518. 零钱兑换II]]几乎一样,但是518是求组合,本题是求排列! 对于求排列问题,**需要在外层遍历背包容量,内层遍历物品,否则只会有{1,3}组合,而不会有{3,1}组合,因为总是先放置物品1.**
### 代码:
```java
class Solution {  
    public int combinationSum4(int[] nums, int target) {  
        int n = nums.length;  
        int[] dp = new int[target+1];  
        dp[0] = 1;  
  
        for (int i = 0; i <= target ; i++) {  
            for (int j = 0; j < n; j++) {  
                if (i - nums[j] >= 0) { // 容量大于物品重量时，才放  
                    dp[i] += dp[i-nums[j]];  
                }  
            }  
        }  
        return dp[target];  
    }  
}

```
## 70. 爬楼梯
### 题目
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
### 信息
- **难度：** easy
- **重要性：** #★★☆☆☆ 
- **标签：** #动态规划 
### 思路一：动态规划
由于有两种跳跃方法，则到达第n阶可通过两种方式：从第n-1阶台阶跳1阶到达和从第n-2阶台阶跳2阶到达。据此我们相当于得到了递推表达式。
```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2]; 
        }
        return dp[n];
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：递归+记忆化搜索
第n阶的跳跃方式可由第n-1阶的跳跃方式和第n-2阶的跳跃方式获得，因此可以逐步划分为子问题，直至到达第1阶和第0阶台阶，此时已知跳跃方式为1种。

并且为了避免重复计算，可以定义memo数组用于存储计算结果。
![[Pasted image 20241230132201.png|450]]
```java
class Solution {
    public int climbStairs(int n) {
        int[] memo = new int[n+1];
        return dfs(n,memo);
    }
    int dfs(int n,int[] memo){
        if (n <= 1){
            return 1;
        }  
        if (memo[n] != 0){
            return memo[n];
        }
        memo[n] = dfs(n-1,memo) + dfs(n-2,memo);
        return memo[n];
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N$)
## 322. 零钱兑换 
### 题目:
给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 思路与[[#279. 完全平方数]]一致,区别在于这里需要判断`dp[j-coins[i]]`是否可达!
	- 例如对于`coins=[2],amount=3`,此时`dp[3]`就是不可达的!
### 代码:
```java
class Solution {  
    public int coinChange(int[] coins, int amount) {  
        int n = coins.length;  
        int[] dp = new int[amount + 1];  
        for (int i = 0; i < dp.length; i++) {  
            dp[i] = Integer.MAX_VALUE;  
        }  
        dp[0] = 0;  
  
        for (int i = 0; i < n; i++) {   // 物品  
            for (int j = coins[i]; j <= amount; j++) {   // 容量  
                if (dp[j - coins[i]] != Integer.MAX_VALUE) {  
                    dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);  
                }  
            }  
        }  
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];  
    }  
}  
```
## 279. 完全平方数
>**时间**：2025-2-8 20:03:18
### 题目
给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

	输入：n = 12
	输出：3 
	解释：12 = 4 + 4 + 4
### 信息
- **难度：** medium
- **重要性：** #★★★★☆ 
- **标签：** #动态规划 
### 思路一：
- **dp数组定义**：`dp[i]`表示和为i的最少完全平方数数量；
- **递推公式**：对于每个i，都尝试通过小于i的完全平方数以及平方数`x=j*j`进行更新；
- **初始化**：对于每个i，最差情况为全由1组成。
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for (int i = 1; i <= n; i++){
            dp[i] = i;
        }
        for (int i = 1; i <= n; i++){
            for (int j = 1; j * j <= i; j++){
                int x = j * j;
                dp[i] = Math.min(dp[i],dp[i-x]+1);
            }
        }
        return dp[n];
    }
}
```
**时间复杂度：** $O(N\times \sqrt{N})$
**空间复杂度：** $O(N)$
## 139. 单词拆分
### 题目:
给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
### 信息:
- **难度**: meidum
- **重要性:** #★★★★☆
### 思路:
- `dp[i]`表示前i个字符能否被字典中的单词拼接.
- 因为是要求排列问题,所以先遍历背包,再遍历物品.
### 代码:
```java
class Solution {  
    public boolean wordBreak(String s, List<String> wordDict) {  
        int n = s.length();  
        boolean[] dp = new boolean[n+1];  
        HashSet<String> set = new HashSet<>(wordDict);  
		dp[0] = true;  // 定义空字符串也可拆分.
        // 完全背包.  
        for (int i = 1; i <= n; i++) {        // 背包.  
            for (int j = 0; j < i; j++) {     // 物品.  
                String str = s.substring(j,i);  
                if (set.contains(str) && dp[j]) {  
                    dp[i] = true;  
                }  
            }  
        }  
        return dp[n];  
    }  
}  
```
### 优化时空复杂度:
```java
class Solution {  
    public boolean wordBreak(String s, List<String> wordDict) {  
        int n = s.length();  
        boolean[] dp = new boolean[n+1];  
        HashSet<String> set = new HashSet<>(wordDict);  
        dp[0] = true;  
  
        int maxLen = 0;  
        for (String word : wordDict) {  
            maxLen = Math.max(maxLen, word.length());  
        }  
  
        // 完全背包.  
        for (int i = 1; i <= n; i++) {        // 背包.  
            for (int j = Math.max(0, i - maxLen); j < i; j++) {    // 物品.  
                String str = s.substring(j,i);  
                if (set.contains(str) && dp[j]) {  
                    dp[i] = true;  
                    break;  
                }  
            }  
        }  
        return dp[n];  
    }  
}  
```
# 背包问题总结:
**递推公式**
> 👉 问能否装满背包（或者最多装多少）：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`
> 
> 👉 问装满背包几种方法：`dp[j] += dp[j - nums[i]]`
> 
> 👉 问装满背包最大价值：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
> 
> 👉 问装满背包最小个数：`dp[j] = min(dp[j], dp[j - coins[i]] + 1)`

**遍历顺序**

> 👉 01背包  
> 二维 dp 数组：先遍历物品或背包皆可，且第二层是从小到大遍历。  
> 一维 dp 数组：先遍历物品再遍历背包，且第二层是从大到小遍历。
> 
> 👉 完全背包（一维 dp 数组）  
> **求组合数：** 先遍历物品再遍历背包，且第二层是从小到大遍历。  
> **求排列数：** 先遍历背包再遍历物品，且第二层是从小到大遍历。  
> **求最小值：** 先遍历物品或背包皆可，且第二层是从小到大遍历。


# 树形DP:
## 377. 打家劫舍III
### 题目:

### 信息:
- **难度**:
- **重要性:** #★★★★☆
### 思路1:
- 通过递归+记忆化搜索来实现,即分为两种情况:
	1. 选择root节点,则儿子不能选,只能选孙子;
	2. 不选择root节点,则儿子可以选.
- 对于树形的记忆化搜索,利用HashMap做缓存.最后选择两种情况的最大值.
### 代码:
```java
class Solution {  
    HashMap<TreeNode,Integer> map = new HashMap<>();  
    public int rob(TreeNode root){  
        return rob1(root);  
    }  
  
    public int rob1(TreeNode root) {  
        if (root == null) return 0;  
  
        if (map.containsKey(root)) return map.get(root);  
  
        int money = root.val;  
  
        if (root.left != null){  
            money += (rob1(root.left.left)+rob1(root.left.right));  
        }  
        if (root.right != null){  
            money += rob1(root.right.left)+rob1(root.right.right);  
        }  
        int ans = Math.max(money,rob1(root.left)+rob1(root.right));  
        map.put(root,ans);  
        return ans;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

### 思路2:
- 动态规划进行优化,定义二维数组`ans`,`ans[0]`存放放根节点的,`ans[1]`存放不放根节点的,这两种情况就代表了当前节点的两种情况!(取最大值即为当前节点的最大价值)
- `ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);`代表了当前节点不偷的情况,而这种情况包含**子节点偷(`[1]`)/不偷(`[0]`)**.
- `ans[1] = left[0] + right[0] + root.val;`代表了当前节点偷的情况,即**此时子节点不能偷**!所以此时只能取`left[0]`与`right[0]`.

```java hl:16-17
class Solution {  
    public int rob(TreeNode root){  
        int[] ans = rob1(root);  
        return Math.max(ans[0],ans[1]);  
    }  
  
    public int[] rob1(TreeNode root) {  
        int[] ans = new int[]{0,0};  
        // 到底,返回.  
        if (root == null) return ans;  
        // 存储 不放根节点+放根节点  
        // 左儿子,右儿子  
        int[] left = rob1(root.left);  
        int[] right = rob1(root.right);  
  
        ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);   //不放根节点: 儿子偷!  
        ans[1] = left[0] + right[0] + root.val;  // 放根节点: 儿子不偷+根节点  
  
        return ans;  
    }  
}
```


# 股票问题:
**初始化逻辑:** 
- **第`j`次交易不持股的状态**初始化为:`Integer.MIN_VALUE`,以便于后面买入时更新.
	- `dp[j][1]=Integer.MIN_VALUE`
- **第`j`次交易持股的状态**初始化为`0`,即不持股时没有任何收益
	- `dp[j][0]=0`
**遍历顺序:**
- `for (int i = 0; i < n; i++)`:即
## 121. 买卖股票的最佳时机
### 题目:
你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路1:
- 持续更新最小成本作为买入价格,遍历所有`price[i]`计算利润.
### 代码1:
```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int minPrice = prices[0];
        for (int p : prices) {
            ans = Math.max(ans, p - minPrice);
            minPrice = Math.min(minPrice, p);
        }
        return ans;
    }
}
```

### 思路2:
- 前i天分别有两种状态:持有股票和不持有股票,所以`dp[i][j]`表示下标为 `i` 这一天结束的时候，手上持股状态为 `j` 时，我们持有的现金数。
	- `dp[i][0]`:表示第i天,不持有股票时,持有的现金数.
	- `dp[i][1]`:表示第i天,持有股票时,持有的现金数.
- 将`dp[i][1]`初始化为`-price[i]`,这样能保证在计算利润时,即`prices[i] + dp[i-1][1]`,能更方便获取买入价格.
### 代码2:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // dp[i][0]表示第i天不持有股票所得最多现金.  
        // dp[i][1]表示第i天持有股票所得最多现金.  
        int[][] dp = new int[n][2];  
        dp[0][0] = 0;  
        dp[0][1] = -prices[0];  
        //int ans = 0;  
        for (int i = 1; i < n; i++) {  
            dp[i][0] = Math.max(prices[i] + dp[i-1][1],dp[i-1][0]);  
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);   //持续获取最低买入价格.
        }  
        return Math.max(dp[n-1][0],dp[n-1][1]);  
    }  
}
```
## 122. 买卖股票的最佳时机II
>**时间**：2025-02-07 17:36:52
### 题目
给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #动态规划 
### 思路一：动态规划
- **dp数组定义**：`dp[i][0]`表示前i天不持有股票的利润；`dp[i][1]`表示前i天持有股票的利润。
- **dp数组初始化**：`dp[i][j]`初始化，因为从第一天开始递推，也就是i=1开始遍历，因此我们需要初始化`dp[0][0]`和`dp[0][1]`。`dp[0][0]=0`，代表第0天不持有的情况下利润为0；`dp[0][1]=Integer.MIN_VALUE`，代表第0天不持有的情况不可能发生，并便于后续更新（成本为负）。
- **递推公式**：
	- 不持有的情况下，可能是前一天不持有且今天继续不持有，或者前一天持有且今天卖出：`dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1])`.
	- 持有的情况下，可能是前一天持有且今天继续持有，前一天不持有且今天买入（加上成本），`dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i])`
- **遍历顺序**：自然是正序遍历。
```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // dp[i][0/1]表示前i天所能获得的最大利润（区分是否持有股票）
        int[][] dp = new int[n+1][2];
        dp[0][0] =  0;
        dp[0][1] = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++){
            // 不持有股票：1.卖出；2.继续不持有
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
            // 持有股票：1.继续持有；2.买入
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]);
        }        
        // 返回值肯定不持有股票
        return dp[n][0];
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 123. 买卖股票的最佳时机III
### 题目:
给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 因为限制了只能买入两次,所以在[[#122. 买卖股票的最佳时机II]]的基础上**再增加一个维度**来记录买卖次数,即`dp[i][j][k]`.
- **递推公式:**
- `return Math.max(dp[1][0],dp[2][0])`:保证仅有一次交易时,也能返回正确的答案.
### 代码:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][][] dp = new int[n][3][2];  
        dp[0][1][1] = -prices[0];  
        dp[0][2][1] = Integer.MIN_VALUE;  
        for (int i = 1; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[i][1][0] = Math.max(dp[i-1][1][1]+prices[i],dp[i-1][1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[i][1][1] = Math.max(-prices[i],dp[i-1][1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[i][2][0] = Math.max(dp[i-1][2][1]+prices[i],dp[i-1][2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[i][2][1] = Math.max(dp[i-1][1][0]-prices[i],dp[i-1][2][1]);  
        }  
        return Math.max(dp[n-1][1][0],dp[n-1][2][0]);  
    }  
}

```

### 代码2:滚动数组优化:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][][] dp = new int[2][3][2];  
        dp[0][1][1] = -prices[0];  
        dp[0][2][1] = Integer.MIN_VALUE;  
        for (int i = 1; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[i%2][1][0] = Math.max(dp[(i-1)%2][1][1]+prices[i],dp[(i-1)%2][1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[i%2][1][1] = Math.max(-prices[i],dp[(i-1)%2][1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[i%2][2][0] = Math.max(dp[(i-1)%2][2][1]+prices[i],dp[(i-1)%2][2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[i%2][2][1] = Math.max(dp[(i-1)%2][1][0]-prices[i],dp[(i-1)%2][2][1]);  
        }  
        return Math.max(dp[(n-1)%2][1][0],dp[(n-1)%2][2][0]);  
    }  
}
```
### 代码3:使用二维数组(当天的值之与前一天的值相关)
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][] dp = new int[3][2];  
        //dp[1][1] = -prices[0];  
        dp[1][1] = Integer.MIN_VALUE;  
        dp[2][1] = Integer.MIN_VALUE;  
        for (int i = 0; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[1][0] = Math.max(dp[1][1]+prices[i],dp[1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[1][1] = Math.max(-prices[i],dp[1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[2][0] = Math.max(dp[2][1]+prices[i],dp[2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[2][1] = Math.max(dp[1][0]-prices[i],dp[2][1]);  
        }  
        return Math.max(dp[1][0],dp[2][0]);  
    }  
}
```
## 188. 买卖股票的最佳时机IV
### 题目:
给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 使用二维数组进行优化,因为当天的值只与前一天的值有关,所以可以**通过状态压缩来节省内存空间.** 具体而言就是在循环中不断更新`dp[j][1/0]`!
- 更进一步的优化,源于ChatGPT的思路,见代码2.
- **初始化: 将第一次买入的价格置为最小值,便于后面的更新.**
- **根本的递推思路都没变**:(j表示交易次数)
	- **持股时:** 1)前一天不持股+今天买入; 2)前一天持股,今天继续持股;
		- `dp[j][1] = Math.max(dp[j-1][0]-prices[i-1],dp[j][1])`
			- **今天买入,此时对应前一天应该是第j-1次交易!**
	- **不持股时:** 1)前一天持股,今天卖出; 2)前一天不持股+今天继续不持股;
		- `dp[j][0] = Math.max(dp[j][1]+price[i-1],dp[j][0])`
### 代码1:
```java hl:13,14
class Solution {  
    public int maxProfit(int k, int[] prices) {  
        int n = prices.length;  
  
        int[][] dp = new int[k+1][2];  
        for (int i = 0; i <= n; i++) {  
            for (int j = 0; j <= k; j++) {  
                dp[j][1] = Integer.MIN_VALUE;  
            }  
        }  
        for (int i = 1; i <= n; i++) {  
            for (int j = 1; j <= k; j++) {  
                dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i - 1]);  
                dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i - 1]);  
            }  
        }  
        // 说明：第一维和第二维状态都具有前缀性质的，输出最后一个状态即可  
        return dp[k][0];  
    }  
}
```
### 代码2:
```java hl:17-18
class Solution {  
    public int maxProfit(int k, int[] prices) {  
        int n = prices.length;  
        if (n == 0 || k == 0) return 0;  
        // dp[j][0]：第j次交易后，不持股的最大利润  
        // dp[j][1]：第j次交易后，持股的最大利润  
        int[] dp0 = new int[k + 1];  // dp[j][0] 简化为 dp0[j]        
        int[] dp1 = new int[k + 1];  // dp[j][1] 简化为 dp1[j]  
        // 初始化 dp1 数组为最小值，因为开始时我们还没有进行任何交易  
        for (int j = 0; j <= k; j++) {  
            dp1[j] = Integer.MIN_VALUE;  
        }  
  
        for (int price : prices) {  
            for (int j = 1; j <= k; j++) {  
                dp1[j] = Math.max(dp1[j], dp0[j - 1] - price); // 买入  
                dp0[j] = Math.max(dp0[j], dp1[j] + price);     // 卖出  
            }  
        }  
        return dp0[k];  
    }  
}
```

### 剪枝操作:
- 如果可交易次数大于交易天数的一半,则可以累加所以的正利润
	- 例如:`[1,2,3,4,5,6],k=3`,最大利润为5,可通过累加获得!
```java
if (k >= n / 2) {  
    // 如果可以进行的交易次数大于等于可交易的天数的一半，使用贪心法  
    int maxProfit = 0;  
    for (int i = 1; i < n; i++) {  
        if (prices[i] > prices[i - 1]) {  
            maxProfit += prices[i] - prices[i - 1]; // 累加所有正利润  
        }  
    }  
    return maxProfit;  
}
```

## 309. 买卖股票的最佳时机含冷冻期
### 题目:
给定一个整数数组 `prices`，其中第 `prices[i]` 表示第 `_i_` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★ 
### 思路:
- **`dp[i][j]`表示第i天,状态为j时,所拥有的现金数.** 根据题目要求,定义3种状态:0,1,2.
```java
// dp[i][0]: 手上不持有股票，并且今天不是由于卖出股票而不持股，我们拥有的现金数
// dp[i][1]: 手上持有股票时，我们拥有的现金数
// dp[i][2]: 手上不持有股票，并且今天是由于卖出股票而不持股，我们拥有的现金数
```
### 代码:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        if (n==1) return 0;  
  
        int[][] dp = new int[n][3];  
        dp[0][0] = 0;  
        dp[0][1] = -prices[0];  
        dp[0][2] = 0;  
  
        for (int i = 1; i < n; i++) {  
            // 1)卖出; 2)继续不持股  
            dp[i][0] = Math.max(dp[i-1][2],dp[i-1][0]);  
            // 1)买入; 2)继续持股  
            dp[i][1] = Math.max(dp[i-1][0]-prices[i],dp[i-1][1]);  
            // 1)卖出;  
            dp[i][2] = dp[i-1][1]+prices[i];  
        }  
        return Math.max(dp[n-1][0],dp[n-1][2]);  
    }  
}
```

## 714. 买卖股票的最佳时机含手续费
### 题目:
给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
### 信息:
- **难度**: meidum
- **重要性:** #★★★☆☆
### 思路:
- 在每次买入时加入手续费即可,基本的动态规划思路不变!
### 代码:
```java hl:6,11,13
class Solution {  
    public int maxProfit(int[] prices, int fee) {  
        int n = prices.length;  
        int[][] dp = new int[n][2];  
  
        dp[0][1] = -prices[0] - fee; // 买入时加入手续费  
        dp[0][0] = 0;  
  
        for (int i = 1; i < n; i++) {  
            // 1)卖出 2)继续不持股  
            dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i-1][0]);  
            // 1)keep not holding 2)buy  
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);  
        }  
        return dp[n - 1][0];  
    }  
}  
```


# 子序列问题:
>**在解决字符串或数组匹配、对比的问题时，动态规划通常是一种有效的方法，尤其当问题涉及子序列、子数组或子串时**


## 300. 最长递增子序列
### 题目:
给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- `dp[i]`表示以`nums[i]`结尾的上升子序列的长度.
- **状态转移:** `dp[i]`可由`dp[j]+1`获得,其中有`nums[j]<nums[i]`.
### 代码:
```java
class Solution {  
    public int lengthOfLIS(int[] nums) {  
        int n = nums.length;  
        if (n == 1) return 1;  
        int[] dp = new int[n];  
        Arrays.fill(dp,1);  
        int ans = 0;  
        for (int i = 1; i < n; i++) {  
            for (int j = 0; j < i; j++) {  
                if (nums[j] < nums[i]) {  
                    dp[i] = Math.max(dp[j]+1,dp[i]);  
                }  
            }  
            ans = Math.max(ans,dp[i]);  
        }  
        return ans;  
    }  
}  
```
## 718. 最长重复子数组
### 题目:
给两个整数数组 `nums1` 和 `nums2` ，返回 _两个数组中 **公共的** 、长度最长的子数组的长度_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- `dp[i][j]`表示`nums1`中前`i`个元素和`nums2`的前`j`个元素中所能构成的最长公共子数组.
- `dp[i][0]`和`dp[0][j]`都初始化为0,代表长度为0,也便于后面的推导.
- **递推数组:** `dp[i][j] = dp[i-1][j-1] + 1` 
	- 由递推数组也可以看出`dp[i][0]`和`dp[0][j]`都应初始化为0.
### 代码:
```java
class Solution {  
    public int findLength(int[] nums1, int[] nums2) {  
        int n1 = nums1.length;  
        int n2 = nums2.length;  
        int[][] dp = new int[n1+1][n2+1];  
        int ans = 0;  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (nums1[i-1] == nums2[j-1]) {  
                    dp[i][j] = dp[i-1][j-1] + 1;  
                }  
                ans = Math.max(dp[i][j],ans);  
            }  
        }  
        return ans;  
    }  
}
```
## 1143. 最长公共子序列
### 题目
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #动态规划 
### 思路一：多维DP
- `dp[i][j]`表示`text1[0:i-1]`和`text2[0:j-1]`元素的最长公共子序列.
- **递推公式:** 
	- 当`text1[i-1]==text2[j-1]`时，则子序列长度+1 -> `dp[i][j] = dp[i-1][j-1]+1`;
	- 当`text1[i-1]!=text2[j-1]`时，取`dp[i-1][j]`和`dp[i][j-1]`的最大值.
	- ![[Pasted image 20241023092053.png|450]]
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();

        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i <= m; i++){
            for (int j = 1; j <= n; j++){
                if (text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[m][n];
    }
}
```
**时间复杂度：** $O(MN)$
**空间复杂度：** $O(MN)$
## 53. 最大子数组和
### 题目
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。
### 信息
- **难度：** medium
- **重要性：** #★★☆☆☆
- **标签：** #动态规划 #前缀和 #数组 
### 思路一：动态规划
- 两种可能性
	- 若`前i-1个最大和+nums[i]`可能小于0,此时需要从nums[i]重新开始计算;
	- 若`前i-1个最大和+nums[i]`比`前i-1个最大和`还要大,则继续累加
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        // 表示前n个元素的最大子数组和
        int[] dp = new int[n+1];
        dp[0] = 0;
        int ans = Integer.MIN_VALUE;
        // 递归公式：dp[i] = dp[i-1] + nums[i], dp[]
        for (int i = 1; i <= n; i++) {
            dp[i] = Math.max(dp[i-1]+nums[i-1],nums[i-1]);
            ans = Math.max(dp[i],ans);
        }
        return ans;
    }
}
```
### 思路二：前缀和
利用preSum和minPreSum来计算子数组，由于minPreSum的初始值为0且更新逻辑为`minPresum = Math.min(minPresum,preSum);`，因此不会出现`minPreSum>0`的情况！
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int preSum = 0;
        int minPresum = 0;
        int n = nums.length;
        int ans = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++){
            preSum += nums[i];
            ans = Math.max(ans,preSum - minPresum);
            minPresum = Math.min(minPresum,preSum);
        }
        return ans;
    }
}
```

## 392. 判断子序列
### 题目:
给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- indexS和indexT进行判断,indexT不断自增,而indexS只有在相等时才自增,最后若indexS到达了末尾,则返回true,否则返回false
### 代码:
```java
class Solution {  
    public boolean isSubsequence(String s, String t) {  
        int indexS = 0, indexT = 0;  
        int n1 = s.length(), n2 = t.length();  
  
        while (indexS < n1 && indexT < n2) {  
            if (s.charAt(indexS) == t.charAt(indexT)) {  
                indexS++;  
            }  
            indexT++;  
        }  
        return indexS == n1;  
    }  
}
```
### 同样的思路:(灵神代码)
- 定义索引i(相当于遍历s字符串),当存在`charAt(i)==c`,此时i++,最后若`i == s.length()`,则说明为子序列了,返回true.
```java
class Solution {  
    public boolean isSubsequence(String s, String t) {  
        if (s.isEmpty()) return true;  
  
        int i = 0;  
        for (char c : t.toCharArray()){  
            if (c == s.charAt(i) && (++i) == s.length()) return true;  
        }  
        return false;  
    }  
}
```

## ==115. 不同的子序列==
### 题目:
给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。

**示例 1：**
**输入：** s = "rabbbit", t = "rabbit"
输出：**`3`
**解释：**
如下所示, 有 3 种可以从 s 中得到 `"rabbit" 的方案`。
`rabbbit`
`rabbbit`
`rabbbit`
### 信息:
- **难度**: hard
- **重要性:** #★★★★☆
### 思路:
- 定义dp数组`dp[i][j]`:以`i-1为结尾的s子序列`中出现`以j-1为结尾的t`的个数.
- **初始化:** 
	- 当 `j = 0` 时，无论 `i` 的值如何，`dp[i][0]` 都应该为 `1`。因为空字符串是任何字符串的子序列。
	- 当 `i = 0` 且 `j > 0` 时，`dp[0][j]` 应为 `0`，因为没有字符的 `s` 不能形成非空的 `t`。
- **递推公式:** 
    - 如果 `s[i-1]` 和 `t[j-1]` 相等：有两种选择：
		1. **选择这个字符**：在 `s` 中包含这个字符，那么我们可以通过 `dp[i-1][j-1]` 来找到子序列。
		2. **不选择这个字符**：继续在 `s` 中寻找 `t[j-1]`，那么数量为 `dp[i-1][j]`。
        - 所以，状态转移方程为：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`
    - 如果 `s[i-1]` 和 `t[j-1]` 不相等：
        - 我们只能选择不包含 `s[i-1]`，因此：`dp[i][j] = dp[i-1][j]`

![[Pasted image 20241022142834.png|450]]
### 代码:
```java hl:11,13
public int numDistinct(String s, String t) {  
    int n1 = s.length();  
    int n2 = t.length();  
    int[][] dp = new int[n1 + 1][n2 + 1];  
    for (int i = 0; i <= n1; i++) {  
        dp[i][0] = 1;  
    }  
    for (int i = 1; i <= n1; i++) {  
        for (int j = 1; j <= n2; j++) {  
            if (s.charAt(i - 1) == t.charAt(j - 1))  
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];  
            else  
                dp[i][j] = dp[i - 1][j];  
        }  
    }  
    return dp[n1][n2];  
}
```
## 583. 两个字符串的删除操作
### 题目:
给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

**输入:** word1 = "sea", word2 = "eat"
**输出:** 2
**解释:** 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"

**示例 2:**

**输入：** word1 = "leetcode", word2 = "etco"
**输出：** 4
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 思路是找到word1和word2的最长公共子序列,然后返回`(n1-dp[i][j])+(n2-dp[i][j])`即可.
### 优化:
- 分析递推公式,仅与前一行状态有关,所以可采用滚动数组优化!
### 代码:
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[n1+1][n2+1];  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i][j] = dp[i-1][j-1]+ 1;  
                }else {  
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);  
                }  
            }  
        }  
        return n1 + n2 - 2 * dp[n1][n2];  
    }  
}

```
### **优化后代码:**

```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[2][n2+1];  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i%2][j] = dp[(i-1)%2][j-1]+ 1;  
                }else {  
                    dp[i%2][j] = Math.max(dp[(i-1)%2][j],dp[i%2][j-1]);  
                }  
            }  
        }  
        return n1 + n2 - 2 * dp[n1%2][n2];  
    }  
}
```


## ==72. 编辑距离== 
### 题目:
给你两个单词 `word1` 和 `word2`， _请返回将 `word1` 转换成 `word2` 所使用的最少操作数_ 。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- **dp数组定义:**
	- `dp[i][j]` 表示将`word1`的前`i`个字符转换为`word2`的前`j`个字符所需的最少操作数。
- **初始化:**
	- `dp[0][0] = 0`:将空字符串转换为空字符串不需要任何操作.
	- `dp[i][0] = i`:将`word1`的前`i`个字符转换为空字符串需要`i`次删除操作
	- `dp[0][j] = j`:将空字符串转换为 `word2` 的前 `j` 个字符需要 `j` 次插入操作。
- **递推公式:**
	- **字符相等时**:(`words1[i-1]==words2[j-1]`)
		- `dp[i][j] = dp[i-1][j-1]`，因为不需要额外的操作
	- **字符不相等时**:(`words1[i-1]!=words2[j-1]`)
		- **插入**：在`word1`的前`i`个字符中插入一个字符使其与 `word2` 的前 `j` 个字符匹配，操作数为 `dp[i][j-1] + 1`。
		- **删除**：在 `word1` 中删除一个字符，操作数为 `dp[i-1][j] + 1`。
		- **替换**：将 `word1[i-1]` 替换为 `word2[j-1]`，操作数为 `dp[i-1][j-1] + 1`。
### 代码:
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[n1+1][n2+1];  
        for (int i = 0; i <= n1; i++) {  
            // word2为空,则必为子序列.  
            dp[i][0] = i;  
        }  
        for (int i = 0; i <= n2; i++) {  
            // word2为空,则必为子序列.  
            dp[0][i] = i;  
        }  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i][j] = dp[i-1][j-1];  
                }else {  
                    dp[i][j] = Math.min(dp[i][j-1]+1,Math.min(dp[i-1][j-1]+1,dp[i-1][j]+1));  
                }  
            }  
        }  
        //System.out.println(dp[n1][n2]);  
        return dp[n1][n2];  
    }  
}
```

## 516. 最长回文子序列
### 题目:
给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- **dp数组定义:**
	- `dp[i][j]` 表示在字符串的子串`s[i]`到`s[j]`范围内的最长回文子序列的长度。
- **初始化:**
	- 当 `i == j` 时，表示只有一个字符的情况，因此 `dp[i][i] = 1`，是一个回文字符串.
- **递推公式:**
	- **相等情况**:(`s.charAt(left) == s.charAt(right)`)
		- 此时将相同的两个字符都加上
			- `dp[left][right]=dp[left+1][right−1]+2`
	- **不相等情况**:(`s.charAt(left) != s.charAt(right)`)
		- 字符不相等,所以同时加两个字符串,故比较"加左字符"和"加右字符"的较大值.
			- `dp[left][right]=max(dp[left+1][right],dp[left][right−1])`
- **遍历顺序:**
  - 注意下文的填充顺序,所以外层循环应该是`从n-2倒序遍历`;内层循环`从i+1开始正序遍历.`
  ![[Pasted image 20241023144055.png|450]]
### 代码:
```java hl:10-11
public int longestPalindromeSubseq(String s) {  
	int n = s.length();  
	if (n == 1) return n;  
	int[][] dp = new int[n][n];  

	for (int i = 0; i < n; i++) {  
		dp[i][i] = 1;  
	}  

	for (int left = n-2; left >= 0; left--) {  
		for (int right = left+1; right < n; right++) {  
			if (s.charAt(left) == s.charAt(right)) {  
				dp[left][right] = dp[left + 1][right - 1] + 2;  
			} else {  
				dp[left][right] = Math.max(dp[left + 1][right], dp[left][right - 1]);  
			}  
		}  
	}  
	return dp[0][n-1];  
}  
```

## ==[1547. 切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)==
### 题目:
有一根长度为 `n` 个单位的木棍，棍上从 `0` 到 `n` 标记了若干位置。例如，长度为 **6** 的棍子可以标记如下：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg)

给你一个整数数组 `cuts` ，其中 `cuts[i]` 表示你需要将棍子切开的位置。

你可以按顺序完成切割，也可以根据需要更改切割的顺序。

每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。

返回切棍子的 **最小总成本** 。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 区间dp问题，要计算整根棍子的切割成本。将木棍切割后，会产生两个更小的木棍，转换为同样的子问题，因此使用动态规划进行解答。为了便于解答，创建newCuts数组，将木棍的两个端点0与n也加入newCuts数组。
- **dp数组定义：**
	- dp\[i]\[j]表示端点为newCuts\[i]和newCuts\[j]的木棍的切割总成本。
- **dp数组初始化：**
	- dp\[0]\[0]=0，因为j-1<=i时，木棍达到最小长度，无需切割。
- **递推公式：** dp\[i]\[j]的切割成本为木棍长度+子木棍的最小切割成本，因此有：
	```java
	for (k = i + 1; k < j;k++){
		res = Math.min(res,dp[i][k]+dp[k][j]);
	}
	dp[i][j] = res + newCuts[j] - newCuts[i];
	```
	- 这里要遍历i到j之间所有可能的切割点，取最小值！
- **最终结果：** 返回结果为dp\[0]\[m+1]，表示端点为`newCuts\[0],newCuts\[m+1]`，也即端点`(0,n)`的木棍的切割总成本。
- **循环顺序：** 循环为`i=m-1;i >= 0;i--`,`j=i+2;j<=m+1;j++`.
	- 一方面是需要从小到大枚举，保证在计算dp\[i]\[j]时，dp\[i]\[k]已经计算出来；
	- 另一方面是i从m-1开始，而不是其他位置，如m等位置开始，是为了保证(i,j)之间包含可切断的端点。若i从m开始，则j从m+2开始，此时无意义；j从m+1开始，此时(m,m+1)区间并无切割点，也不行。所以最小区间为(m-1,m+1)，此时区间至少存在一个切割点。
### 代码:
```java
class Solution {
    public int minCost(int n, int[] cuts) {
        // dp[i][j]表示当前待切割木棍的左端点为cuts[i-1]，右端点为cuts[j+1]。
        // cuts数组长度
        int m = cuts.length;
        // 用于存储所有切割端点
        int[] newCuts = new int[m+2];
        Arrays.sort(cuts);
        // 木棍两端端点
        newCuts[0] = 0;
        newCuts[m+1] = n;
        // 切割点
        for (int i = 1; i < m+1; i++){
            newCuts[i] = cuts[i-1];
        }

        // dp[i][j]数组表示切割端点为i和j的木棍所需的最小成本,最终结果为dp[0][m+1];
        int[][] dp = new int[m+2][m+2];
        
        // 倒序遍历：
        for (int i = m-1; i >= 0; i--){
            for (int j = i+2; j <= m+1; j++ ){
                int res = Integer.MAX_VALUE;
                // System.out.printf("------dp[%d][%d]--------\n",i,j);
                for (int k = i + 1; k < j; k++){
                    res = Math.min(res,dp[i][k]+dp[k][j]);
                    // System.out.printf("res = Math.min(res,dp[%d][%d]+dp[%d][%d])\n",i,k,k,j);
                }
                dp[i][j] = res +  newCuts[j] - newCuts[i];
            }
        }
        return dp[0][m+1];

    }
}
```
## 688. 骑士在棋盘上的概率
### 题目：
在一个 `n x n` 的国际象棋棋盘上，一个骑士从单元格 `(row, column)` 开始，并尝试进行 `k` 次移动。行和列是 **从 0 开始** 的，所以左上单元格是 `(0,0)` ，右下单元格是 `(n - 1, n - 1)` 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 `k` 步或离开了棋盘。

返回 _骑士在棋盘停止移动后仍留在棋盘上的概率_ 。
### 信息：
- **难度**：medium
- **重要性：** #★★★★☆
### 思路一：
这题厘清题目所定义的概率很重要：


```java
class Solution {
    private int[][] DIRS = new int[][]{{-2,-1},{-1,-2},{-1,2},{-2,1},{1,-2},{2,-1},{2,1},{1,2}};
    
    public double knightProbability(int n, int k, int row, int column) {
        double[][][] memo = new double[n][n][k+1];
        return dfs(row,column,k,n,memo);
    }
    double dfs(int r, int c,int k,int n,double[][][] memo){
        // 越界
        if (r < 0 || r >= n || c < 0 || c >= n) {
            return 0;
        }
        // 在界内的情况。
        if (k == 0) {
            return 1;
        }
        if (memo[r][c][k] > 0){
            return memo[r][c][k];
        }
        double res = 0.0;
        for (int[] dir : DIRS){
            int x = r + dir[0];
            int y = c + dir[1];
            
            res += dfs(x,y,k-1,n,memo);
        }
        memo[r][c][k] = res / 8;
        return memo[r][c][k];
    }
}
```

# 其他分类
## 118. 杨辉三角
### 题目
给定一个非负整数 _`numRows`，_生成「杨辉三角」的前 _`numRows`_ 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
![[Pasted image 20241230144028.png]]
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #动态规划 
### 思路一：
根据`path[i][j] = path[i-1][j] + path[i-1][j-1]`可得结果。
**具体算法流程：**
2. 创建path集合和ans集合保存结果；
3. 由于第一行只有一个数，因此提前放入数组中；
4. 对于其他行数：先添加首1，中间的数遵循`path[i][j] = path[i-1][j] + path[i-1][j-1]`，尾部再添加尾1。
```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(List.of(1));
        // 构建n行杨辉三角
        for (int i = 1; i < numRows; i++){
            List<Integer> path = new ArrayList<>();
            path.add(1);
            for (int j = 1; j < i; j++){
                // 由上一行的第j个和第j-1个构建
                path.add(ans.get(i-1).get(j) + ans.get(i-1).get(j-1));
            }
            path.add(1);
            ans.add(path);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N^2)$
**空间复杂度：** $O(1)$，返回值不计入。

## 198. 打家劫舍
### 题目
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

	输入：[1,2,3,1]
	输出：4
	解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
	     偷窃到的最高金额 = 1 + 3 = 4 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #动态规划 
### 思路一：

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n+2];

        for (int i = 0; i < n; i++){
            dp[i+2] = Math.max(dp[i+1], nums[i]+dp[i]);
        }
        return dp[n+1];
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：
- **dp数组定义**：`dp[n]`表示前n个(`0~n-1`)房子的最高金额
- **递推公式**：不能偷相邻房屋，因此有`dp[i] = dp[i-1], dp[i-2] + nums[i-1]`
- **初始化**：根据递推公式，考虑`i=0`、`i=1`：
	- `dp[0]`：此时可以理解为无房屋，那么`dp[0] = 0`。
	- `dp[1]`：此时可以理解为只有`nums[0]`一间房屋，那么`dp[1] = nums[0]`
- **遍历顺序**：根据递推公式可知，`dp[i]`依赖于`dp[i-1]`与`dp[i-2]`，所以需要从左往右遍历，以保证在计算`dp[i]`时已经将子问题计算出来。
```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        
        int[] dp = new int[n+1];
        // k=0，此时没有房子
        dp[0] = 0;
        // k=1，此时只有nums[0]一个房子
        dp[1] = nums[0];
        for (int i = 2; i <= n; i++){
            // 前k个房子的最大和
            dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i-1]);
        }
        // k = n，表示前n个房子的最高金额
        return dp[n];
    }
}
```
### 思路三：空间优化
思考，`dp[i]`只与`dp[i-1]`和`dp[i-2]`有关，因此我们只需要保存前两个变量即可，无需将前`i-1`个变量都保存。
```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        int prev0 = 0;
        int prev1 = nums[0];
        int ans = 0;
        for (int i = 2; i <= n; i++){
            ans = Math.max(prev1,prev0 + nums[i-1]);
            prev0 = prev1;
            prev1 = ans;
        }
        // k = n，表示前n个房子的最高金额
        return ans;
    }
}
```
```java
public int rob(int[] nums) {
    int prev = 0;
    int curr = 0;

    // 每次循环，计算“偷到当前房子为止的最大金额”
    for (int i : nums) {
        // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]
        // dp[k] = max{ dp[k-1], dp[k-2] + i }
        int temp = Math.max(curr, prev + i);
        prev = curr;
        curr = temp;
        // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]
    }

    return curr;
}
```

## 32. 最长有效括号
### 题目
给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #动态规划 #栈 
### 思路一：动态规划
- **dp数组定义**：`dp[i]`表示以`s[i]`结尾的字符串的最长有效子串。
- **初始化**：`dp[0]=0`，此时还无法形成括号。
- **递推公式**：
	- 如果`s[i]=='('`，此时肯定无法形成有效子串，故此时`dp[i]=0`，可以忽略；
	- 如果`s[i]==')'`，此时又会有两种情况：
		- `s[i-1] == '('`，那么说明此时最长子串最小为2，还为`()()`这样的情况，此时为`dp[i] = dp[i-2] + 2`
		- `s[i-2] == ')'`，此时若`s[i-dp[i-1]-1] == '('`，则为`(())`这样的情况，此时为`dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]`

`()`,`(())`,`()()`,
注意这种情况：`(()())`
![[Pasted image 20250121155210.png]]
```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int ans = 0;
        for (int i = 1; i < s.length(); i++){
            if (s.charAt(i) == ')'){
                if (s.charAt(i-1) == '('){
                    if (i - 2 >= 0) dp[i] = dp[i-2] + 2;
                    else dp[i] = 2;
                }
                else if (i-dp[i-1]-1 >= 0 && s.charAt(i-dp[i-1]-1) == '('){
                    if (i - dp[i-1] - 2 >= 0){
                        dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2];
                    }else {
                        dp[i] = dp[i-1] + 2;
                    }
                }
                ans = Math.max(dp[i],ans);
            }
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int ans = 0;
        for (int i = 1; i < s.length(); i++){
            if (s.charAt(i) == ')'){
                if (s.charAt(i-1) == '('){
                    dp[i] = 2 + (i-2 >= 0 ? dp[i-2] : 0);
                }
                else if (i-dp[i-1]-1 >= 0 && s.charAt(i-dp[i-1]-1) == '('){
                    dp[i] = dp[i-1] + 2 + (i-dp[i-1]-2 >= 0 ? dp[i-dp[i-1]-2] : 0);
                }
                ans = Math.max(dp[i],ans);
            }
        }
        return ans;
    }
}
```


## 152. 乘积最大子数组

### 题目
给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #动态规划 
### 思路一：动态规划
- **dp数组定义**：`dpMax[i]`表示表示前i个数字中的最大子数组。`dpMin[i]`表示表示前i个数字中的最大子数组。
- **递推公式**：
```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        // dp[n]表示前n个元素中的最大子数组
        int[] fMax = new int[n];
        // 表示前n个元素的最小子数组
        int[] fMin = new int[n];
        fMax[0] = fMin[0] = nums[0];
        int ans = nums[0];
        for (int i = 1; i < n; i++){
            int x = nums[i];
            fMax[i] = Math.max(Math.max(fMax[i-1] * x, fMin[i-1] * x),x);
            fMin[i] = Math.min(Math.min(fMax[i-1] * x, fMin[i-1] * x),x);
            
            ans = Math.max(ans,fMax[i]);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
#### 空间优化
因为递归数组只会用到dp[i-1]前一个状态，因此可以使用单个变量代替DP数组实现递推。

并且由于对于`fMin`的更新会用到`fMax`，而fMax在fMin使用之前已经更新，因此需要tmp变量来暂存fMax的值。
```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        // dp[n]表示前n个元素中的最大子数组
        int fMax = nums[0];
        // 表示前n个元素的最小子数组
        int fMin = nums[0];
        int ans  = nums[0];
        for (int i = 1; i < n; i++){
            int x = nums[i];
            int tmp = fMax;
            fMax = Math.max(Math.max(fMax * x, fMin * x),x);
            fMin = Math.min(Math.min(tmp * x, fMin * x),x);
            
            ans = Math.max(ans,fMax);
        }
        return ans;

    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

### 思路二：维护当前最大最小值
有个很关键的点：当出现`num<0`时，由于num会使得大于小于号翻转，因此提前交换二者元素，使得max和min在乘小于0的num后仍能保持为max和min！因此，不断维护max值和min值并更新ans，当遍历结束后，就能获得最终结果。
```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = 1;
        int min = 1;
        int ans = Integer.MIN_VALUE;
        int n = nums.length;
        for (int num : nums){
            if (num < 0){
                int tmp = max;
                max = min;
                min = tmp;
            }
            max = Math.max(num * max, num);
            min = Math.min(num * min, num);
            ans = Math.max(max,ans);
        }    
        return ans;
    }

}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 2266. 统计打字方案数
### 题目
Alice 在给 Bob 用手机打字。

为了 **打出** 一个字母，Alice 需要 **按** 对应字母 `i` 次，`i` 是该字母在这个按键上所处的位置。

- 比方说，为了按出字母 `'s'` ，Alice 需要按 `'7'` 四次。类似的， Alice 需要按 `'5'` 两次得到字母  `'k'` 。
- 注意，数字 `'0'` 和 `'1'` 不映射到任何字母，所以 Alice **不** 使用它们。

但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 **按键的字符串信息** 。

- 比方说，Alice 发出的信息为 `"bob"` ，Bob 将收到字符串 `"2266622"` 。

给你一个字符串 `pressedKeys` ，表示 Bob 收到的字符串，请你返回 Alice **总共可能发出多少种文字信息** 。

由于答案可能很大，将它对 `109 + 7` **取余** 后返回。

	输入：pressedKeys = "22233"
	输出：8
	解释：
	Alice 可能发出的文字信息包括：
	"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae" 和 "ce" 。
	由于总共有 8 种可能的信息，所以我们返回 8 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #动态规划 #字符串 
### 思路一：线性DP
首先，假设为单一字母的字符串，那么求解其组合数，可以看作爬楼梯问题，即共i次按键，可由i-1个按键再按一次，i-2个按键再按两次，i-3个按键再按3次得来，即`dp0[i] = dp0[i-1] + dp0[i-2] + dp0[i-3]`.

因为数据范围已知，并且后续需要用到的`dp[i]`不定，因此可以提前预处理获取所有`dp[i]`。

最后遍历字符串，出现不等、或者遍历到最后一个时，计算当前子串的文字信息数。由于每个不同子串之间的方信息数独立，因此最终结果为他们的累乘。
```java
class Solution {
    private static final int MAX = 100001;
    private static final int MOD = 1_000_000_007;
    private static long[] dp0 = new long[MAX];
    private static long[] dp1 = new long[MAX];
    static {

        dp0[0] = dp1[0] = 1;
        dp0[1] = dp1[1] = 1;
        dp0[2] = dp1[2] = 2;
        dp0[3] = dp1[3] = 4;
        for (int i = 4; i < MAX; i++){
            dp0[i] = (dp0[i-1] + dp0[i-2] + dp0[i-3]) % MOD;
            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3] + dp1[i-4]) % MOD;
        }
    }
    public int countTexts(String pressedKeys) {
        long ans = 1;
        int cnt = 0;
        int n = pressedKeys.length();
        for (int i = 0; i < n; i++){
            char c = pressedKeys.charAt(i);
            cnt++;
            if (i == n-1 || c != pressedKeys.charAt(i+1)){
                ans = ans * (c == '7' || c == '9' ? dp1[cnt] : dp0[cnt]) % MOD;
                cnt = 0;
            }
        }
        return (int)ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
# 多维DP
## 62. 不同路径
### 题目
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆ 
- **标签：** #动态规划 
### 思路一：二维DP
- **dp数组定义**：`dp[i][j]`表示第i行第j列的格子的路径数。
- **初始化**：`dp[0][0] = 0`；
- **递推公式**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，代表可由上面的格子**向下**走一步和左边的格子**向右**走一步。
- **遍历顺序**：进行二维遍历，获取所有格子的路径`dp[i][j]`
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                dp[i][j] = (i-1>=0 ? dp[i-1][j] : 0) +  (j-1>=0 ? dp[i][j-1] : 0);
            }
        }
        return dp[m-1][n-1];
    }
}
```
**时间复杂度：** $O(N\times M)$
**空间复杂度：** $O(M\times N)$
### ⭐思路二：空间优化—滚动数组
之前一直不理解滚动数组优化，现在终于厘清思路。
![[Pasted image 20250110092253.png|300]]
根据上述示意图的递推可知，当前`dp[i][j]`仅上一行路径相关，和上上行路径无关。因此我们是可以在获取当前格子的路径时使用上一行格子的路径的：`dp[j] = dp[j] + dp[j-1]`，此处等式右边的的`dp[j]`就代表了使用的上一行的路径。

**那么`dp[j-1]`呢？**
- 这里就是我一直迷惑的点。要注意遍历顺序，我们逐行从左向右遍历的，因此在获取`dp[j]`时，`dp[j-1]`必然是已经被计算出来了的！据下图可以看出，在计算`dp[1][1]`时，上一行该列和同行左列的路径数都已经被计算出来。因此使用滚动数组优化：`dp[1] = dp[0] + dp[1]`是合理的，此时右侧的`dp[0]`代表同行左列，已被更新过；`dp[1]`代表上行同列，当前正在被更新，使用的是上一行的值。
- ![[Pasted image 20250110092849.png]]
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                dp[j] += (j-1>=0 ? dp[j-1] : 0);
            }
        }
        return dp[n-1];
    }
}
```
**时间复杂度：** $O(M\times N)$
**空间复杂度：** $O(N)$
## 63. 不同路径 II
>**时间**：2025-02-08 15:58:27
### 题目
给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 2 * 109。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #动态规划 
### 思路一：动态规划
- **dp数组定义**：`dp[i][j]`表示到达`grid[i][j]`的不同路径数量。
- **递推公式**：因为只能往右走和往下走，所以有`dp[i][j]=dp[i-1][j] + dp[i][j-1]`。
- **dp数组初始化**：`dp[0][0]=1`，初始位置路径数为1，否则之后的递推只会一直为0；先初始化第一行和第一列，若无障碍物，则路径数均为1，若有障碍物，则后面的路径数都为0，因为被障碍物阻挡，不可达。
- **递推顺序**：从`i=1`和`j=1`开始遍历：一方面是保证`i-1>0`和`j-1>0`；另一方面是第一行与第一列只能向右或向下走。
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // dp[i][j]表示到达grid[i][j]的路径数量
        int[][] dp = new int[m][n];
        // 递推：dp[i][j] = dp[i-1][j] + dp[i][j-1];
        
        for (int i = 0; i < m; i++){
            if (grid[i][0] == 1) break;
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++){
            if (grid[0][j] == 1) break;
            dp[0][j] = 1;
        }
        
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                if (grid[i][j] == 1){
                    dp[i][j] = 0;
                }else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```
**时间复杂度：** $O(M\times N)$
**空间复杂度：** $O(M \times N)$
## 64. 最小路径和
### 题目
给定一个包含非负整数的 `_m_ x _n_` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明**：每次只能向下或者向右移动一步。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #动态规划 
### 思路一：使用三目运算符判断
```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                    continue;
                }
                dp[i][j] = Math.min((i-1>=0?dp[i-1][j] : Integer.MAX_VALUE),(j-1>=0?dp[i][j-1]:Integer.MAX_VALUE)) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}

```
**时间复杂度：** $O(M\times N)$
**空间复杂度：** $O(M\times N)$

### 思路二：空间优化
为了统一嵌套循环中的遍历`dp[j] = Math.min(dp[j],dp[j-1]) + grid[i][j];`，我们需要额外处理第一行和第一列，因此在前面额外处理第一行和第一列。
```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[] dp = new int[n];
        dp[0] = grid[0][0];
        // 先处理第一行
        for (int j = 1; j < n; j++){
            dp[j] = dp[j-1] + grid[0][j];
        }
        for (int i = 1; i < m; i++){
	        // 处理第一列
            dp[0] += grid[i][0];
            for (int j = 1; j < n; j++){
                dp[j] = Math.min(dp[j],dp[j-1]) + grid[i][j];
            }
        }
        return dp[n-1];
    }
}
```
**时间复杂度：** $O(M\times N)$
**空间复杂度：** $O(N)$
## 5. 最长回文子串
### 题目
给你一个字符串 `s`，找到 `s` 中最长的 回文子串。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #双指针 #动态规划 
### 思路一：中心扩散法
遍历所有字符，获取以每个字符（或相邻两个字符）**作为中心进行扩散**所能获得的最长子串，并更新最终结果。
- 扩散时有两种情况：以单个字符`i`为中心；或者以相邻两个字符`i`和`i+1`为中心。分别对应"aba"和"abba"，奇数长度和偶数长度的情况。
```java
class Solution {
    public String longestPalindrome(String s) {
        int start = 0;
        int end = 0;
        
        for (int i = 0; i < s.length(); i++){
            // 计算以 i 为中心的回文串的左边界和右边界
            int[] res1 = expandToPalidrome(s, i, i);   // 单个字符为中心
            int[] res2 = expandToPalidrome(s, i, i + 1); // 相邻两个字符为中心

            // 选择较长的回文串
            int len1 = res1[1] - res1[0] + 1;
            int len2 = res2[1] - res2[0] + 1;
            
            int[] res = len1 > len2 ? res1 : res2;

            // 更新最长回文子串的起始和结束位置
            if ((res[1] - res[0]) > (end - start)) {
                start = res[0];
                end = res[1];
            }
        }
        return s.substring(start,end+1);
        
    }
    private int[] expandToPalidrome(String s, int l, int r){
        int n = s.length();
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)){
            l--;
            r++;
        }
        return new int[]{l+1,r-1};
    }
}

```
**时间复杂度：** $O(N^2)$
**空间复杂度：** $O(1)$

## 72. 编辑距离
### 题目
给你两个单词 `word1` 和 `word2`， _请返回将 `word1` 转换成 `word2` 所使用的最少操作数_  。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符


	输入：word1 = "horse", word2 = "ros"
	输出：3
	解释：
	horse -> rorse (将 'h' 替换为 'r')
	rorse -> rose (删除 'r')
	rose -> ros (删除 'e')

### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #动态规划 
### 思路一：
- **dp数组定义**：`dp[i][j]`表示word1中前i个字符变换到word2中前j个字符，需要操作的次数。
- **初始化**：`dp[i][0] = i`和`dp[0][j] = j`，代表`i->0`或者`j->0`需要删除`i/j`次；`dp[0][0] = 0`代表不需要额外操作。
- **递推公式**：有三种操作：增删改：【在操作`dp[i][j]`时，`dp[i-1][j]`、`dp[i][j-1]`和`dp[i-1][j-1]`都已相等。
	- `word1[i-1] != word2[j-1]`时，则可以通过增或者改来获得，即+1操作来获得。详见下图。
	- `word1[i-1] == word2[j-1]`时，则此时无需操作，因为两者都增加了一个相同的字符。
![[Pasted image 20250116095949.png|650]]
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        // dp[i][j]表示word1的前i个字符(0~i-1)，变换到word2的前j个字符(0~J-1)，需要操作的次数。
        int[][] dp = new int[m+1][n+1];

        // 初始化
        for (int i = 0; i <= m; i++){
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++){
            dp[0][j] = j;
        }
        // dp[0][0] = 0;

        for (int i = 1; i <= m; i++){
            for (int j = 1; j <= n; j++){
                if (word1.charAt(i-1) != word2.charAt(j-1)){
                    dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1]) + 1;
                }else {
                    dp[i][j] = dp[i-1][j-1];
                }
            }
        }

        return dp[m][n];
    }
    private int min(int m , int n, int l){
        return Math.min(Math.min(m,n),l);
    }
}

```
**时间复杂度：** 
**空间复杂度：** 