## 55. 合并区间
### 题目:
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 记录start和end区间,分几种情况讨论:
	1) end区间与下一个区间的左边界有重叠,则合并区间->即更新end为目前最远的右边界;
	2) end区间与下一个区间的左边界无重叠,则将区间加入到res结果中.并且要更新start和end为下一个区间的左右边界.
	3) 最后还需将最后的区间加入到res结果中.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int[][] merge(int[][] intervals) {  
        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);  
        // 存放当前最右区间  
        int start = intervals[0][0];  
        int end = intervals[0][1];  
        // 存放二维数组  
        List<int[]> res = new ArrayList<>();  
        // 存放区间  
        //List<Integer> temp = new LinkedList<>();  
  
        for (int i = 1; i < intervals.length; i++) {  
            // 没重叠, 则放入集合中  
            if (intervals[i][0] > end){  
                res.add(new int[]{start,end});  
                start = intervals[i][0];  
                end = intervals[i][1];  
            }else {  
                // 有重叠, 则合并  
                end = Math.max(intervals[i][1],end);  
            }  
        }  
        res.add(new int[]{start,end});  
  
        return res.toArray(new int[res.size()][]);  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 738. 单调递增的数字
### 题目: 
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 将int通过`String.valueOf().toCharArray()`转换为char数组,便于比较.
- 分为两种情况进行讨论: (从后向前遍历)
	1) 若`[i-1] <= [i]`,则满足条件,继续遍历;
	2) 若`[i-1] > [i]`, 则记录此时位置idx,并将`[i-1]--`.
- 遍历直到起始为止,持续更新idx,最后将idx及后面的数字全部更新为9.
### 关键点:
- 从后向前遍历是关键,这样才能反复利用更新后的`[i-1]`.
- 必须使用idx记录后统一更新,若遍历时更新,无法保证全是递增.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int monotoneIncreasingDigits(int n) {  
        if (n >= 0 && n <= 9) return n;  
        // 转换为char数组，便于操作  
        char[] c = String.valueOf(n).toCharArray();  
        // 记录开始变9的位置  
        int idx = c.length;  
        for (int i = c.length-1; i > 0; i--) {  
            if (c[i-1] > c[i]){  
                c[i-1]--;  
                idx = i;  
            }  
        }  
        for (int i = idx; i < c.length;i++){  
            c[i] = '9';  
        }  
        return Integer.parseInt(String.valueOf(c));  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 1705. 吃苹果的最大数目
### 题目
有一棵特殊的苹果树，一连 `n` 天，每天都可以长出若干个苹果。在第 `i` 天，树上会长出 `apples[i]` 个苹果，这些苹果将会在 `days[i]` 天后（也就是说，第 `i + days[i]` 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 `apples[i] == 0` 且 `days[i] == 0` 表示。

你打算每天 **最多** 吃一个苹果来保证营养均衡。注意，你可以在这 `n` 天之后继续吃苹果。

给你两个长度为 `n` 的整数数组 `days` 和 `apples` ，返回你可以吃掉的苹果的最大数目_。_
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #贪心 #数组 #堆（优先级队列） 
### 思路一：
利用优先级队列，实现淘汰即将腐烂的苹果。利用贪心思路，吃更早腐烂的苹果。

**具体算法流程：**
1. 使用优先级队列，记录第$i$天长出的苹果以及其腐烂时间，排序方法就依据腐烂时间；
2. 到达第i天后：
	1. 先将所有腐烂的苹果出队（此时已不能吃）；
	2. 入队第i天长出来的苹果；
	3. 开始吃1个苹果。若苹果被吃完，则出队；
3. 超过第i天后，就将队列持续出队，直到苹果已被吃完或腐烂。
```java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        int ans = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);
        for (int i = 0; i < apples.length || !pq.isEmpty(); i++){
            // 此时已腐烂，吃不了了，需要出队。（注意，可能多个苹果都这天腐烂，需要while）
            while (!pq.isEmpty() && pq.peek()[0] == i) {
                pq.poll();
            }
            
            // 添加长出来的苹果
            if (i < apples.length && apples[i] > 0)
                pq.offer(new int[]{i+days[i],apples[i]});

            if (!pq.isEmpty()){
                ans++;
                // 吃即将腐烂的苹果
                pq.peek()[1]--;
                // 离腐烂时间最近的苹果已被吃完
                if (pq.peek()[1]==0){
                    pq.poll();
                }
            }
        }
        return ans;
    }
}

```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$