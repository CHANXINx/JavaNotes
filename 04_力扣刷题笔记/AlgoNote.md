# 算法解题方法:
## 1. 双指针法:

- 也叫快慢指针法,**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**
### 定义快慢指针
- 快指针：寻找新数组的元素,新数组就是不含有目标元素的数组
- 慢指针：指向**更新新数组**下标的位置
### 细分分类:
#### 滑动窗口:
[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
- 参考本题.利用fast指针遍历到最远处,取得满足sum>val的长度的数组,再移动slow指针,逐步缩小"窗口",以取得最小窗口.
- 
## 2. 虚拟头结点:
- 虚拟头结点主要用于简化空指针时的边界条件处理,尤其是需要对头节点进行增删时!
	- 例如当`head==null`时,需要判断curr是否为空,才能使用边界条件`curr.next == null`进行判断.
	- 若使用`dummyHead`,则可统一写成`curr.next == null`进行边界条件的判断.因为在初始化时,不会出现`curr==null`的情况.

## 3. ACM模式

## 4. KMP算法:

## 5. 单调队列:

## 6. 递归法:
1. **确定递归函数的参数和返回值:** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数,并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。  
2. **确定终止条件:** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑:** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## 7. 01背包问题详解:

---
# 数据结构及其常见库函数

## 1. 二叉树:
### 平衡二叉树:
「平衡二叉树balanced binary tree」中**任意节点的左子树和右子树的高度之差的绝对值不**
**超过1.**

### 完全二叉树:
在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且**最下面一层的节点都集中在该层最左边的若干位置**。若最底层为第h层(h从1开始),则该层包含$1到2^{h-1}$个节点。
![[Pasted image 20240917233523.png]]
### 二叉搜索树:
- 若它的左子树不空，则**左子树上所有结点的值均小于它的根结点的值**；
- 若它的右子树不空，则**右子树上所有结点的值均大于它的根结点的值**；
- 它的左、右子树也分别为二叉排序树
![[Pasted image 20240917233621.png]]
### 平衡二叉搜索树:
AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的**左右两个子树的高度差的绝对值不超过1**，并且**左右两个子树都是一棵平衡二叉树**。

### 二叉树存储方式:
**二叉树可以链式存储，也可以顺序存储。**

**链式存储:**
![[Pasted image 20240917234336.png|500]]
**数组存储:**
![[Pasted image 20240917234523.png|500]]
### 二叉树的遍历方式:
二叉树主要有两种遍历方式：
1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**深度优先遍历**
- 前序遍历（递归法，迭代法）
- 中序遍历（递归法，迭代法）
- 后序遍历（递归法，迭代法）
**广度优先遍历**
- 层次遍历（迭代法）

### 二叉树的定义:
```java
public class TreeNode(){
	TreeNode left;
	TreeNode right;
	int val;
	TreeNode() {}
	TreeNode(int val) { this.val = val; } 
	TreeNode(int val, TreeNode left, TreeNode right){
		 this.val = val;
		 this.left = left;
		 this.right = right;
	}
	 
 }
```


## String常用库函数
