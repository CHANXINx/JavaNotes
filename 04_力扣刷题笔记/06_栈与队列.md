## 232. 用栈实现队列
### 题目
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：
- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**
- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #队列 #栈 
### 思路一：两个栈
因为队列是先进后出，所以无法单个栈无法构成循环，故必须使用两个栈。用第二个栈来暂存元素，获取所需结果后再将辅助栈中的元素放入主栈。
```java
class MyQueue {
    Deque<Integer> sta1;
    Deque<Integer> sta2;
    int size;

    public MyQueue() {
        sta1 = new ArrayDeque<>();
        sta2 = new ArrayDeque<>();
        size = 0;
    }
    
    public void push(int x) {
        sta1.push(x);
        size++;
    }
    
    public int pop() {
        for (int i = 0; i < size-1; i++){
            sta2.push(sta1.pop());
        }
        int ans = sta1.pop();

        change();

        size--;
        return ans;
    }
    
    public int peek() {
        for (int i = 0; i < size-1; i++){
            sta2.push(sta1.pop());              
        }

        int ans = sta1.pop();
        sta1.push(ans);
        
        change();

        return ans;
    }
    
    public boolean empty() {
        return sta1.isEmpty();
    }

    private void change(){
        while (!sta2.isEmpty()){
            sta1.push(sta2.pop());
        }
    }
}
```

```java
class MyQueue {
    Deque<Integer> sta1;  // 用于入队操作
    Deque<Integer> sta2;  // 用于出队操作

    public MyQueue() {
        sta1 = new ArrayDeque<>();
        sta2 = new ArrayDeque<>();
    }
    
    // 入队操作，直接将元素压入 sta1
    public void push(int x) {
        sta1.push(x);
    }
    
    // 出队操作，检查 sta2 是否为空，如果为空，则将 sta1 中的元素全部转移到 sta2
    public int pop() {
        moveToSta2();  // 转移元素到 sta2
        return sta2.pop();  // 从 sta2 弹出栈顶元素
    }
    
    // 获取队列头部元素
    public int peek() {
        moveToSta2();  // 转移元素到 sta2
        return sta2.peek();  // 返回 sta2 栈顶元素
    }
    
    // 检查队列是否为空
    public boolean empty() {
        return sta1.isEmpty() && sta2.isEmpty();
    }

    // 将 sta1 中的元素转移到 sta2 中
    private void moveToSta2() {
        if (sta2.isEmpty()) {  // 只有在 sta2 为空时才进行转移
            while (!sta1.isEmpty()) {
                sta2.push(sta1.pop());
            }
        }
    }
}

```
### 思路二：均摊时间复杂度
使用$in$栈进行入队，$out$栈进行出队操作。

注意，只有当out栈为空时，才往里面入队，否则可能会队列顺序。
![[Pasted image 20241207224853.png|450]]
```java
class MyQueue {
    Deque<Integer> in;
    Deque<Integer> out;
    public MyQueue() {
        in = new ArrayDeque<>();
        out = new ArrayDeque<>();
    }
    
    public void push(int x) {
        in.push(x);
    }
    
    public int pop() {
        in2out();
        return out.pop();
    }
    
    public int peek() {
        in2out();
        return out.peek();
    }
    
    public boolean empty() {
        return in.isEmpty() && out.isEmpty();        
    }

    private void in2out(){
        if (out.isEmpty()){
            while (!in.isEmpty()){
                out.push(in.pop());
            }
        }
    }
}
```
## 225. 用队列实现栈
### 题目
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
实现 `MyStack` 类：
- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
**注意：**
- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #栈 #队列
### 思路一：两个队列
使用标志位$change$切换操作的队列：
```java
class MyStack {
    Deque<Integer> deque1;
    Deque<Integer> deque2;
    int size;
    boolean change;

    public MyStack() {
        deque1 = new ArrayDeque<>();
        deque2 = new ArrayDeque<>();
        size = 0;
        change = false;
    }
    
    public void push(int x) {
        if (!change){
            deque1.add(x);
        }else {
            deque2.add(x);
        }
        size++;
    }
    
    public int pop() {
        int ans = 0;
        if (!change){
            for (int i = 0; i < size-1; i++){
                deque2.add(deque1.poll());
            }
            ans = deque1.poll(); 
        }else{
            for (int i = 0; i < size-1; i++){
                deque1.add(deque2.poll());
            }
            ans = deque2.poll(); 
        }
        
        change = !change;
        size--;
        return ans;
    }
    
    public int top() {
        int ans;
        if (!change){
            for (int i = 0; i < size-1; i++){
                deque2.add(deque1.poll());
            }
            ans = deque1.poll(); 
            deque2.add(ans);
        }else{
            for (int i = 0; i < size-1; i++){
                deque1.add(deque2.poll());
            }
            ans = deque2.poll(); 
            deque1.add(ans);
        }
        
        change = !change;        
        return ans;
    }
    
    public boolean empty() {
        return change ? deque2.isEmpty() : deque1.isEmpty();
    }
}
```

使用中间变量$tmp$队列交换操作的队列：
```java
class MyStack {
    Deque<Integer> deque1;
    Deque<Integer> deque2;
    int size;
    boolean change;

    public MyStack() {
        deque1 = new ArrayDeque<>();
        deque2 = new ArrayDeque<>();
        size = 0;
    }
    
    public void push(int x) {
        deque1.add(x);
        size++;
    }
    
    public int pop() {
        int ans = 0;
        for (int i = 0; i < size-1; i++){
            deque2.add(deque1.poll());
        }
        ans = deque1.poll(); 
        
        size--;

        deque1 = deque2;
        deque2 = new ArrayDeque<>();
        
        return ans;
    }
    
    public int top() {
        int ans;

        for (int i = 0; i < size-1; i++){
            deque2.add(deque1.poll());
        }
        ans = deque1.poll(); 
        deque2.add(ans);
        deque1 = deque2;
        deque2 = new ArrayDeque<>();
        return ans;
    }
    
    public boolean empty() {
        return deque1.isEmpty();
    }
}
```

```java
class MyStack {  
//    使用Queue实现,不使用末尾弹出.  
    Queue<Integer> queue1;  
  
    public MyStack() {  
        queue1 = new LinkedList<>();  
    }  
  
    public void push(int x) {  
        queue1.add(x);  
    }  
  
    public int pop() {  
        if (!empty()) {  
            int size = queue1.size();  
            while (size > 1) {  
                size--;  
                queue1.add(queue1.poll());  
            }  
            return queue1.poll();  
        }  
        return -1;  
    }  
  
    public int top() {  
        int res = pop();  
        push(res);  
        return res;  
    }  
  
    public boolean empty() {  
        return queue1.isEmpty();  
    }  
}

```

### 思路二：一个队列
当作循环队列，出队的同时同时入队，既能保证相对顺序不变，同时还能获取队尾元素。
```java
class MyStack {
    Deque<Integer> deque;
    int size;
    public MyStack() {
        deque = new ArrayDeque<>();
        size = 0;
    }
    
    public void push(int x) {
        deque.add(x);
        size++;
    }
    
    public int pop() {
        for (int i = 0; i < size-1; i++){
            deque.add(deque.poll());
        }
        size--;
        return deque.poll();
    }
    
    public int top() {
        for (int i = 0; i < size-1; i++){
            deque.add(deque.poll());
        }
        int ans = deque.poll();
        deque.add(ans);
        return ans;
    }
    
    public boolean empty() {
        return deque.isEmpty(); 
    }
}
```
## 20. 有效的括号
### 题目
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。
### 信息
- **难度：**:easy
- **重要性：** #★★★★☆
- **标签：** #字符串 #栈
### 思路一：
属于“**邻项相消**”问题，使用栈解决。通过栈的先入后出特性，来保证“**以正确的顺序**”闭合。

**具体算法流程：**
1. 遇到左括号，则对应入栈右括号；
2. 遇到右括号，则对应推出栈顶元素：
	- 若相等，则说明左括号以正确的顺序闭合；
	- 若不相等或栈为空，说明闭合顺序错误或右括号多于左括号
3. 遍历结束，若栈为空，说明一一匹配；若栈不为空，说明左括号更多，均返回false。

>[!双端队列中栈与队列方法分类]-
>注意区分栈的方法和队列的方法，若要使用栈的特性，就使用栈的方法，勿与队列方法混用，否则可能出现错误。![[Pasted image 20241207181426.png]]

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> sta = new ArrayDeque<>();
        if (s.length() % 2 != 0) return false;

        for (char c : s.toCharArray()){
            if (c == '(') {
                sta.push(')'); // 入栈对应的右括号
            } else if (c == '[') {
                sta.push(']');
            } else if (c == '{') {
                sta.push('}');
            }else {
                if (sta.isEmpty() || sta.pop() != c){
                    return false;
                }
            }
        }
        return sta.isEmpty();
    }
}
```
## 1047. 删除字符串中的所有相邻重复项
### 题目
给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
### 信息:
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #字符串 #栈 
### 思路一：
邻项相消问题，使用栈来处理。并且由于需要返回字符串，所以可以利用StringBuilder来模拟栈。
```java
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()){
            if (sb.length() != 0 && sb.charAt(sb.length()-1) == c){
                sb.deleteCharAt(sb.length()-1);
            }else sb.append(c);
        }
        return sb.toString();
    }
}
```
**时间复杂度：**$O(N)$
**空间复杂度：**$O(N)$
## 150. 逆波兰表达式求值
### 题目
给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
**注意：**
- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。
### 信息
- **难度：** Medium
- **重要性：** #★★★☆☆
- **标签：** #栈 
### 思路一：栈模拟
逆波兰表达式，使用栈模拟进行模拟。
```java
class Solution {  
    public int evalRPN(String[] tokens) {  
        Deque<Integer> stack = new LinkedList<>();  
        for (String s : tokens){  
	        // 判断当前字符数s是+,-,或/.
            if ("+-*/".contains(s)){  
                int a = stack.pop();  
                int b = stack.pop();  
                switch (s) {  
                // 弹出后两个计算,并再次入栈.
                    case "+" -> stack.push(b+a);  
                    case "-" -> stack.push(b-a);  
                    case "*" -> stack.push(b*a);  
                    case "/" -> stack.push(b/a);  
                }  
            }else  
	            // Integer.valueOf将字符串转换为Integer型.
                stack.push(Integer.valueOf(s));  
        }  
        return stack.pop();  
    }  
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 239. 滑动窗口最大值
### 题目:
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值.
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 这题是单调队列的题目!获得窗口内的最值.
- 单调队列,用于获取队列/窗口内的最值,所以队顶必须为当前窗口内的最值.作为处理这类题目的特殊的队列,**与常规队列不同,无需维护窗口内的所有元素,只需要维护窗口内的最值即可**!
### 关键点:
- 单调队列的构造,无需维护窗口内所有元素.
### 代码:
```java
class Solution {  
    public int[] maxSlidingWindow(int[] nums, int k) {  
        MyQueue queue = new MyQueue();  
        int n = nums.length;  
        int[] res = new int[n-k+1];  
        if (n == 1 || k == 1) return nums;  
		// 先入队k-1个.
        for (int i = 0;i < k-1; i++){  
            queue.push(nums[i]);  
        }  
        // 入队,获得当前窗口最大值,出队.
        for (int i = 0; i <= (n-k);i++){  
            queue.push(nums[i+k-1]);  
            res[i] = queue.max();  
            queue.pop(nums[i]);  
        }  
        return res;  
    }  
}  
  
class MyQueue{  
	// 频繁增删,用LinkedList.
    Deque<Integer> que = new LinkedList<>();  
	// 为空则入队;或队底的元素小于当前元素,则弹出小的,推入大的.
    public void push(int n){  
        while (!que.isEmpty() && que.peekLast() < n){  
            que.pollLast();  
        }  
        que.add(n);  
    }  
	// 队顶始终为最大值,故返回peek()即可.
    public int max(){  
        return que.peek();  
    }  
	// 若移出窗口的元素在队顶,则移出.
    public void pop(int n){  
        if (!que.isEmpty() && n == que.peek()) que.poll();  
    }  
}
```

## 347. 前 K 个高频元素

### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #队列 #哈希表 #数组 
### 思路一：哈希表+优先级队列
存储元素出现次数，首先想到就是哈希表。哈希表实现方式：$cnt[]$数组或$HashMap$集合。在本例中，由于数字范围是$1\sim10^5$，所以使用$HashMap$。

那么如何获取前$k$个高频元素呢？若是获取**最**高频，那么就直接遍历即可。而对于不定长的前$k$个高频元素，采用优先级队列进行获取。

**具体算法流程：**
1. 遍历第一次，保存元素出现次数；
2. 遍历第二次，保存所有$KEY$到优先级队列中，根据$VALUE$进行比较；
3. 构建$ans$数组，保存优先级队列中的前$k$个元素。

>[!优先级队列根据VALUE进行排序的方式]-
>`(a,b) -> map.get(b) - map.get(a)`：大根堆
```java hl:7
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        PriorityQueue<Integer> que = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));

        for (int num : map.keySet()){
            que.add(num);
        }

        int[] ans = new int[k];
        for (int i = 0; i < k; i++){
            ans[i] = que.poll();
        }
        return ans;
    }
}
```

## 2931. 购买物品的最大开销
### 题目
给你一个下标从 **0** 开始大小为 `m * n` 的整数矩阵 `values` ，表示 `m` 个不同商店里 `m * n` 件不同的物品。每个商店有 `n` 件物品，第 `i` 个商店的第 `j` 件物品的价值为 `values[i][j]` 。除此以外，第 `i` 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 `0 <= j < n - 1` 都有 `values[i][j] >= values[i][j + 1]` 。

每一天，你可以在一个商店里购买一件物品。具体来说，在第 `d` 天，你可以：

- 选择商店 `i` 。
- 购买数组中最右边的物品 `j` ，开销为 `values[i][j] * d` 。换句话说，选择该商店中还没购买过的物品中最大的下标 `j` ，并且花费 `values[i][j] * d` 去购买。

**注意**，所有物品都视为不同的物品。比方说如果你已经从商店 `1` 购买了物品 `0` ，你还可以在别的商店里购买其他商店的物品 `0` 。

请你返回购买所有 `m * n` 件物品需要的 **最大开销** 。

**示例 1：**

	**输入：**values = [[8,5,2],[6,4,1],[9,7,3]]
	**输出：**285
	**解释：**第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 = 1 。
	第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 = 4 。
	第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 = 9 。
	第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 = 16 。
	第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 = 25 。
	第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 = 36 。
	第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 = 49 。
	第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 = 64 。
	第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 = 81 。
	所以总开销为 285 。
	285 是购买所有 m * n 件物品的最大总开销。
### 信息
- **难度：** hard
- **重要性：** #★★★☆☆
- **标签：** #堆（优先级队列） #贪心 #数组 
### 思路一：数组排序
随天数增多，购买物品的价值也随之增大，据此就能满足题意。因此，可以使用`System.arraycopy()`将values中的数组复制到新数组中，再进行排序。最后再遍历新数组获取结果即可。
```java
class Solution {
    public long maxSpending(int[][] values) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        int m = values.length;
        int n = values[0].length;
        int[] arr = new int[m*n];
        for (int i = 0; i < m; i++){
            System.arraycopy(values[i],0,arr,i*n,n);
        }
        Arrays.sort(arr);
        long ans = 0l;
        for (int i = 0; i < arr.length; i++){
            ans += (i+1) * (long) arr[i];
        }
        return ans;
    }
}

```
**时间复杂度：** $O(MNlogMN)$
**空间复杂度：** $O(MN)$