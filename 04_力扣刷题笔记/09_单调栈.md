>**利用栈来维护一个单调性序列.**
## 适用范围:
**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置.**

## 基本思路
1. **单调性**：
    - **单调递增栈**：栈中元素是递增的，每次入栈时，如果当前元素小于栈顶元素，则将栈顶元素弹出，直到栈为空或当前元素大于等于栈顶元素。
    - **单调递减栈**：栈中元素是递减的，每次入栈时，如果当前元素大于栈顶元素，则将栈顶元素弹出，直到栈为空或当前元素小于等于栈顶元素。
2. **维护栈的性质**：
    - 每次处理一个新元素时，通过弹出栈顶元素来维护栈的单调性。
    - 这样可以==**确保栈中始终保持有效的候选元素**==，以便快速找到符合条件的最小值或最大值。
3. **处理逻辑**：
    - 对于每个元素，使用栈存储之前的元素，并在需要时利用栈来快速查找与当前元素相关的值。
    - 可以利用栈中的元素来计算结果，例如计算与当前元素有关的范围、数量或其他统计信息。
## 常见遍历方法:
单调递增栈:
```java
    for (int i = 0; i < n; i++) {  
        int x = heights[i];  
        while (!st.isEmpty() && x <= heights[st.peek()]){  
            st.pop();  
        }  
        ...
        st.push(i);  
    } 
```

## 42. 接雨水
### 题目:
给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。![[Pasted image 20241026105028.png]]
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- **单调栈解法:** 将高度入栈,若遇到低的,则弹出,计算高度差之间的雨水体积。
![[Pasted image 20241026105809.png]]
![[Pasted image 20241026114430.png]]
### 代码:
```java
public int trap(int[] height) {  
    Deque<Integer> st = new ArrayDeque<>();  
    int n = height.length;  
    int ans = 0;  
    for (int i = 0; i < n; i++) {  
        while (!st.isEmpty() && height[i] >= height[st.peek()]){  
            int bottomH = height[st.pop()];  
            if (st.isEmpty()){  
                break;  
            }  
            int left = st.peek();  
            // 高  
            int dh = Math.min(height[left],height[i]) - bottomH;  
            ans += dh * (i-left-1);  
        }  
        st.push(i);  
    }  
    return ans;  
}
```

## 84. 柱状图中的最大矩形 
### 题目
给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #数组 #单调栈 
### 思路一：单调栈
将元素入栈，若遇到比栈顶小的元素，就计算以当前栈顶元素为高的矩形面积。并且因为出栈后，此时即将入栈的元素可能仍比栈顶小，所以需要使用while循环，直至栈顶元素小于即将入栈的元素。

$下标为i的矩形面积计算 = heights[i] \times (右边第一个低于i的矩形 - 左边第一个小于i的矩形 - 1)$ 
![[Pasted image 20241228152539.png|500]]
```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] hei = new int[heights.length+2];
        System.arraycopy(heights,0,hei,1,heights.length);

        Deque<Integer> sta = new ArrayDeque<>();
        int ans = 0;
        for (int i = 0; i < hei.length; i++){
            while (!sta.isEmpty() && hei[sta.peek()] > hei[i]){
                int h = hei[sta.pop()];
                // 此时栈中的元素都应该比原栈顶要低，因此此时栈顶就是左边第一个比h低的矩形
                ans = Math.max(ans, h * (i - sta.peek()-1));
            }
            sta.push(i);
        }
        return ans;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 739. 每日温度
### 题目
给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆  
- **标签：** #栈 #数组 #单调栈
### 思路一：单调栈
思路见代码。
```java
class Solution {
    public int[] dailyTemperatures(int[] temp) {
        int n = temp.length;
        Deque<Integer> sta = new ArrayDeque<>();
        int[] ans = new int[n];
        for (int i = n-1; i >= 0; i--){
            // 即将入栈的元素更高，那么此时栈中小的元素都不会成为更高温度了。
            while (!sta.isEmpty() && temp[sta.peek()] <= temp[i]){
                sta.pop();
            }
            // 栈为空，或者此时栈中更小
            if (!sta.isEmpty() && temp[sta.peek()] > temp[i]){
                ans[i] = sta.peek() - i;
            }
            sta.push(i);
        }
        return ans;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$