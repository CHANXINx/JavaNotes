# ==数组==
## 704. 二分查找
### 信息:
- **难度**:easy
- **重要性:** #★☆☆☆☆ 
### 思路: 
- **定义`head`和`end`节点**, 即二分中的头和尾. **将`index`定义为`(head+end/2)`;
- 此时即判断`nums[index]`与`target`的关系, 若小于`target`, 则说明在二分中的右半部分, 此时将head置为`index+1`. 此时继续在右半部分重复上述判断, 直到找到`target`退出循环或数组中没有等于`target`的值而退出.
### 代码:
```
class Solution {  
    public int search(int[] nums, int target) {  
        int head = 0;  
        int end = nums.length - 1;  
        while (head <= end){  
            int index = (head + end) / 2;  
            if (nums[index] == target)  
                return index;  
            if (nums[index] < target){  
                head = index + 1;  
            }else if (nums[index] > target)  
                end = index - 1;  
        }  
        return -1;  
    }  
}
```
## 27. 移除元素
### 信息:
- **难度**:easy
- **重要性:** #★★★☆☆ 
### 思路:
- 因为是原地移除, 所以双指针方法进行解答: 一个快指针,一个慢指针.**快指针用来遍历数组中的所有元素, 慢指针用来存放数组中不等于target的元素(即需要存放的元素).** 用双指针进行求解,能在原数组上进行变化,而无需多定义新数组.
### 关键点:
- 原地移除,所以不能定义新数组,要在原数组上保存,故用双指针很合适.
### 代码:
```
class Solution {  
    public int removeElement(int[] nums, int val) {  
        int slow = 0;  
        int fast = 0;  
        while (fast < nums.length){  
            if (nums[fast] != val){  
                nums[slow] = nums[fast];  
                slow++;  
            }  
            fast++;  
        }  
        return slow;  
    }  
}
```
## 26. 删除有序数组中的重复项
### 信息:
- **难度**:easy
- **重要性:** #★★★★☆
### 思路:
- 非严格递增数组,原地删除. 这里要注意: 非严格递增数组中的重复项一定是连续出现的!并且原地删除, 所以不能定义新数组.综上,定义快慢指针,当出现重复元素时,去除重复项,即`nums[slow++] = nums[fast]` .
### 关键点:
- 去除重复元素,指的是仅保留单个,而不是全部去除,所以这里应该是`nums[++slow] = nums[fast];`→ 先自增,再赋值!
### 代码:
```
class Solution {  
    public int removeDuplicates(int[] nums) {  
        int slow = 0;  
        int fast = 1;  
        while (fast < nums.length) {  
            if (nums[slow] != nums[fast]) {  
                nums[++slow] = nums[fast];  
            }  
            fast++;  
        }  
        return slow + 1;  
    }  
}
```

## 283. 移动零
### 题目:
- 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意, 必须在不复制数组的情况下原地对数组进行操作。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 注意,原地操作,故不能定义新数组.定义快慢指针,当出现非0元素时,则赋值给慢指针处. 最后多定义一个循环,将`slow+1-nums.leng-1`索引处的所有元素都赋0!
### 关键点:
- 较简单,略.
### 代码:
```
class Solution {  
    public void moveZeroes(int[] nums) {  
        int slow = 0,fast = 0;  
  
        while (fast < nums.length){  
            if (nums[fast] != 0){  
                nums[slow] = nums[fast];  
                slow++;  
            }  
            fast++;  
        }  
        for (int i = slow;i < nums.length;i++)  
            nums[i] = 0;  
    }  
}
```
## 844. 比较含退格的字符串
### 题目:
- 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。注意：如果对空文本输入退格字符，文本继续为空。
### 信息:
- **难度**: easy
- **重要性:** #★★★★★
### 思路:
- 难度较高.这题的重点在于利用`skipS`和`skipT`存放`#`的个数!然后利用指针从右往左遍历字符串:当出现`#`,则`skip++`并且指针左移;当出现非`#`,且`skip==0`,则将当前字符存放到新数组中;当出现非`#`,且`skip>0`,则指针左移.
- 这里对于我的思路,有个优化的方法,即不需要使用新数组进行额外的存放,而是在遍历每个元素时同时进行判断,这样节省了空间! 同时,利用charAt(index)来获取字符串的索引元素,而不是利用`toCharArray()`
### 关键点:
- 利用`skip`变量存放`#`的个数.
- 各种情况的判断!!!这是我觉得复杂的点.
- 避免使用`i = i - (skipS); skipS = 0;`!这样会导致在出现`a#j##`这种字符串的时候出错,因为会有一个#被忽略!
### 代码:
```
class Solution {  
    public boolean backspaceCompare(String s, String t) {  
  
        int i = s.length() - 1;  
        int j = t.length() - 1;  
        int skipS = 0, skipT = 0;  
        while (i >= 0 || j >= 0){  
            while (i >= 0) {  
                if (s.charAt(i) == '#'){  
                    i--;  
                    skipS++;  
                }else if (s.charAt(i) != '#' && skipS != 0){  
                    skipS--;  
                    i--;  
                }else {  
                    break;  
                }  
            }  
            while (j >= 0) {  
                if (t.charAt(j) == '#'){  
                    j--;  
                    skipT++;  
                }else if (t.charAt(j) != '#' && skipT != 0){  
                    skipT--;  
                    j--;  
                }else{  
                    break;  
                }  
            }  
            // Ensure both indices are valid before comparison  
            if (i >= 0 && j >= 0 && s.charAt(i) != t.charAt(j)) {  
                return false;  
            }  
  
            // If only one string is exhausted, they are not equal  
            if ((i >= 0) != (j >= 0)) {  
                return false;  
            }  
            i--;  
            j--;  
        }  
        return true;  
    }
}
```
## 977. 有序数组的平方
### 题目:
- 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
### 信息:
- **难度**:easy
- **重要性:** #★★★★☆
### 思路:
- 直接使用暴力解法,固然可行,但是时间复杂度较高,无法通过力扣测试!
- 给定的是非递减数组,即已经排好序,但是小于0的数字平方后数值较大,所以利用双指针进行判断,同时**定义新数组`res[key]`存放平方后的排序**:左指针指向head,右指针指向end, 比较`nums[head]`和`nums[end]`的平方后的大小,谁大谁存到数组里,并且移动key与head/end的指针!当`head>end`时,停止判断.
### 关键点:
- 利用左右指针比较平方后的元素大小,并存放到新数组里,更新指针.
### 代码:
```
class Solution {  
    public int[] sortedSquares(int[] nums) {  
//      1. 双指针.  
        int[] res = new int[nums.length];  
        int key = nums.length - 1;  
        for (int i = 0, j = nums.length - 1; i <= j;) {  
            if ((nums[i] * nums[i]) < (nums[j] * nums[j])){  
                res[key] = nums[j] * nums[j];  
                j--;  
            }else {  
                res[key] = nums[i] * nums[i];  
                i++;  
            }  
            key--;  
        }  
        return res;  
    }
}
```


## 977.有序数组的平方
### 题目:
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
### 信息:
- **难度**:easy
- **重要性:** #★★★☆☆
### 思路:
#### 思路一:
- 直接暴力解法,将数组元素平方后使用Arrays.sort()方法.
#### 思路二:
- 数组为非递减顺序,即平方后的最大值一定在最左侧或最右侧!所以可以定义双指针i和j,判断两端元素平方后的大小,将较大的放在结果数组`res[nums.length]`中,同时存放到res数组后,需要移动key,保证将结果存放到res数组的空位.如此循环,直到指针i和j相遇.
### 关键点:
- 观察到数组为非递减序列,所以平方后的最大值一定在两侧,数组大小会呈现凹型(有负值时).
### 代码:
```java
class Solution {  
    public int[] sortedSquares(int[] nums) {  
//      1. 双指针.  
        int[] res = new int[nums.length];
        // 用于控制res数组的存放.  
        int key = nums.length - 1;  
        for (int i = 0, j = nums.length - 1; i <= j;) {  
        // 判断平方后较大的,存放到res中,并移动指针key和i/j.
            if ((nums[i] * nums[i]) < (nums[j] * nums[j])){  
                res[key] = nums[j] * nums[j];  
                j--;  
            }else {  
                res[key] = nums[i] * nums[i];  
                i++;  
            }  
            key--;  
        }  
        return res;  
    }  
}
```
#### 优化:
- 可以定义left和right用于存放平方后的结果,避免重复计算,能稍稍提高效率.
```java
int leftSquare = nums[i] * nums[i];
int rightSquare = nums[j] * nums[j];
if (leftSquare < rightSquare) {
    res[key] = rightSquare;
    j--;
} else {
    res[key] = leftSquare;
    i++;
}
key--;

```
## 209.长度最小的子数组
### 题目:
给定一个含有 `n` 个正整数的数组和一个正整数 `target`.
找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ,并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
### 信息:
- **难度**:easy
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路一:
- 暴力解法,但是超时.
#### 思路二:
- 对于子数组问题,可以采用**滑动窗口法**(可理解会双指针法变体): 数组是无序的,不过全是整数,所以当存在满足的条件的子数组时,逐渐缩小数组,能保证子数组的值会变小,此时就可以找到最小子数组.
- 定义指针i和j,用于括住一个窗口.固定i,往右移动j,当存在满足条件的窗口(子数组)时,往右移动i,使得窗口减小,据此找到符合条件的最小子数组!
### 关键点:
- 使用滑动窗口使得遍历次数减少,降低时间复杂度.
### 代码:
```java
class Solution {  
    public int minSubArrayLen(int target, int[] nums) {  
        // 用于存放窗口的总和.
        int sum = 0;  
        int i = 0;  
        // 用于存放结果:子数组长度
        int res = nums.length+1;
        // 存放当前子数组长度.  
        int subL = 0;  
        for (int j = 0; j < nums.length; j++) { 
        // 窗口总和.
            sum += nums[j];  
            while (sum >= target) {  
			// 满足条件,取当前窗口长度.
                subL = j - i + 1;  
			// 若当前子数组长度和目前最小子数组长度比较
                res = res < subL ? res : subL;  
           //  左指针向右移动, 缩小窗口.  
                sum -= nums[i];  
                i++;  
            }  
        }  
        // 若res的值不为nums.length+1,代表修改过res,即存在最小子数组;否则返回0.
        return res == nums.length+1? 0 : res;  
    }  
}
```
#### 优化:
- `int res = Integer.MAX_VALUE;`:使用Integer.MAX_VALUE,使程序可读性更高.
- `res = Math.min(res,j-i+1)`:取最小子数组,可读性更高,同时效率好像也更高!
## 59.螺旋矩阵II
### 题目:
- 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
- ![[ArrayPart2_img1.png]]
### 信息:
- **难度**: Medium
- **重要性:** #★★★★★
### 思路:
>这道题目可以说在面试中出现频率较高的题目，**本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。**
- 确认每次画一条线,然后明确边界条件.建议以4×4矩阵为例子.
- 循环不变量:遵循一个规则来处理每一条边.
### 关键点:

### 代码:
```java
class Solution {  
    public int[][] generateMatrix(int n) {  
        int[][] matrix = new int[n][n];  
        int start = 0;  
        int end = n-1;  
        int count = 1;  
        while (start <= end) {  
            for (int i = start; i < end; i++) {  
                matrix[start][i] = count;  
                count++;  
            }  
            for (int i = start; i < end; i++) {  
                matrix[i][end] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[end][i] = count;  
                count++;  
            }  
            for (int i = end; i > start; i--){  
                matrix[i][start] = count;  
                count++;  
            }  
            if (start == end)  
                matrix[start][end] = count;  
            start++;  
            end--;  
        }  
        return matrix;  
    }  
}  
```

# 链表
## 203.移除链表元素
### 题目:
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
**输入:head = `[1,2,6,3,4,5,6]`, val = 6 输出：**`[1,2,3,4,5]`
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 这题难度不大,但是引入一个新方法:虚拟头节点.虚拟头节点可以使得在删除头节点时无需额外判断.
### 关键点:
- **虚拟头节点的引入!**
### 代码:
```java
class Solution {  
    public ListNode removeElements(ListNode head, int val) {  
        // 虚拟头节点,指向头节点,值任意.
        ListNode dummyNode = new ListNode(0, head);  
        
        ListNode curr = dummyNode;  
        while (curr.next != null) {  
            if (curr.next.val == val) {  
                curr.next = curr.next.next;  
            }else {  
                curr = curr.next;  
            }  
        }  
        return dummyNode.next;  
    }  
}

```
## 707.设计链表
### 题目:
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路:
- 设计自己的链表,定义如下方法:1)`get(int index)`:获取节点的值; 2)`addAtHead()`:插入新的头节点; 3)`addAtTail(int val)`:在尾节点后插入节点; 4)`addAtIndex(index,val)`:在index节点后插入新节点; 5)`deleteAtIndex(index)`:删除index节点.
- 要注意,我们只有头节点,要获取第index个节点,或者尾节点,必须通过遍历n次得到.
- 定义虚拟头节点,使得插入新的头节点更方便.
- 增/删节点,无非就是获取当前节点,并更改next指向!
### 关键点:
- 有对头节点的增删,定义虚拟头节点,操作头节点更方便!
### 代码:
```java
class ListNode{  
    int val;  
    ListNode next;  
    public ListNode(){}  
    public ListNode(int val){  
        this.val = val;  
    }  
}  
  
//leetcode submit region begin(Prohibit modification and deletion)  
class MyLinkedList {  
    int size;  
//    虚拟头节点.  
    ListNode head;  
    public MyLinkedList() {  
        size = 0;  
        head = new ListNode(0);  
    }  
      
    public int get(int index) {  
        if (index < 0 || index >= size){  
            return -1;  
        }  
        ListNode temp = head;  
        for (int i = 0; i <= index; i++){  
            temp = temp.next;  
        }  
        return temp.val;  
    }  
      
    public void addAtHead(int val) {  
        ListNode newHead = new ListNode(val);  
        newHead.next = head.next;  
        head.next = newHead;  
        size++;  
    }  
      
    public void addAtTail(int val) {  
        ListNode curr = head;  
        ListNode finalNode = new ListNode(val);  
        for (int i = 0; i < size; i++){  
            curr = curr.next;  
        }  
        curr.next = finalNode;  
        size++;  
  
    }  
      
    public void addAtIndex(int index, int val) {  
        ListNode insertNode = new ListNode(val);  
        if (index > size) {  
            return;  
        } else if (index == size) {  
            addAtTail(val);  
            return;  
        } else {  
            ListNode temp = head;  
            for (int i = 0; i <= index; i++) {  
                if (i == index){  
                    insertNode.next = temp.next;  
                    temp.next = insertNode;  
                    size++;  
                    return;  
                }  
                temp = temp.next;  
            }  
        }  
  
    }  
      
    public void deleteAtIndex(int index) {  
        if (index >= size || index < 0){  
            return;  
        }else {  
            ListNode temp = head;  
            for (int i = 0; i <= index; i++){  
                if (i == index){  
                    temp.next = temp.next.next;  
                    size--;  
                    return;  
                }  
                temp = temp.next;  
            }  
        }  
    }  
}
```
## 206.反转链表
### 题目:
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 单链表的操作,定义三个节点.prev,用于表示前驱节点;curr,表示当前节点;next,用于表示后继节点.next用于保存curr.next,因为反转节点意味着更新curr的指向,所以需要先保存`curr.next`!同时,prev需要一直保存前驱节点,使得能实现反转!
- **1)先保存curr.next; 2)更新curr的指向; 3)更新前驱prev和curr.**
### 关键点:
- **定义next或temp用于保存curr.next!!!!** 
- 操作curr.next时,需要判断curr是否为空.所以循环条件为curr!=null.
### 代码:
```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode prev = null;  
        ListNode cur = head;  
        ListNode next = null;  
        while (cur != null){  
            next = cur.next;  
            cur.next = prev;  
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
}
```


## 24.两两交换链表中的节点
### 题目:
- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 定义虚拟头节点,指向头节点.有了虚拟头节点后,方便对头节点与第二个节点进行交换操作.交换操作遵循如下步骤:![[LinkedListPart2_img1.png]]
	1. 步骤1: `cur.next = cur.next.next;`
	2. 步骤2: `cur.next.next = (cur.next);` 此时由于`cur.next`已在步骤1中被替换掉,所以此时在步骤1之前应该使用临时变量`temp1`来保存`cur.next`的值;
	3. 步骤3:`cur.next.next.next = (cur.next.next.next);`,此时由于`cur.next.next.next`已在步骤2中被斩断,所以在步骤2前应该使用`temp2`进行临时保存.
	4. cur节点更新,cur节点的更新逻辑应该是待交换的两个节点的前一个节点,所以有`cur = cur.next.next`
- 循环条件:因为是对cur的后两个节点进行替换操作,所以必须保证`cur.next`和`cur.next.next`不为空.当`cur.next`为空时,此时是偶数个节点,且cur已是链表的最后一个元素;当`cur.next`不为空,而`cur.next.next`为空时,此时是奇数个节点,并且cur已是倒数第二个元素.
- 特殊情况的处理: 1)链表只有单个元素,此时`cur.next.next == null`,所以不会进入循环,故直接返回`dummyHead.next`; 2)链表为空,此时`cur.next == null`,直接返回`dummyHead.next`
### 关键点:
- 定义虚拟头节点,对后两个节点进行交换操作;
- 循环条件的处理,因为是对curr的后两个节点操作,所以保证的是`curr.next, curr.next.next != null`.
### 代码:
```
class Solution {  
    public ListNode swapPairs(ListNode head) {  
        ListNode dummyHead = new ListNode(0);  
        dummyHead.next = head;  
        ListNode curr = dummyHead;  
        if (head == null || head.next == null)  
            return head;  
        ListNode temp1;  
        ListNode temp2;  
  
        while (curr.next != null && curr.next.next != null){  
            temp1 = curr.next;  
            temp2 = curr.next.next.next;  
  
            curr.next = curr.next.next;  
            curr.next.next = temp1;  
            curr.next.next.next = temp2;  
  
            curr = curr.next.next;  
        }  
        return dummyHead.next;  
    }  
}
```

## 19.删除链表的倒数第N个节点 
### 题目:
- 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
### 信息:
- **难度**:medium
- **重要性:** #★★★☆☆
### 思路:
- 通过快慢指针来判断是否到达了倒数第n个节点.具体如下:快,慢指针都指向头节点.快节点先移动n次,然后快慢节点同时移动,此时当快节点到达末尾时,慢节点到达倒数第n个节点!
### 关键点:
- 利用快指针先移动n个单位,使得快慢指针距离n个单位.
### 代码:
```java
class Solution {  
    public ListNode removeNthFromEnd(ListNode head, int n) {  
        ListNode dummyHead = new ListNode(0);  
        dummyHead.next = head;  
  
        ListNode slow = dummyHead;  
        ListNode fast = dummyHead;  
        int count = 0;  
        while (fast != null) {  
            %% 快指针先移动n个单位 %%
            if (count <= n) {  
                fast = fast.next;  
                count++;  
                continue;  
            }  
            fast = fast.next;  
            slow = slow.next;  
        }  
        slow.next = slow.next.next;  
        return dummyHead.next;  
    }  
}
```

## 面试题 02.07. 链表相交
### 题目:
- 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 拼接两个链表n1+n2,此时就能保证能在经过长度n1+n2后,到达同一起点,即形成了相同长度的路径,在遍历完这个长度后,会在相交点相遇,或者同时到达null.
### 关键点:
- 
### 代码:
```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode currA = headA;  
        ListNode currB = headB;  
        while (currA != currB){  
            if (currA != null) {  
                currA = currA.next;  
            }else {  
                currA = headB;  
            }  
            if (currB != null) {  
                currB = currB.next;  
            }else {  
                currB = headA;  
            }  
        }  
        return currA;  
    }  
}
```

## 142. 环形链表
### 题目:
- 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。**不允许修改链表。** 
### 信息:
- **难度**:
- **重要性:** #★★★★★
### 思路:
- 带有考察数学知识的题目.需要进行细心的推理!**首先**,明确一点,当有环时,可以转化为一个追赶问题,即**步长为2的快指针一定会追赶上步长为1的慢指针**,因为他们之间的距离是以不断减1的!据此,是否有环的逻辑完成,接下来就是判断环的起点!这里用一个图和公式进行说明:![[LinkedListPart2_img2.png]]
当**快慢指针相遇**时,有以下情况:
- 慢指针走过的节点数为$x+y$,快指针走过的节点数为$x+y+n(y+z)$,并且由于慢指针的步长为1,快指针的步长为2,所以有$(x+y)\times2=x+y+n(y+z)$
- 据此可推出→ $x+y=n(y+z)$.即头节点到环形入口节点的节点数目$x=n(y+z)-y$
- 理解一下,当n=1时,此时$x=z$;当n≠1时,此时$x=n(y+z)-y$,即走过了n个环的节点数$n(y+z)$-环形入口到相遇节点的节点数y.
- 
### 关键点:
- 
### 代码:
```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        if (head == null || head.next == null) {  
            return null;  
        }  
        ListNode fast = head;  
        ListNode slow = head;  
  
        while (fast != null && fast.next != null){  
            fast = fast.next.next;  
            slow = slow.next;  
  
            if (fast == slow) {  
                slow = head;  
  
                while (fast != slow) {  
                    fast = fast.next;  
                    slow = slow.next;  
                }  
                return fast;  
            }  
        }  
        return null;  
    }  
}

```

# 哈希表

## 242. 有效的字母异位词
### 题目:
- 给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。
- **字母异位词** 是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。
### 信息:
- **难度**:Easy
- **重要性:** #★★★☆☆
### 思路:
- 对题目进行简化:其实就是统计s中出现的次数及其次数,要求t中的字符均在s中使用过,并且使用次数要一致.
- 利用集合/数组存储字符串`s`的**出现的字符**及其**出现次数**,然后遍历字符`t`,判断t中的字符**是否均在存储s中的字符数组中**以及**t中的字符出现次数是否超出****.
- 因为小写字母一共只有26个,所以定义一个长度为26的数组一定满足条件!
### 关键点:
- 定义**长度为26**的数组存储**出现的字符及其使用次数.**
- 
### 代码:
```java
class Solution {  
    public boolean isAnagram(String s, String t) {  
        int[] record = new int[26];  
        if (s.length() != t.length())  
            return false;  
        for (int i = 0; i < s.length(); i++){  
            record[s.charAt(i) - 'a']++;  
        }  
        for (int j = 0; j < t.length(); j++){  
            record[t.charAt(j) - 'a']--;  
            if (record[t.charAt(j) - 'a'] < 0){  
                return false;  
            }  
        }  
        return true;  
    }  
}
```
## 349. 两个数组的交集
### 题目:
- 给定两个数组 `nums1` 和 `nums2`,返回它们的交集。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
### 信息:
- **难度**:
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路一:
- 利用Map存储nums1中的所有元素,其中key为nums1中的值,value任意(作为flag,之后在判断交集时使用).遍历nums2,判断nums2中的元素是否在Map出现过,若出现过,则将value置0,并且利用slow指针将该元素放置在nums2中.(slow指针肯定<=遍历nums2的指针)
#### 思路二:
- 利用set存储元素,set的特点是不会存储相同的元素,并且可以利用contains方法判断元素是否在set集合中.
### 关键点:
- 利用set集合不存储相同元素的特点.
### 代码:
#### 解法一:
- 利用Map来求解,可以但不是最优解.
```java
class Solution {  
    public int[] intersection(int[] nums1, int[] nums2) {  
        HashMap<Integer,Integer> map1 = new HashMap<>();  
        for (int i = 0; i < nums1.length; i++){  
            map1.put(nums1[i],1);  
        }  
        int slow = 0;  
        for (int j = 0; j < nums2.length; j++){  
            if (map1.get(nums2[j])== null){  
                continue;  
            }  
            if (map1.get(nums2[j]) != 0) {  
                nums2[slow] = nums2[j];  
                slow++;  
                map1.remove(nums2[j]);  
            }  
        }  
        if (slow != 0) {  
            nums1 = Arrays.copyOfRange(nums2,0,slow);  
            return nums1;  
        }else  
            return new int[0];  
    }  
}
```

## 202. 快乐数
### 题目:
- 编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
>难点在于 1)如何取出个,十,百位的数字; 2)在不是快乐数时,如何跳出循环.
- 1)取出各位数,可以定义函数(通用),i存储余数(i=n%10),并更新n的值(n=n/10),由于n是int类型,所以当**n<10时,n/10的结果为0**,所以可以利用这点作为循环条件,代码如下:
```java
	while (n != 0){  
//            保存余数  
		i = n % 10;  
//            利用集合/数组存储余数.
		map.put(count,i);  
		count++;  
//            保存整除结果  
		n = n / 10;  
	}  
```
- 2)跳出快乐数的循环,这里就与代码无关了,而是快乐数的定义.非快乐数,最终一定会出现相同的值,而快乐数最终结果会为1.但是如何判断是否重复,这也是个重点!利用HashSet<>不存储重复元素的特点以及contains方法实现.
### 关键点:
- 利用非快乐数的"平方和"的结果会重复出现作为跳出无限循环的条件.
### 代码:
#### 我的代码:
```java
class Solution {  
    public boolean isHappy(int n) {  
//    marked as function.  
        int res = n;  
        HashSet<Integer> set = new HashSet<>();  
        while (true) {  
            res = getResult(res);  
            if (res == 1) {  
                return true;  
            }  
            if (set.contains(res)) {  
                return false;  
            }  
            set.add(res);  
        }  
    }  
    public int getResult(int n){  
        HashMap<Integer,Integer> map = new HashMap<>();  
        int res = 0;  
        int i = 1;  
        int j = 1;  
        int count = 0;  
        //        取出个,十,百...  
        while (n != 0){  
//            保存余数  
            i = n % 10;  
            map.put(count,i);  
            count++;  
//            保存整除结果  
            n = n / 10;  
        }  
        for (int m = 0; m < count; m++){  
            res += (map.get(m) * map.get(m)) ;  
        }  
        return res;  
    }  
}
```

#### 官方解答
```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```

## 1. 两数之和
### 题目:
- 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_ 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路1:
- 这题最简单的方法就是利用两个for循环实现!
#### 思路2:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public int[] twoSum(int[] nums, int target) {  
//        解法1: 使用数组遍历  
        int sum = 0;  
        for (int i = 0; i < nums.length - 1; i++)  
            for (int j = i+1; j < nums.length; j++){  
                sum = nums[i] + nums[j];  
                if (sum == target)  
                    return new int[]{i,j};  
            }  
        return null;  
```


## 454. 四数相加II

### 题目:
- 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
	- `0 <= i, j, k, l < n`
	- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
**别害怕遍历所有数组!**
- 首先是有四个数组,需要统计一共多少个满足条件的元组(即无需返回数组索引).利用Map的特性,将nums1和nums2的两数和作为key,将出现次数作为value.之后再遍历nums3和nums4,得到其和c+d,并利用containsKey判断满足`a+b=c+d`的key值是否存在.
### 关键点:
- 利用Map的key-value特性保存两数和及其出现次数,其实`int[]`也可以实现这个,但是数组需要先定义长度,这里的数组长度是不确定的,所以无法使用,故选用集合Map来实现!
- Map有两个方法很常用:
	- `containsKey(Object key)`:用于判断是否存在该key的映射;其实用`get(Object) == null`也可以替代,但是containsKey更高效,也更直观.
	- `getOrDefault(Object Key,V defaultValue)`:返回指定key映射到的值，如果此map不包含键的映射，则返回传入的`defaultValue`. 这个操作用来替代`nums[i]++;`:因为在Map中,若key对应的映射不存在时,无法进行自增操作;而利用`getOrDefault`可以在映射不存在时,赋值为0再进行自增.
### 代码:
```java
class Solution {  
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
        int count = 0;  
        HashMap<Integer, Integer> map1 = new HashMap<>();  
        for (int i : nums1) {  
            for (int j : nums2) {  
                map1.put(i+j,map1.getOrDefault(i+j, 0) + 1);  
            }  
        }  
//        ArrayList<Integer> sum2 = new ArrayList<>();  
        for(int i :nums3) {  
            for (int j : nums4) {  
//                a+b+c+d=0  
//                sum1存储了a+b,判断是0-(c+d)的值是否存在  
                if (map1.containsKey(-(i+j))) {  
                    count += map1.get(-(i+j));  
                }  
            }  
        }  
        return count;  
    }  
}
```

## 383. 赎金信
### 题目:
- 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 利用数组作为哈希表,其中**索引**为字母的ASCII码,UNICODE码或者直接利用与'a'相减得到相对位置,即'a'的索引为0,'b'的索引为1...,**值**为出现次数.
### 关键点:
- 利用数组作为哈希表,思路更清晰,内存空间占用更少!
### 代码:
```java
class Solution {  
    public boolean canConstruct(String ransomNote, String magazine) {  
        if (ransomNote.length() > magazine.length())  
            return false;  
        int[] nums = new int[26];  
        for (int i = 0; i < magazine.length(); i++){  
            nums[magazine.charAt(i) - 'a']++;  
        }  
        for (int i = 0; i < ransomNote.length(); i++) {  
            if (nums[ransomNote.charAt(i) - 'a'] != 0) {  
                    nums[ransomNote.charAt(i) - 'a']--;  
            }else {  
                return false;  
            }  
        }  
        return true;  
    }  
}

```
## 15. 三数之和 
### 题目:
- 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
**注意：**答案中不可以包含重复的三元组。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- 将数组进行**排序**,利用双指针法!之后就是定义三个指针:i,j和k.i和j由左向右移动,k由右向左移动,移动逻辑如下:
	- 遍历i: `for(int i=0;i<nums.length-2;i++)`,判断`sum = nums[i]+nums[j]+nums[k]`: 1)`>0`,则此时k需要向左移动; 2)`<0`,则此时j需要向右移动(即增大sum); 3)`==0`,满足条件,将sum加入list中,并且j++,k--(`nums[j]`增大和`nums[k]`减小),并且需要进行去重操作:`nums[k/j] == nums[k-1/j+1]`,则多执行一次`k--/j++`.
### 关键点:
- 利用`Arrays.sort(nums)`将数组进行排序!
- **双指针法:对sum的值进行判断,然后决定移动哪个指针;**
- 去重操作,若`nums[i] == nums[i+1]`,则需额外移动一次指针.
### 代码:
```java
class Solution {  
    public List<List<Integer>> threeSum(int[] nums) {  
        List<List<Integer>> list = new ArrayList<>();  
        Arrays.sort(nums);  
//      若首个元素都为空,则直接返回!  
        if (nums[0] > 0 || nums.length < 3) return list;  
        int j = 0;  
        int k = nums.length - 1;  
        int sum = 0;  
        for (int i = 0; i < nums.length - 2; i++) {  
            j = i + 1;  
            k = nums.length - 1;  
  
            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a  
                continue;  
            }  
            while (j < k) {  
                sum = nums[i] + nums[j] + nums[k];  
                if (sum < 0) j++;  
                else if (sum > 0) k--;  
                else {  
                    list.add(Arrays.asList(nums[i], nums[j], nums[k]));  
                    while (k > j && nums[k] == nums[k - 1]) k--;  
                    while (k > j && nums[j] == nums[j + 1]) j++;  
                    j++;  
                    k--;  
                }  
            }  
        }  
        return list;  
    }  
}
```

## 18. 四数之和

### 题目:
给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 **任意顺序** 返回答案 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- 这题其实是和三数之和一种类型的题目,都是利用多指针法.其中i,j,m三个指针在左,k指针在右.先判断sum值:1)若大于target,则移动指针k; 2)若小于target,则移动指针m; 3)若等于,则`list.add`,并同时移动m和k.当`m>=k`时,此时就需要更新一次j,重复上述步骤;若遍历完所有j,则需要更新i了.即i是最外层循环,j是内层循环,而m和k是内内层循环.
- 去重操作,对于i的去重,`if (i > 0 && nums[i] == nums[i - 1]);`,总是迷惑是用`nums[i]==nums[i-1]`还是`nums[i]==nums[i+1]`,这样理解:**i是向右移动的**,所以先对i进行遍历,结束后i++,此时的`nums[i]和nums[i-1]`有可能重复,所以判断条件是`nums[i]==nums[i-1]`,若重复了,则跳过当前的i!
- 同理,对于k的去重,k是向左移动的,先使用当前的k,当k--后,判断`nums[k]==nums[k+1]`,若重复,则跳过当前k(即执行k--).
### 关键点:
- 多指针法!特别是指针k需要放在最右边!然后就是根据sum值的不同移动指针.
- **去重操作**是重点,要注意不同的条件,指针往右移动时,是使用`num[i]==nums[i-1]`;向左移动时,是使用`num[i]==nums[i+1]`,即判断当前值和前面使用过的值是否相等,相等则跳过!
- **剪枝操作**,即当满足一定条件时直接跳出循环,不执行多余的操作:
	- i循环的剪枝,当满足`nums[i]>0且nums[i]>target`时,此时往后的均是`大于0且大于nums[i]`的数,只会越来越大于target,故可直接返回list.
	- j循环的剪枝,当`nums[i]+nums[j] > 0 && nums[i]+nums[j] > target`时,
```
i循环的剪枝:

// nums[i] > target 直接返回, 剪枝操作
if (nums[i] > 0 && nums[i] > target) {
	return result;
}

j循环的剪枝:
//
if (nums[i]+nums[j] > 0 && nums[i]+nums[j] > target) {
	break;
}
```
### 代码:
```java
class Solution {  
    public List<List<Integer>> fourSum(int[] nums, int target) {  
        List<List<Integer>> list = new ArrayList<>();  
        Arrays.sort(nums);  
  
        if (nums.length < 4) return list;  
  
        int m = 0;  
        int k = nums.length - 1;  
//        int sum = 0;  
        for (int i = 0; i < nums.length - 3; i++) {  
            // nums[i] > target 直接返回, 剪枝操作  
            if (nums[i] > 0 && nums[i] > target) {  
                return list;  
            }  
            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a  
                continue;  
            }  
            for (int j = i + 1; j < nums.length - 2; j++){  
                if (nums[i]+nums[j] > 0 && nums[i]+nums[j] > target) {  
                    break;  
                }  
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; // 去重b  
                m = j + 1;  
                k = nums.length - 1;  
  
               while (m < k) {  
                   long sum =(long) nums[i] + nums[j] + nums[m] + nums[k];  
                   if (sum > target) k--;  
                   else if (sum < target) m++;  
                   else {  
                       list.add(Arrays.asList(nums[i], nums[j],nums[m],nums[k]));  
                       while (m < k && nums[k] == nums[k-1]) k--;  
                       while (m < k && nums[m] == nums[m+1]) m++;  
                       m++;  
                       k--;  
                   }  
               }  
           }  
        }  
        return list;  
    }  
}  
```

# 字符串
## 344. 反转字符串

### 题目:
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
- 双指针交换数组元素,利用中间变量temp保存交换元素.
### 关键点:
- 无.
### 代码:
```java
class Solution {  
    public void reverseString(char[] s) {  
        int left = 0;  
        int right = s.length - 1;  
        char temp;  
        while (left < right){  
            temp = s[right];  
            s[right] = s[left];  
            s[left] = temp;  
            left++;  
            right--;  
        }  
    }  
}
```

## 541. 反转字符串II
### 题目:
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- **理解题目:** 每2k个,反转前k个;若当出现剩下的字符长度<k,则全部反转;若剩下的字符>=k,但<2k,则依旧反转前k个.
- 定义index变量,用于判断剩余字符串属于上述哪种类型,不同类型执行不同的反转操作.最终代码如下.每次执行反转操作后,都需要更新index!
### 关键点:
- 思路很清晰,重点是代码如何操作!还有就是减少冗余.
- **每2k个翻转前k个,若剩余字符小于2k,但大于k,仍翻转前k个**,所以这两者的右指针其实是一样的;若剩余字符小于k个,则此时右指针会不同,但翻转逻辑仍是一样的.
### 代码:
#### 版本一:(冗余度高)
```java
class Solution {  
    public String reverseStr(String s, int k) {  
        int index = 0;  
        char temp;  
        char[] s1 = s.toCharArray();  
        while ((s.length()-index) > 0){  
        // 1和2内的for循环逻辑是相同的,可以合并!
            1:if ((s.length() - index) > 2*k) {  
                for (int i = index, j = index+k-1; i < j; i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }2:else if ((s.length() - index > k)){  
                for (int i = index, j = index+k-1; i < j;i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }else {  
            // 逻辑与上面也相同,但是右指针不一样!想办法根据不同条件获得不同右指针.
                for (int i = index, j = s.length()-1; i < j;i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }  
            index = index + 2*k;  
        }  
        return String.valueOf(s1);  
    }  
}  
```
#### 版本二:(优化后)
##### 优化思路:
1. 首先,上面的if和else-if是一样的逻辑,所以首先合并了;
2. if和else的交换逻辑也是一样的,**只是右指针不同**,所以这里可以利用`Math.min()`函数来判断j取`index+k-1`还是`s.length()-1`,即**若剩余字符小于k时,此时`s.length()-1`肯定小于`index+k-1`**,故取min值是正确且合理的.
```java
class Solution {  
    public String reverseStr(String s, int k) {  
        int index = 0;  
        char[] s1 = s.toCharArray();  
        // 只要还剩余字符,就需要交换!
        while ((s.length()-index) > 0){  
            int i = index;  
            // 取min值,避免右指针越界了!
			// s.length()-1代表着剩余字符少于k,全翻转;
			// index+k-1,代表着剩余字符大于k,翻转前k个.
            int j = Math.min(index + k - 1, s.length() - 1);  
            while(i<j){  
                char temp = s1[j];  
                s1[j] = s1[i];  
                s1[i] = temp;  
                i++;
                j--;
            }  
            index = index + 2*k;  
        }  
        return String.valueOf(s1);  
    }  
} 
```

## 54. 替换数字（卡码网）
### 题目:
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。
**输入描述**
输入一个字符串 s,s 仅包含小写字母和数字字符。
**输出描述**
打印一个新的字符串，其中每个数字字符都被替换为了number
### 信息:
- **难度**: null
- **重要性:** #★★★☆☆
### 思路:
- 由于String的不可变性,所以此处应该使用StringBuilder来输出结果.
- 利用`Character.isDigit(char c)`来判断当前字符是否为数字,若为数字,则`res.append("number")`;若非数字,则`res.append("currChar")`
- **在不需要获取索引时,可以使用增强for循环!**
### 关键点:
- 1)利用好StringBuilder的可变性; 
- 2)利用append函数在可变字符串尾部添加字符(串);
- 3)利用`Character.isDigit()`判断是否为数字.
### 代码:
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
		// 获取输入.
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        // 操作逻辑.
        StringBuilder result = new StringBuilder();
        for(char c : s.toCharArray()){
            if (Character.isDigit(c)){
                result.append("number");
            }else{
                result.append(c);
            } 
        }
        //输出结果.
        System.out.println(result.toString());
    }
}

```


## 151. 反转字符串中的单词
### 题目:
给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：** 输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
#### 思路一:
- 最简单的想法,利用java的String库函数,例如trim,split函数.这样使得这题过于简单,无意义.
#### 思路二:
- 定义双指针,碰到非空格,就定住慢指针,快指针寻找空格,找到了,就取之间的单词,使用append函数添加到sb中.同时,为了保证能找到开头的单词,额外添加了" ", 这样就能保证快指针一定能寻找到开头的空格了.
#### 思路三:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public String reverseWords(String s) {  
        StringBuilder sb = new StringBuilder();  
        // 保证能取到开头的单词!
        s = " ".concat(s);  
        char[] c1 = s.toCharArray();  
  
        int fast = 0;  
  
        for (int i = c1.length - 1; i >= 0; i--){  
            if (c1[i] != ' ') {  
                for (int j = i; j >= 0; j--) {  
                    if (c1[j-1] == ' ') {  
                    // 取非' '和' '之间的单词. 
                        sb.append(s.substring(j, i + 1)+' ');  
                        i = j;  
                        break;  
                    }  
                }  
            }  
        }  
        return sb.substring(0,sb.length()-1);  
    }  
}
```
## 55. 右旋字符串
### 题目:
字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。
### 信息:
- **难度**: null
- **重要性:** #★★☆☆☆
### 思路:
- 利用subString获得后k位和前k位,再利用+来拼接字符串.
### 关键点:
- 
### 代码:
```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        String s = scanner.next();
        
        int sLen = s.length();
        String sub1 = s.substring(sLen-k,sLen);
        String sub2 = s.substring(0,sLen-k);
        System.out.println(sub1+sub2);
    }
}
```
## 28. 找出字符串中第一个匹配项的下标
### 题目:
给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
#### 思路一:
- 暴力解法,判断所有与needle长度相同的字符串是否与needle匹配,是则返回下标.
#### 思路二:
- 思路类似,不过通过增加限制来减少匹配次数,即降低了时间复杂度. 1)若needle长度>haystack长度,不可能匹配,直接返回; 2)只有当haystack中的某个字母与needle的首字母相同时,才开始匹配操作; 3)循环i的判断不用到`<haystack.length()`,小于`haystack.length()-needle.length()`即可.易理解,在这之后的匹配并无意义,因为剩余字符串的长度小于needle的长度.
#### 思路三:
- KMP算法?
### 关键点:
- 多添加进行循环匹配的限制条件!
### 代码:
```java
class Solution {  
    public int strStr(String haystack, String needle) {  
        int hLen = haystack.length();  
        int nLen = needle.length();  
        // needle字符串更长,不可能匹配,直接返回!
        if (nLen > hLen) return -1;  
        for (int i = 0; i <= hLen-nLen;i++){ 
        // 首字母相同才进行匹配! 
            if (haystack.charAt(i) == needle.charAt(0)) {  
                    int end = nLen;  
                    String str = haystack.substring(i,end+i);  
                    if (str.equals(needle))  
                        return i;  
            }  
        }  
        return -1;  
    }  
}
```
#### 优化:
- 使用滑动窗口优化subString.当`charAt(i+j)==charAt(j)`,即代表当前首字母相同,开始滑动,即j++.此时窗口逐步增大,即while中逐个判断字符是否相等,当`j==nLen`,代表窗口长度等于needle字符串长度,即此时二者匹配!
```java
for (int i = 0; i <= hLen - nLen; i++) { 
	// 检查 haystack 从 i 开始的子串是否与 needle 相等
	int j = 0; 
	while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {
		j++; 
	} 
	if (j == nLen) return i; // 找到匹配 
	}
```
## 459. 重复的子字符串
### 题目:
给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 能由子串重复构成,代表必定存在`s.charAt(i)==s.charAt(0)`.取该子串,并对剩余字符串进行判断即可.
### 关键点:
- **能由子串重复构成,代表必定存在`s.charAt(i)==s.charAt(0)`.**
### 代码:
```java
class Solution {  
    public boolean repeatedSubstringPattern(String s) {  
        int sLen = s.length();
        // i循环条件: 剩余字符串长度应大于等于重复子串长度->i <= sLen/2
        for (int i = 1;(sLen - (i)) >= (i) ; i++){
	        // 判断是否存在首字母相同,即可能重复的子字符串.
            if (s.charAt(i) == s.charAt(0)){  
	            // 取重复子串.
                String sub = s.substring(0,i);  
                int subLen = i;  
                int j = i;  
				// 先判断是否剩余字符串长度大于重复子串.
				// 若大于,则判断接下来相同长度的子串是否跟重复子串匹配.
                while ((sLen - j + 1) >= subLen && s.substring(j,j+subLen).equals(sub)){  
                    j += subLen;  
                    // j能等于sLen,说明一直是匹配的.
                    if (j == sLen) return true;  
                }  
            }  
        }  
        return false;  
    }  
}
```

# 栈与队列


## 232. 用栈实现队列
### 题目:
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 用栈实现队列,即通过栈的"先进后出"实现队列的"先进先出".利用两个栈`stackIn`和`stackOut`,`stackOut`用于存储元素的倒序版本,从而正确模拟队列出队操作.
- ~~实现队列/栈,只要保证能实现基本操作即可.例如栈实现队列,保证能符合队列的进出,获取元素即可,无需过分关注内部如何存储.~~
- `dumpStackIn()`函数,是用于将stackIn的元素放入StackOut,因为栈是先进后出,所以将stackIn的元素放入stackOut,此时后进的元素就变为了先进的元素!
>[!GPTANSWER]
>**如果每次调用 `dumpStackIn` 时都将 `stackIn` 中的元素倒入 `stackOut`，会导致 `stackOut` 中的元素顺序被打乱，无法保证队列的顺序性。**
- 例如,先将1放入了stackOut,此时再将3,2也放入了stackOut,此时就变成了`[2,3,1]`,此时就变成了2先出栈,故会错误! 保证stackOut即保证了"先进先出"!
### 关键点:
- 运用两个队列来保证队列的出队操作.
- 需要理解好模拟的出队操作,尤其是当stackOut为空时才往里面添加元素.
### 代码:
```java
class MyQueue {  
    Stack<Integer> stackIn;  
    Stack<Integer> stackOut;  
  
    public MyQueue() {  
        stackIn = new Stack<>();  
        stackOut = new Stack<>();  
  
    }  
  
    public void push(int x) {  
        stackIn.push(x);  
    }  
  
    public int pop() {  
        dumpStackIn();  
        return stackOut.pop();  
    }  
  
    public int peek() {  
        dumpStackIn();  
        return stackOut.peek();  
    }  
  
    public boolean empty() {  
        return stackIn.isEmpty() && stackOut.isEmpty();  
    }  
  
    private void dumpStackIn(){  
        if (stackOut.isEmpty()){  
            while (!stackIn.isEmpty()){  
                stackOut.push(stackIn.pop());  
            }  
        }  
    }  
}  
```
## 225. 用队列实现栈
### 题目:
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
实现 `MyStack` 类：
- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
**注意：**
- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 可以使用单向队列或双向队列来实现,使用双向队列则更简单.
- 可以使用"循环队列"来实现先进后出.
- 使用队列实现栈的出栈操作: 因为出栈是末尾弹出,所以当队列有size个元素,即**将前size-1个元素先出队,再入队**.就能在**保证末尾元素被出队,同时保存前面元素顺序不变!**
- 获得栈顶元素,就是将末尾元素出队,再入队.故先调用pop()方法,再push.
### 关键点:
- 循环队列!
### 代码:
```java
class MyStack {  
//    使用Queue实现,不使用末尾弹出.  
    Queue<Integer> queue1;  
  
    public MyStack() {  
        queue1 = new LinkedList<>();  
    }  
  
    public void push(int x) {  
        queue1.add(x);  
    }  
  
    public int pop() {  
        if (!empty()) {  
            int size = queue1.size();  
            while (size > 1) {  
                size--;  
                queue1.add(queue1.poll());  
            }  
            return queue1.poll();  
        }  
        return -1;  
    }  
  
    public int top() {  
        int res = pop();  
        push(res);  
        return res;  
    }  
  
    public boolean empty() {  
        return queue1.isEmpty();  
    }  
}

```
## 20. 有效的括号
### 题目:
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 遇到左括号就入栈一个相应的右括号.遇到右括号就弹出栈顶元素进行匹配.此时
### 关键点:
- **遇到左括号,入栈对应右括号!**
### 代码:
```java
class Solution {  
    public boolean isValid(String s) {  
        if ((s.length() % 2) != 0) return false;  
        Stack<Character> stack = new Stack<>();  
  
        for (int i = 0; i < s.length(); i++){  
            char c = s.charAt(i);  
            if (c == '(') stack.push(')');  
            else if (c == '{') stack.push('}');  
            else if (c == '[') stack.push(']');  
            else if (stack.isEmpty() || stack.peek() != c) return false;  
            else stack.pop();  
        }  
        return stack.isEmpty();  
    }  
}
```
## 1047. 删除字符串中的所有相邻重复项
### 题目:
给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 将当前元素与前一个入栈的元素进行比较.
- 若栈为空或字母与栈顶元素不匹配,则入栈;否则,将栈顶元素弹出.
### 关键点:
- 无.
### 代码:
```java
class Solution {  
    public String removeDuplicates(String s) {  
        Stack<Character> stack = new Stack<>();  
        if (s.length() == 1) return s;  
        for (int i = 0; i < s.length();i++){  
            char c = s.charAt(i);  
            if (stack.isEmpty() || stack.peek() != c) stack.push(c);  
            else stack.pop();  
        }  
        StringBuilder sb = new StringBuilder();  
        while (!stack.isEmpty()) sb.append(stack.pop());  
        return sb.reverse().toString();  
    }  
}
```


## 150. 逆波兰表达式求值
### 题目:
给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
**注意：**
- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路:
- 遇到这种需要返回前面的两个元素的,可以采用栈来实现.
- 若采用队列,则无法返回刚入栈的两个元素,而是返回最先入栈的两个元素.看似队列没问题,实则仔细思考,在`["4","13","5","/","+"]`时,此时采用队列的话,就会是4/13,无法获得正确答案!
### 关键点:
- 需要获得当前字符的前n个元素,可采用栈来实现!!!
### 代码:
```java
class Solution {  
    public int evalRPN(String[] tokens) {  
        Deque<Integer> stack = new LinkedList<>();  
        for (String s : tokens){  
	        // 判断当前字符数s是+,-,或/.
            if ("+-*/".contains(s)){  
                int a = stack.pop();  
                int b = stack.pop();  
                switch (s) {  
                // 弹出后两个计算,并再次入栈.
                    case "+" -> stack.push(b+a);  
                    case "-" -> stack.push(b-a);  
                    case "*" -> stack.push(b*a);  
                    case "/" -> stack.push(b/a);  
                }  
            }else  
	            // Integer.valueOf将字符串转换为Integer型.
                stack.push(Integer.valueOf(s));  
        }  
        return stack.pop();  
    }  
}
```
## 239. 滑动窗口最大值
### 题目:
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值.
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 这题是单调队列的题目!获得窗口内的最值.
- 单调队列,用于获取队列/窗口内的最值,所以队顶必须为当前窗口内的最值.作为处理这类题目的特殊的队列,**与常规队列不同,无需维护窗口内的所有元素,只需要维护窗口内的最值即可**!
### 关键点:
- 单调队列的构造,无需维护窗口内所有元素.
### 代码:
```java
class Solution {  
    public int[] maxSlidingWindow(int[] nums, int k) {  
        MyQueue queue = new MyQueue();  
        int n = nums.length;  
        int[] res = new int[n-k+1];  
        if (n == 1 || k == 1) return nums;  
		// 先入队k-1个.
        for (int i = 0;i < k-1; i++){  
            queue.push(nums[i]);  
        }  
        // 入队,获得当前窗口最大值,出队.
        for (int i = 0; i <= (n-k);i++){  
            queue.push(nums[i+k-1]);  
            res[i] = queue.max();  
            queue.pop(nums[i]);  
        }  
        return res;  
    }  
}  
  
class MyQueue{  
	// 频繁增删,用LinkedList.
    Deque<Integer> que = new LinkedList<>();  
	// 为空则入队;或队底的元素小于当前元素,则弹出小的,推入大的.
    public void push(int n){  
        while (!que.isEmpty() && que.peekLast() < n){  
            que.pollLast();  
        }  
        que.add(n);  
    }  
	// 队顶始终为最大值,故返回peek()即可.
    public int max(){  
        return que.peek();  
    }  
	// 若移出窗口的元素在队顶,则移出.
    public void pop(int n){  
        if (!que.isEmpty() && n == que.peek()) que.poll();  
    }  
}
```

## 347. 前 K 个高频元素

### 题目:
给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 回想到之前存放字母出现的频次,因为小写字母只有26个,故可以用数组来存储.但对于数字,只能采用Map来存储,其中key为数字值,value为出现频次.
- 返回高频元素,可以采用优先级队列`PriorityQueue`.优先级队列是将入队元素按Comparator的顺序排列(即出现频次排列,默认为小顶堆).
>[!函数式接口Comparator中的方法compare(T o1,T o2)]
>当返回值为负数时,代表o1小于o2,返回值为正数时,代表o1>o2.
>**return o1-o2 ,代表升序排列.**

>[!小顶堆和大顶堆]
>小顶堆即队首元素最小,按升序排列;大顶堆则反过来,队顶元素最大,按降序排列. 对于此题,采用小顶堆较方便,因为可以更好的弹出频次较低的元素.
### 关键点:
- 采用Map存储数字的出现频次.
- 选取优先级队列存储,便于获得出现频次前k的元素.
### 代码:
此处的Comparator.comparingInt(map::get)不太好理解,可以转换成:
`(a,b) -> Integer.compare(map.get(a)-map.get(b))`
```java
class Solution {  
    public int[] topKFrequent(int[] nums, int k) {  
        HashMap<Integer,Integer> map = new HashMap<>();  
        // 存储数字出现的频次.
        for (int i = 0; i < nums.length;i++){  
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);  
        }  
	//优先级队列:指定队列大小为k,按Comparator.comparingInt(map::get)排序.
        Queue<Integer> queue1 = new PriorityQueue<>(k,Comparator.comparingInt(map::get));  
        // 入队,
        for (Integer key : map.keySet()){  
            queue1.add(key);  
            if (queue1.size() > k) queue1.poll();  
        }  
        int[] res = new int[k];  
        // 存储前k个高频元素.
        for (int i = 0; i < k; i++){  
            res[i] = queue1.poll();  
        }  
        return res;  
    }  
}
```

# 二叉树


## 前中后序遍历的迭代写法
### 题目:

### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:

#![[二叉树中序遍历（迭代法）.gif|400]]
### 关键点:
- 
### 代码:
```java


```


## 102. 二叉树的层序遍历
### 题目:
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public List<List<Integer>> levelOrder(TreeNode root) {  
  
        List<List<Integer>> res = new ArrayList<>();  
        Queue<TreeNode> que = new LinkedList<>();  
  
        if (root != null) que.offer(root);  
        while (!que.isEmpty()) {  
            int size = que.size();  
            List<Integer> temp = new ArrayList<>();  
//                 以size循环,即对本层节点进行遍历.  
            for (int i = 0; i < size; i++){  
//                 队顶出队,并存储到该层结果中.  
                TreeNode tempNode = que.poll();  
                temp.add(tempNode.val);  
//                存储子节点,由于队列是先进先出,所以子节点会在本层节点遍历完后才遍历.  
                if (tempNode.left != null) que.offer(tempNode.left);  
                if (tempNode.right != null) que.offer(tempNode.right);  
            }  
//            一层结束,存储该层结果.  
            res.add(temp);  
        }  
        return res;  
    }  
}
```
# 贪心算法

## 55. 合并区间
### 题目:
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 记录start和end区间,分几种情况讨论:
	1) end区间与下一个区间的左边界有重叠,则合并区间->即更新end为目前最远的右边界;
	2) end区间与下一个区间的左边界无重叠,则将区间加入到res结果中.并且要更新start和end为下一个区间的左右边界.
	3) 最后还需将最后的区间加入到res结果中.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int[][] merge(int[][] intervals) {  
        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);  
        // 存放当前最右区间  
        int start = intervals[0][0];  
        int end = intervals[0][1];  
        // 存放二维数组  
        List<int[]> res = new ArrayList<>();  
        // 存放区间  
        //List<Integer> temp = new LinkedList<>();  
  
        for (int i = 1; i < intervals.length; i++) {  
            // 没重叠, 则放入集合中  
            if (intervals[i][0] > end){  
                res.add(new int[]{start,end});  
                start = intervals[i][0];  
                end = intervals[i][1];  
            }else {  
                // 有重叠, 则合并  
                end = Math.max(intervals[i][1],end);  
            }  
        }  
        res.add(new int[]{start,end});  
  
        return res.toArray(new int[res.size()][]);  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 738. 单调递增的数字
### 题目: 
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 将int通过`String.valueOf().toCharArray()`转换为char数组,便于比较.
- 分为两种情况进行讨论: (从后向前遍历)
	1) 若`[i-1] <= [i]`,则满足条件,继续遍历;
	2) 若`[i-1] > [i]`, 则记录此时位置idx,并将`[i-1]--`.
- 遍历直到起始为止,持续更新idx,最后将idx及后面的数字全部更新为9.
### 关键点:
- 从后向前遍历是关键,这样才能反复利用更新后的`[i-1]`.
- 必须使用idx记录后统一更新,若遍历时更新,无法保证全是递增.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int monotoneIncreasingDigits(int n) {  
        if (n >= 0 && n <= 9) return n;  
        // 转换为char数组，便于操作  
        char[] c = String.valueOf(n).toCharArray();  
        // 记录开始变9的位置  
        int idx = c.length;  
        for (int i = c.length-1; i > 0; i--) {  
            if (c[i-1] > c[i]){  
                c[i-1]--;  
                idx = i;  
            }  
        }  
        for (int i = idx; i < c.length;i++){  
            c[i] = '9';  
        }  
        return Integer.parseInt(String.valueOf(c));  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 968. 监控二叉树
### 题目:
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {
    int res = 0;
    public int minCameraCover(TreeNode root) {
        if (dfs(root) == 0) { // root 无覆盖
            res++;
        }
        return res;
    }

    int dfs(TreeNode root){
        // 标记状态：2为有覆盖 1为有摄像头 0为无覆盖
        if (root == null) return 2;

        int left = dfs(root.left);
        int right = dfs(root.right);

        // 都有覆盖，则父节点应该是0
        if (left == 2 && right == 2) return 0

        if (left == 0 || right == 0) {
            res++;
            return 1;
        }
        if (left == 1 || right == 1) return 2;

        return -1;

    }

}
```



# 动态规划
如果某一问题有很多重叠子问题，使用动态规划是最有效的。
所以动态规划中**每一个状态一定是由上一个状态推导出来的**，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

**动态规划五部曲:**
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**动态规划debug方式:**
debug 的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的。写代码之前一定要把状态转移在 dp 数组上的具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。


## 509. 斐波那契数列
### 题目:

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 思路1:利用递归来做.
- 思路2:利用动态规划来做:
	- dp数组已知,即`dp[i]`为第i个斐波那契数.
	- 递推公式已知,`dp[i] = dp[i-1] + dp[i-2] `
	- 初始化已知:`dp[0]=0,dp[1]=1`;
	- 遍历顺序:从前往后
	- 
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int fib(int n) {  
        // dp数组: dp[i]为第i个数的fib数列  
        // 递推公式: dp[i] = dp[i-1] + dp[i-2]  
        // 初始化: dp[1] = 1, dp[0] = 0;  
        // 遍历顺序: 从前往后.  
        // 举例推导: n=5时,dp数组为:  
        if (n <= 1) return n;  
        int[] dp = new int[n+1];  
        dp[1] = 1;  
        dp[0] = 0;  
        for (int i = 2; i <= n; i++) {  
            dp[i] = dp[i-1] + dp[i-2];  
        }  
        return dp[n];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)  
  
//if (n <= 1) return n;  
//return fib(n-1) + fib(n-2);
```
## 70. 爬楼梯
### 题目:

### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 重点是找到规律!`[1 2 3 5 8 13 ...]`,可以看出每一层的可能性都是前面2个可能性的和.
- 找到规律后,用暴力求解,发现方法超时!!!
- 使用动态规划来做:
	- 初始化dp数组: 第i层台阶即是`dp[i-1]`;
	- 递推公式: `dp[i] = dp[i-1] + dp[i-2]`
	- dp数组初始化: `dp[0] = 1, dp[1] = 2`
	- 遍历顺序: 从前往后遍历,获取第n层,遍历到`dp[n-1]`即可.
### 关键点:
- 重点是找到规律!`[1 2 3 5 8 13 ...]`,可以看出每一层的可能性都是前面2个可能性的和.
### 代码:
```java

//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int climbStairs(int n) {  
        if (n <= 2) return n;  
        int[] dp = new int[2];  
        dp[1] = 2;  
        dp[0] = 1;  
        int sum = 0;  
        // [1 2 3 5 8 13]  
        for (int i = 2; i < n; i++) {  
            sum = dp[0] + dp[1];  
            dp[0] = dp[1];  
            dp[1] = sum;  
        }  
        return dp[1];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 
### 题目:

### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
- 
### 关键点:
- 
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    int sum = 0;  
    public int minCostClimbingStairs(int[] cost) {  
        // 不会连爬两次1个台阶.  
        // dp[i]为到达第i层台阶所需的费用.  
        //dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])        // 要获取dp[n]  
        int n = cost.length;  
        int[] dp = new int[n+1];  
         dp[0] = 0;  
         dp[1] = 0;  
        for (int i = 2; i <= n; i++) {  
            dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2]);  
        }  
  
        return dp[n];  
  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```

## 62. 不同路径
### 题目:
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 可以看出,`[i][j]`的路径可有`[i][j-1]`和`[i-1][j]`到达,所以可以得到递推公式: `dp[i][j]=dp[i-1][j]+dp[i][j-1]`,然后就是需要处理特殊情况,因为当在边界时,此时只能由`[i][j-1]`或`[i-1][j]`到达.
### 关键点:
- 
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int uniquePaths(int m, int n) {  
        // 1 <= m, n <= 100  
        int ans = 0;  
        int[][] dp = new int[m][n];  
        dp[0][0] = 1;  
  
        for (int i = 0; i < m; i++) {  
            for (int j = 0; j < n; j++) {  
                if (i > 0 && j > 0){  
                    dp[i][j] = dp[i][j-1] + dp[i-1][j];  
                }else if (i > 0){  
                    //  
                    dp[i][j] = dp[i-1][0];  
                }else if (j > 0){  
                    dp[i][j] = dp[0][j-1];  
                }  
            }  
        }  
        return dp[m-1][n-1];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```

## 63. 不同路径 II
### 题目:
给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 与62的思路一致,不过这里要注意,当`obstacleGrid[i][j]==1`,即遇到障碍物时,要将当前`dp[i][j]`也置为0,即无法到达.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {  
  
        int m = obstacleGrid.length;  
        int n = obstacleGrid[m-1].length;  
        int[][] dp = new int[m][n];  
        dp[0][0] = 1;  
        for (int i = 0; i < m; i++) {  
            for (int j = 0; j < n; j++) {  
                if (obstacleGrid[i][j] == 0){  
                    if (i > 0 && j > 0) {  
                        dp[i][j] = dp[i-1][j]+dp[i][j-1];  
                    }else if (i > 0){  
                        dp[i][j] = dp[i-1][0];  
                    }else if (j > 0){  
                        dp[i][j] = dp[0][j-1];  
                    }  
                }else {  
                    dp[i][j] = 0;  
                }  
            }  
        }  
        return dp[m-1][n-1];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```

## 
### 题目:

### 信息:
- **难度**:
- **重要性:** #★☆☆☆☆
### 思路:
- 
### 关键点:
- 
### 代码:
```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;

        for (int i = 3; i <= n;i++){
            for (int j = 1; j < i;j++){
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}

```

## 96. 不同的二叉搜索树
### 题目:
给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。![[Pasted image 20241012000929.png]]
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 易知,当n=3时,此时的根节点可以为①,②,③:
	- 当节点为①时,左边0个节点,右边2个节点,种数为:`[0]*[2]`
	- 当节点为②时,左边1个节点,右边1个节点,种数为:`[1]*[1]`
	- 当节点为③时,左边2个节点,右边0个节点,种数为:`[2]*[0]`
- 所以有,`dp[3]=dp[0]*dp[2]+dp[1]*dp[1]+dp[2]*dp[0]`
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int numTrees(int n) {  
        int[] dp = new int[n+1];  
  
        dp[0] = 1;  
        dp[1] = 1;  
        // 求解dp[n]  
        for (int i = 2; i <= n; i++){  
            for (int j = 0; j < i; j++){  
                dp[i] += dp[j] * dp[i-1-j];  
            }  
        }  
        return dp[n];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```

## 416. 分割等和子集
### 题目:
给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- 
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public boolean canPartition(int[] nums) {  
        int n = nums.length;  
        int sum = 0;  
        for (int i : nums) sum += i;  
        if (sum % 2 != 0) return false;  
  
        int target = sum / 2;  
  
        int[] dp = new int[target+1];  
  
        for (int i = 0; i < n; i++) {  
            for (int j = target; j >= nums[i]; j--) {  
                dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]);  
            }  
            if (dp[target] == target) return true;  
        }  
  
        return dp[target] == target;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 198. 打家劫舍
### 题目:

### 信息:
- **难度**:
- **重要性:** #★★★☆☆
### 思路1:
- 首先,这是选or不选的问题,对于第i个房子,若选,则第i-1个就不能选了;若不选,则可以选择第i-1个,故最终第i个房子就是取这两种情况的最大值,由此获得递归公式:`dfs(i) = Math.max(dfs(i-1),dfs(i-2)+nums[i])`.
- 然后就是采取缓存策略来避免重复计算,利用cache数组来保存已计算过的值,并在递归函数中进行判断,若已计算过,则直接返回结果.
![[Pasted image 20241013140923.png]]
### 代码1: 记忆化搜索+递归.
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    int[] nums;  
    int[] cache;  
  
    public int rob(int[] nums) {  
        int n = nums.length;  
  
        this.nums = nums;  
        this.cache = new int[n];  
        // 初始化为-1
        Arrays.fill(cache, -1);  
  
        return dfs(n-1);  
    }  
    int dfs(int n){  
        if (n < 0) return 0;  
        // 缓存策略,避免重复计算.
        if (cache[n] != -1) {  
            return cache[n];  
        }  
        int ans = Math.max(dfs(n - 1), dfs(n - 2) + nums[n]);  
        cache[n] = ans;  
        return ans;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```


### 思路2:
- 动态规划,递推的思路.从前往后逐次遍历,最终得到最后的结果.
### 代码2:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int rob(int[] nums) {  
        int n = nums.length;  
        // dp[i]表示第i间屋子时的最高金额.  
        int[] dp = new int[n+1];  
        dp[0] = 0;  
        dp[1] = nums[0];  
        for (int i = 2; i <= n; i++) {  
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]);  
        }  
        return dp[n];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)

```
### 代码3:进一步优化空间复杂度:
```java
class Solution {  
    public int rob(int[] nums) {  
        int n = nums.length;  
        int prev1 = nums[0]; // 上一个  
        int prev2 = 0; // 上上个  
        int ans = nums[0];  
        for (int i = 2; i <= n; i++) {  
            ans = Math.max(prev1,prev2+nums[i-1]);  
            prev2 = prev1;  
            prev1 = ans;  
        }  
        return ans;  
    }  
}  
```

## 494. 目标和
### 题目:
给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路1:
- 首先,所有整数的和为sum,假设添加`'+'`的整数的和为p,则添加`'-'`的和为`sum-p`.所以运算结果为`p-(sum-p)=target`,即`p=(sum+target)/2`!!! 转换为01背包的思路,就是价值要为`p`.
- 在代码上,当容量为0时,即代表一次成功方案,方案数+1. 若容量不为0,则继续递归,此时要判断第i个元素是否要选: 
	1) 若`nums[i]>c`,即代表`nums[i]`的值要大于剩余容量,肯定不能选,所以直接返回`dfs(i-1,c)`,即表示第i个不选,容量不变; 
	2) 若`nums[i]<=c`,则代表第i个元素,可以选,那么前i-1个元素的剩余容量就为`c-nums[i]`
### 代码1:递归写法
```java
class Solution {  
    int[] nums;  
    public int findTargetSumWays(int[] nums, int target) {  
        int n = nums.length;  
  
        this.nums = nums;  
  
        //  
        int sum = 0;  
        for (int num : nums){  
            sum += num;  
        }  
  
        target += sum;  
        // 如果target为奇数，那么需要nums中存在整数和为小数-> 不可能。  
        if (target < 0 || target % 2 != 0) return 0;  
  
        target /= 2;  
  
        return dfs(n-1,target);  
    }  
    int dfs(int i,int c){  
        if (i < 0) return c == 0 ? 1 : 0;  
        //if (c == 0) return 1;  // 条件符合  
  
        // nums[i]大于剩余容量，必不能选！  
        if (nums[i] > c) {  
            return dfs(i-1,c);  
        }  
        return dfs(i-1,c) + dfs(i-1,c-nums[i]);  
    }  
}  
```
### 思路2:

### 代码2: 使用动态规划递推.
```JAVA
class Solution {  
    public int findTargetSumWays(int[] nums, int target) {  
        int n = nums.length;  
  
        int sum = 0;  
        for (int num : nums) sum += num;  
        target += sum;  
        
        // 检查 target 是否有效  
        if (target < 0 || (target % 2) !=0) return 0;  
  
        target /= 2;  
  
        // i代表物品个数，j代表容量  
        int[][] dp = new int[n+1][target+1];  
        dp[0][0] = 1;  // 选0个物品组成容量0的方案有1种
        
        for (int i = 1; i <= n; i++) { // 遍历每个物品
            for (int j = 0; j <= target; j++) {  //遍历每个容量
                if (j < nums[i-1]){ //容量小于物品大小 不选  
                    dp[i][j] = dp[i-1][j];  
                }else{  
	                // 选择和不选择当前物品的方案数之和
                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];  
                }  
            }  
        }  
        return dp[n][target];  
    }  
}  
```
# 每日一题
## ==3171. 找到按位或最接近k的子数组==
### 题目:
给你一个数组 `nums` 和一个整数 `k` 。你需要找到 `nums` 的一个子数组,满足子数组中所有元素按位或运算 `OR` 的值与 `k` 的 **绝对差** 尽可能 **小** 。换言之，你需要选择一个子数组`nums[l..r]`满足`|k - (nums[l] OR nums[l + 1] ... OR nums[r])|` 最小。

请你返回 **最小** 的绝对差值。

**子数组** 是数组中连续的 **非空** 元素序列。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 对于数组中的元素，按位或运算具有单调性，即随着子数组的扩大，**按位或值不会减少，只会增加或保持不变**。通过维护一个当前可能的按位或值的集合，避免重复计算.
- **剪枝逻辑:**`(nums[j] | x) == nums[j]`, 此时x是`nums[j]`的子集,所以增加x不会增加OR运算的值,可以**跳过当前x**,进入下一次循环.
	- 注意遍历的顺序,当i增加时,在原有的遍历基础上多了个x,所以需要判断这个多出的x会不会对结果产生变化. 例如`[1,3,1,3]`,当i=2时,此时`nums[j]=1|3=011`,此时多了个`nums[2]=1`,不会对`nums[j]`造成影响,即`nums[j]|nums[2]==nums[j]`,所以可以跳过当前i=2.
### 代码:
```java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++){
            int x = nums[i];
            ans = Math.min(ans,Math.abs(x-k));
            // 当x是nums[j]的子集，就退出
            for (int j = i - 1; j >= 0;j--){
                 if ((nums[j] | x) == nums[j]) break;
                nums[j] |= x;
                ans = Math.min(ans,Math.abs(nums[j]-k));
            }
        }
        return ans;
    }
}

```


## 3164. 优质数对的总数II
### 题目:
给你两个整数数组 `nums1` 和 `nums2`，长度分别为 `n` 和 `m`。同时给你一个**正整数** `k`。

如果 `nums1[i]` 可以被 `nums2[j] * k` 整除，则称数对 `(i, j)` 为 **优质数对**（`0 <= i <= n - 1`, `0 <= j <= m - 1`）。

返回 **优质数对** 的总数。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★ 
### 思路:
- 使用枚举因子进行做题. 题目要求`nums1[i]%(nums2[j]*k) == 0`,即要求`nums[j]*k`是`nums[i]`的因子. 转换一下, 可以求`nums[i]/k`的因子,用Map进行存储. 最后遍历nums2中的元素,是因子,则总数增加.
- **优化思路:** 
	1) 加入`nums1[i]%k != 0`,此时`nums2[j]*k`也肯定不能被整除,可以跳过;
	2) 求因子的时候,只需要遍历到$\sqrt{x}$即可,然后再对应把(x/i)的因子数也+1.
### 关键点:
- 
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public long numberOfPairs(int[] nums1, int[] nums2, int k) {  
        Map<Integer,Integer> cnt = new HashMap<>();  
  
        for (int x : nums1){  
            if (x % k != 0) continue;  // 只考虑能被k整除的数  
            x /= k;  // 计算nums[i]/k的因子, 等效于计算nums1[i] / (nums2 * k)  
            for (int i = 1; i * i <= x; i++) { // 仅对/sqrt(x)遍历: 优化了时间复杂度  
                if (x % i > 0){     //不能整除,跳过.  
                    continue;  
                }  
                cnt.put(i,cnt.getOrDefault(i,0)+1);  // 因子计数  
                if (i * i != x){  // 避免因子重复计数.  
                    cnt.put(x/i,cnt.getOrDefault(x/i,0)+1);  
                }  
            }  
        }  
        long ans = 0;  
        for (int x : nums2){ // 如果是因子,则总数+cnt[x]  
            ans += cnt.getOrDefault(x, 0);  
        }  
        return ans;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 3158. 求出出现两次数字的异或值
### 题目:
给你一个数组 `nums` ，数组中的数字 **要么** 出现一次，**要么** 出现两次。

请你返回数组中所有出现两次数字的按位 `XOR` 值，如果没有数字出现过两次，返回 0 。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
- 使用Set保存出现过的数字,则若再出现的话,add操作返回值就会为false,此时就可以执行异或操作,得到返回值.
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int duplicateNumbersXOR(int[] nums) {  
        int n = nums.length;  
        int ans = 0;  
        Set<Integer> set = new HashSet<>();  
        for (int i = 0; i < n; i++) {  
            if (!set.add(nums[i])){  
                ans ^= nums[i];  
            }  
        }  
        return ans;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 1884. 鸡蛋掉落-两枚鸡蛋
### 题目:
给你 **2 枚相同** 的鸡蛋，和一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都 **会碎** ，从 **`f` 楼层或比它低** 的楼层落下的鸡蛋都 **不会碎** 。

每次操作，你可以取一枚 **没有碎** 的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路1:
- 从任意i楼扔下鸡蛋,都会存在两种情况:碎与不碎. 
	- 若碎了,则只剩一枚鸡蛋,故必须逐次从`1~(i-1)`遍历,保证鸡蛋不碎的情况下获得楼层f.
	- 若鸡蛋不碎,则继续从`i+1~n`重复上述步骤,也即子问题.
- 最终需要找到最小操作次数,
### 代码:
```java
class Solution {
    private static final int[] memo = new int[1001];
    public int twoEggDrop(int n) {
        if (n == 0) return 0;
        if (memo[n] != 0) return memo[n];

        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= n; i++){
            res = Math.min(res,Math.max(i,twoEggDrop(n-i)+1));
        }
        memo[n] = res;
        return res;
    }
}
```
## 3200. 三角形的最大高度
### 题目:
给你两个整数 `red` 和 `blue`，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。

每一行的球必须是 **相同** 颜色，且相邻行的颜色必须 **不同**。

返回可以实现的三角形的 **最大** 高度。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 循环放置小球,并利用`isRed`来判断此行该放红球还是该放蓝球.最后比较红球在第一行和蓝球在第一行时的高度,取最大值.
- 注意放置球中的`break`,这代表着某行应该放置红/蓝球,但是球不够了,此时就代表着放置结束,应该停止循环,返回最大高度.
### 代码:
```java
class Solution {  
    public int maxHeightOfTriangle(int red, int blue) {  
        return(Math.max(dfs(red,blue,true),dfs(red,blue,false)));  
    }  
  
    int dfs(int red, int blue,boolean isRed){  
        int i = 1;  
        int height = 0;  
        while (true){  
            if(isRed){  
                if (red >= i) {  
                    red -= i;  
                    height++;  
                } else {  
                    break;  
                }  
            }else {  
                if (blue >= i) {  
                    blue -= i;  
                    height++;  
                } else {  
                    break;  
                }  
            }  
            i++;  
            isRed = !isRed;  
        }  
        return height;  
    }  
}  
```
## 3191. 使二进制数组全部等于1的最少操作次数I
### 题目:
给你一个二进制数组 `nums` 。

你可以对数组执行以下操作 **任意** 次（也可以 0 次）：

- 选择数组中 **任意连续** 3 个元素，并将它们 **全部反转** 。

**反转** 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。

请你返回将 `nums` 中所有元素变为 1 的 **最少** 操作次数。如果无法全部变成 1 ，返回 -1 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 遇到0就执行反转操作,最多操作到`nums[n-3]`!题目要求剩余元素少于3个时不允许反转.
- 遇到0就反转,会让前n-3的元素都置为1,但是无法保证最后2个元素:即n-1与n-2,所以当他们任一为0时,代表操作失败.

>**问**：题目要求的「最少」体现在哪里？
 **答**：对同一个 i 至多操作一次，就可以做到最少的操作次数。

### 代码:
```java
class Solution {  
    public int minOperations(int[] nums) {  
        int ans = 0;  
        int n = nums.length;  
        for (int i = 0; i < n-2; i++) {  
            if (nums[i] == 0){  
                nums[i] ^= 1;  
                nums[i+1] ^= 1;  
                nums[i+2] ^= 1;  
                ans++;  
            }  
        }  
        return nums[n-1] == 0 || nums[n-2] == 0 ? -1 : ans;  
    }  
}
```

## 3192. 使二进制数组全部等于1的最少操作次数II
### 题目:
给你一个二进制数组 `nums` 。

你可以对数组执行以下操作 **任意** 次（也可以 0 次）：

- 选择数组中 **任意** 一个下标 `i` ，并将从下标 `i` 开始一直到数组末尾 **所有** 元素 **反转** 。

**反转** 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。

请你返回将 `nums` 中所有元素变为 1 的 **最少** 操作次数。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 仔细分析,需要反转的只有两种情况: 1)反转前为0; 2)反转后为0(反转前为1). 所以使用常见方法:**利用`flipped`异或来获取这两种情况.** (或者其实直接利用布尔值判断也可以)
- 利用flipped来判断是否反转(**逻辑反转**),而不是真的执行反转操作,这样可以降低时间复杂度.
### 代码:
```java hl:7
class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int ans = 0;
        int flipped = 0;
        for (int num : nums){
            if ((num ^ flipped) == 0) {
                ans++;
                flipped ^= 1;
            }
        }
        return ans;
    }
}
```

```java hl:7
class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int ans = 0;
        boolean flipped = false;
        for (int num : nums){
            if (num == 0 && flipped == false || num == 1 && flipped == true) {
                ans++;
                flipped = !flipped;
            }
        }
        return ans;
    }
}
```


## 908. 最小差值I
### 题目:
给你一个整数数组 `nums`，和一个整数 `k` 。

在一个操作中，您可以选择 `0 <= i < nums.length` 的任何索引 `i` 。将 `nums[i]` 改为 `nums[i] + x` ，其中 `x` 是一个范围为 `[-k, k]` 的任意整数。对于每个索引 `i` ，最多 **只能** 应用 **一次** 此操作。

`nums` 的 **分数** 是 `nums` 中最大和最小元素的差值。 

_在对  `nums` 中的每个索引最多应用一次上述操作后，返回 `nums` 的最低 **分数**_ 。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 获取的是修改后"最大"和"最小"元素的差值.所以存在两种情况:
	1) 修改前最大和最小元素的差值大于2k,此时`差值-2k`即为最终答案;
	2) 修改前最大和最小元素的差值小于2k,此时`差值-2k`可等于0.
### 代码:
```java
class Solution {
    public int smallestRangeI(int[] nums, int k) {
        int n = nums.length;
        if (n == 1) return 0;
        // 正序排列
        Arrays.sort(nums);
        if ((nums[n-1] - nums[0]) > (2*k)) return nums[n-1] - nums[0] - (2*k);
        else return 0;
    }
}
```
### 题解代码:
```java
class Solution {
    public int smallestRangeI(int[] nums, int k) {
        int n = nums.length;
        int max = Integer.MIN_VALUE,min = Integer.MAX_VALUE;
        for (int num : nums){
            max = Math.max(num,max);
            min = Math.min(num,min);
        }
        int diff = max - min;
        return diff >= 2*k ? (diff-2*k) : 0;
    }
}

```