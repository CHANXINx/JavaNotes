# 哈希表

## 242. 有效的字母异位词
### 题目:
- 给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。
- **字母异位词** 是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。
### 信息:
- **难度**:Easy
- **重要性:** #★★★☆☆
### 思路:
- 对题目进行简化:其实就是统计s中出现的次数及其次数,要求t中的字符均在s中使用过,并且使用次数要一致.
- 利用集合/数组存储字符串`s`的**出现的字符**及其**出现次数**,然后遍历字符`t`,判断t中的字符**是否均在存储s中的字符数组中**以及**t中的字符出现次数是否超出****.
- 因为小写字母一共只有26个,所以定义一个长度为26的数组一定满足条件!
### 关键点:
- 定义**长度为26**的数组存储**出现的字符及其使用次数.**
- 
### 代码:
```java
class Solution {  
    public boolean isAnagram(String s, String t) {  
        int[] record = new int[26];  
        if (s.length() != t.length())  
            return false;  
        for (int i = 0; i < s.length(); i++){  
            record[s.charAt(i) - 'a']++;  
        }  
        for (int j = 0; j < t.length(); j++){  
            record[t.charAt(j) - 'a']--;  
            if (record[t.charAt(j) - 'a'] < 0){  
                return false;  
            }  
        }  
        return true;  
    }  
}
```
## 349. 两个数组的交集
### 题目:
- 给定两个数组 `nums1` 和 `nums2`,返回它们的交集。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
### 信息:
- **难度**:
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路一:
- 利用Map存储nums1中的所有元素,其中key为nums1中的值,value任意(作为flag,之后在判断交集时使用).遍历nums2,判断nums2中的元素是否在Map出现过,若出现过,则将value置0,并且利用slow指针将该元素放置在nums2中.(slow指针肯定<=遍历nums2的指针)
#### 思路二:
- 利用set存储元素,set的特点是不会存储相同的元素,并且可以利用contains方法判断元素是否在set集合中.
### 关键点:
- 利用set集合不存储相同元素的特点.
### 代码:
#### 解法一:
- 利用Map来求解,可以但不是最优解.
```java
class Solution {  
    public int[] intersection(int[] nums1, int[] nums2) {  
        HashMap<Integer,Integer> map1 = new HashMap<>();  
        for (int i = 0; i < nums1.length; i++){  
            map1.put(nums1[i],1);  
        }  
        int slow = 0;  
        for (int j = 0; j < nums2.length; j++){  
            if (map1.get(nums2[j])== null){  
                continue;  
            }  
            if (map1.get(nums2[j]) != 0) {  
                nums2[slow] = nums2[j];  
                slow++;  
                map1.remove(nums2[j]);  
            }  
        }  
        if (slow != 0) {  
            nums1 = Arrays.copyOfRange(nums2,0,slow);  
            return nums1;  
        }else  
            return new int[0];  
    }  
}
```

## 202. 快乐数
### 题目:
- 编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
>难点在于 1)如何取出个,十,百位的数字; 2)在不是快乐数时,如何跳出循环.
- 1)取出各位数,可以定义函数(通用),i存储余数(i=n%10),并更新n的值(n=n/10),由于n是int类型,所以当**n<10时,n/10的结果为0**,所以可以利用这点作为循环条件,代码如下:
```java
	while (n != 0){  
//            保存余数  
		i = n % 10;  
//            利用集合/数组存储余数.
		map.put(count,i);  
		count++;  
//            保存整除结果  
		n = n / 10;  
	}  
```
- 2)跳出快乐数的循环,这里就与代码无关了,而是快乐数的定义.非快乐数,最终一定会出现相同的值,而快乐数最终结果会为1.但是如何判断是否重复,这也是个重点!利用HashSet<>不存储重复元素的特点以及contains方法实现.
### 关键点:
- 利用非快乐数的"平方和"的结果会重复出现作为跳出无限循环的条件.
### 代码:
#### 我的代码:
```java
class Solution {  
    public boolean isHappy(int n) {  
//    marked as function.  
        int res = n;  
        HashSet<Integer> set = new HashSet<>();  
        while (true) {  
            res = getResult(res);  
            if (res == 1) {  
                return true;  
            }  
            if (set.contains(res)) {  
                return false;  
            }  
            set.add(res);  
        }  
    }  
    public int getResult(int n){  
        HashMap<Integer,Integer> map = new HashMap<>();  
        int res = 0;  
        int i = 1;  
        int j = 1;  
        int count = 0;  
        //        取出个,十,百...  
        while (n != 0){  
//            保存余数  
            i = n % 10;  
            map.put(count,i);  
            count++;  
//            保存整除结果  
            n = n / 10;  
        }  
        for (int m = 0; m < count; m++){  
            res += (map.get(m) * map.get(m)) ;  
        }  
        return res;  
    }  
}
```

#### 官方解答
```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```

## 1. 两数之和
### 题目:
- 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_ 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
#### 思路1:
- 这题最简单的方法就是利用两个for循环实现!
#### 思路2:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public int[] twoSum(int[] nums, int target) {  
//        解法1: 使用数组遍历  
        int sum = 0;  
        for (int i = 0; i < nums.length - 1; i++)  
            for (int j = i+1; j < nums.length; j++){  
                sum = nums[i] + nums[j];  
                if (sum == target)  
                    return new int[]{i,j};  
            }  
        return null;  
```


## 454. 四数相加II

### 题目:
- 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
	- `0 <= i, j, k, l < n`
	- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
**别害怕遍历所有数组!**
- 首先是有四个数组,需要统计一共多少个满足条件的元组(即无需返回数组索引).利用Map的特性,将nums1和nums2的两数和作为key,将出现次数作为value.之后再遍历nums3和nums4,得到其和c+d,并利用containsKey判断满足`a+b=c+d`的key值是否存在.
### 关键点:
- 利用Map的key-value特性保存两数和及其出现次数,其实`int[]`也可以实现这个,但是数组需要先定义长度,这里的数组长度是不确定的,所以无法使用,故选用集合Map来实现!
- Map有两个方法很常用:
	- `containsKey(Object key)`:用于判断是否存在该key的映射;其实用`get(Object) == null`也可以替代,但是containsKey更高效,也更直观.
	- `getOrDefault(Object Key,V defaultValue)`:返回指定key映射到的值，如果此map不包含键的映射，则返回传入的`defaultValue`. 这个操作用来替代`nums[i]++;`:因为在Map中,若key对应的映射不存在时,无法进行自增操作;而利用`getOrDefault`可以在映射不存在时,赋值为0再进行自增.
### 代码:
```java
class Solution {  
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
        int count = 0;  
        HashMap<Integer, Integer> map1 = new HashMap<>();  
        for (int i : nums1) {  
            for (int j : nums2) {  
                map1.put(i+j,map1.getOrDefault(i+j, 0) + 1);  
            }  
        }  
//        ArrayList<Integer> sum2 = new ArrayList<>();  
        for(int i :nums3) {  
            for (int j : nums4) {  
//                a+b+c+d=0  
//                sum1存储了a+b,判断是0-(c+d)的值是否存在  
                if (map1.containsKey(-(i+j))) {  
                    count += map1.get(-(i+j));  
                }  
            }  
        }  
        return count;  
    }  
}
```

## 383. 赎金信
### 题目:
- 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- 利用数组作为哈希表,其中**索引**为字母的ASCII码,UNICODE码或者直接利用与'a'相减得到相对位置,即'a'的索引为0,'b'的索引为1...,**值**为出现次数.
### 关键点:
- 利用数组作为哈希表,思路更清晰,内存空间占用更少!
### 代码:
```java
class Solution {  
    public boolean canConstruct(String ransomNote, String magazine) {  
        if (ransomNote.length() > magazine.length())  
            return false;  
        int[] nums = new int[26];  
        for (int i = 0; i < magazine.length(); i++){  
            nums[magazine.charAt(i) - 'a']++;  
        }  
        for (int i = 0; i < ransomNote.length(); i++) {  
            if (nums[ransomNote.charAt(i) - 'a'] != 0) {  
                    nums[ransomNote.charAt(i) - 'a']--;  
            }else {  
                return false;  
            }  
        }  
        return true;  
    }  
}

```
## 15. 三数之和 
### 题目:
- 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
**注意：**答案中不可以包含重复的三元组。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- 将数组进行**排序**,利用双指针法!之后就是定义三个指针:i,j和k.i和j由左向右移动,k由右向左移动,移动逻辑如下:
	- 遍历i: `for(int i=0;i<nums.length-2;i++)`,判断`sum = nums[i]+nums[j]+nums[k]`: 1)`>0`,则此时k需要向左移动; 2)`<0`,则此时j需要向右移动(即增大sum); 3)`==0`,满足条件,将sum加入list中,并且j++,k--(`nums[j]`增大和`nums[k]`减小),并且需要进行去重操作:`nums[k/j] == nums[k-1/j+1]`,则多执行一次`k--/j++`.
### 关键点:
- 利用`Arrays.sort(nums)`将数组进行排序!
- **双指针法:对sum的值进行判断,然后决定移动哪个指针;**
- 去重操作,若`nums[i] == nums[i+1]`,则需额外移动一次指针.
### 代码:
```java
class Solution {  
    public List<List<Integer>> threeSum(int[] nums) {  
        List<List<Integer>> list = new ArrayList<>();  
        Arrays.sort(nums);  
//      若首个元素都为空,则直接返回!  
        if (nums[0] > 0 || nums.length < 3) return list;  
        int j = 0;  
        int k = nums.length - 1;  
        int sum = 0;  
        for (int i = 0; i < nums.length - 2; i++) {  
            j = i + 1;  
            k = nums.length - 1;  
  
            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a  
                continue;  
            }  
            while (j < k) {  
                sum = nums[i] + nums[j] + nums[k];  
                if (sum < 0) j++;  
                else if (sum > 0) k--;  
                else {  
                    list.add(Arrays.asList(nums[i], nums[j], nums[k]));  
                    while (k > j && nums[k] == nums[k - 1]) k--;  
                    while (k > j && nums[j] == nums[j + 1]) j++;  
                    j++;  
                    k--;  
                }  
            }  
        }  
        return list;  
    }  
}
```

## 18. 四数之和

### 题目:
给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 **任意顺序** 返回答案 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- 这题其实是和三数之和一种类型的题目,都是利用多指针法.其中i,j,m三个指针在左,k指针在右.先判断sum值:1)若大于target,则移动指针k; 2)若小于target,则移动指针m; 3)若等于,则`list.add`,并同时移动m和k.当`m>=k`时,此时就需要更新一次j,重复上述步骤;若遍历完所有j,则需要更新i了.即i是最外层循环,j是内层循环,而m和k是内内层循环.
- 去重操作,对于i的去重,`if (i > 0 && nums[i] == nums[i - 1]);`,总是迷惑是用`nums[i]==nums[i-1]`还是`nums[i]==nums[i+1]`,这样理解:**i是向右移动的**,所以先对i进行遍历,结束后i++,此时的`nums[i]和nums[i-1]`有可能重复,所以判断条件是`nums[i]==nums[i-1]`,若重复了,则跳过当前的i!
- 同理,对于k的去重,k是向左移动的,先使用当前的k,当k--后,判断`nums[k]==nums[k+1]`,若重复,则跳过当前k(即执行k--).
### 关键点:
- 多指针法!特别是指针k需要放在最右边!然后就是根据sum值的不同移动指针.
- **去重操作**是重点,要注意不同的条件,指针往右移动时,是使用`num[i]==nums[i-1]`;向左移动时,是使用`num[i]==nums[i+1]`,即判断当前值和前面使用过的值是否相等,相等则跳过!
- **剪枝操作**,即当满足一定条件时直接跳出循环,不执行多余的操作:
	- i循环的剪枝,当满足`nums[i]>0且nums[i]>target`时,此时往后的均是`大于0且大于nums[i]`的数,只会越来越大于target,故可直接返回list.
	- j循环的剪枝,当`nums[i]+nums[j] > 0 && nums[i]+nums[j] > target`时,
```
i循环的剪枝:

// nums[i] > target 直接返回, 剪枝操作
if (nums[i] > 0 && nums[i] > target) {
	return result;
}

j循环的剪枝:
//
if (nums[i]+nums[j] > 0 && nums[i]+nums[j] > target) {
	break;
}
```
### 代码:
```java
class Solution {  
    public List<List<Integer>> fourSum(int[] nums, int target) {  
        List<List<Integer>> list = new ArrayList<>();  
        Arrays.sort(nums);  
  
        if (nums.length < 4) return list;  
  
        int m = 0;  
        int k = nums.length - 1;  
//        int sum = 0;  
        for (int i = 0; i < nums.length - 3; i++) {  
            // nums[i] > target 直接返回, 剪枝操作  
            if (nums[i] > 0 && nums[i] > target) {  
                return list;  
            }  
            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a  
                continue;  
            }  
            for (int j = i + 1; j < nums.length - 2; j++){  
                if (nums[i]+nums[j] > 0 && nums[i]+nums[j] > target) {  
                    break;  
                }  
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; // 去重b  
                m = j + 1;  
                k = nums.length - 1;  
  
               while (m < k) {  
                   long sum =(long) nums[i] + nums[j] + nums[m] + nums[k];  
                   if (sum > target) k--;  
                   else if (sum < target) m++;  
                   else {  
                       list.add(Arrays.asList(nums[i], nums[j],nums[m],nums[k]));  
                       while (m < k && nums[k] == nums[k-1]) k--;  
                       while (m < k && nums[m] == nums[m+1]) m++;  
                       m++;  
                       k--;  
                   }  
               }  
           }  
        }  
        return list;  
    }  
}  
```
