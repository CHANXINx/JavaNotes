# 算法解题方法:
## 双指针法:

- 也叫快慢指针法,**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**
### 定义快慢指针
- 快指针：寻找新数组的元素,新数组就是不含有目标元素的数组
- 慢指针：指向**更新新数组**下标的位置
### 细分分类:
#### 滑动窗口:
[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
- 参考本题.利用fast指针遍历到最远处,取得满足sum>val的长度的数组,再移动slow指针,逐步缩小"窗口",以取得最小窗口.
- 
## 虚拟头结点:
- 虚拟头结点主要用于简化空指针时的边界条件处理,尤其是需要对头节点进行增删时!
	- 例如当`head==null`时,需要判断curr是否为空,才能使用边界条件`curr.next == null`进行判断.
	- 若使用`dummyHead`,则可统一写成`curr.next == null`进行边界条件的判断.因为在初始化时,不会出现`curr==null`的情况.

## ACM模式

## KMP算法:

## 单调队列:

## 递归法:
1. **确定递归函数的参数和返回值:** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数,并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。  
2. **确定终止条件:** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑:** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
---
# 数据结构及其常见库函数