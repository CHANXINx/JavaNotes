# 字符串
## 344. 反转字符串

### 题目:
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路:
- 双指针交换数组元素,利用中间变量temp保存交换元素.
### 关键点:
- 无.
### 代码:
```java
class Solution {  
    public void reverseString(char[] s) {  
        int left = 0;  
        int right = s.length - 1;  
        char temp;  
        while (left < right){  
            temp = s[right];  
            s[right] = s[left];  
            s[left] = temp;  
            left++;  
            right--;  
        }  
    }  
}
```

## 541. 反转字符串II
### 题目:
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- **理解题目:** 每2k个,反转前k个;若当出现剩下的字符长度<k,则全部反转;若剩下的字符>=k,但<2k,则依旧反转前k个.
- 定义index变量,用于判断剩余字符串属于上述哪种类型,不同类型执行不同的反转操作.最终代码如下.每次执行反转操作后,都需要更新index!
### 关键点:
- 思路很清晰,重点是代码如何操作!还有就是减少冗余.
- **每2k个翻转前k个,若剩余字符小于2k,但大于k,仍翻转前k个**,所以这两者的右指针其实是一样的;若剩余字符小于k个,则此时右指针会不同,但翻转逻辑仍是一样的.
### 代码:
#### 版本一:(冗余度高)
```java
class Solution {  
    public String reverseStr(String s, int k) {  
        int index = 0;  
        char temp;  
        char[] s1 = s.toCharArray();  
        while ((s.length()-index) > 0){  
        // 1和2内的for循环逻辑是相同的,可以合并!
            1:if ((s.length() - index) > 2*k) {  
                for (int i = index, j = index+k-1; i < j; i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }2:else if ((s.length() - index > k)){  
                for (int i = index, j = index+k-1; i < j;i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }else {  
            // 逻辑与上面也相同,但是右指针不一样!想办法根据不同条件获得不同右指针.
                for (int i = index, j = s.length()-1; i < j;i++,j--){  
                    temp = s1[j];  
                    s1[j] = s1[i];  
                    s1[i] = temp;  
                }  
            }  
            index = index + 2*k;  
        }  
        return String.valueOf(s1);  
    }  
}  
```
#### 版本二:(优化后)
##### 优化思路:
1. 首先,上面的if和else-if是一样的逻辑,所以首先合并了;
2. if和else的交换逻辑也是一样的,**只是右指针不同**,所以这里可以利用`Math.min()`函数来判断j取`index+k-1`还是`s.length()-1`,即**若剩余字符小于k时,此时`s.length()-1`肯定小于`index+k-1`**,故取min值是正确且合理的.
```java
class Solution {  
    public String reverseStr(String s, int k) {  
        int index = 0;  
        char[] s1 = s.toCharArray();  
        // 只要还剩余字符,就需要交换!
        while ((s.length()-index) > 0){  
            int i = index;  
            // 取min值,避免右指针越界了!
			// s.length()-1代表着剩余字符少于k,全翻转;
			// index+k-1,代表着剩余字符大于k,翻转前k个.
            int j = Math.min(index + k - 1, s.length() - 1);  
            while(i<j){  
                char temp = s1[j];  
                s1[j] = s1[i];  
                s1[i] = temp;  
                i++;
                j--;
            }  
            index = index + 2*k;  
        }  
        return String.valueOf(s1);  
    }  
} 
```

## 54. 替换数字（卡码网）
### 题目:
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。
**输入描述**
输入一个字符串 s,s 仅包含小写字母和数字字符。
**输出描述**
打印一个新的字符串，其中每个数字字符都被替换为了number
### 信息:
- **难度**: null
- **重要性:** #★★★☆☆
### 思路:
- 由于String的不可变性,所以此处应该使用StringBuilder来输出结果.
- 利用`Character.isDigit(char c)`来判断当前字符是否为数字,若为数字,则`res.append("number")`;若非数字,则`res.append("currChar")`
- **在不需要获取索引时,可以使用增强for循环!**
### 关键点:
- 1)利用好StringBuilder的可变性; 
- 2)利用append函数在可变字符串尾部添加字符(串);
- 3)利用`Character.isDigit()`判断是否为数字.
### 代码:
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
		// 获取输入.
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        // 操作逻辑.
        StringBuilder result = new StringBuilder();
        for(char c : s.toCharArray()){
            if (Character.isDigit(c)){
                result.append("number");
            }else{
                result.append(c);
            } 
        }
        //输出结果.
        System.out.println(result.toString());
    }
}

```


## 151. 反转字符串中的单词
### 题目:
给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：** 输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
#### 思路一:
- 最简单的想法,利用java的String库函数,例如trim,split函数.这样使得这题过于简单,无意义.
#### 思路二:
- 定义双指针,碰到非空格,就定住慢指针,快指针寻找空格,找到了,就取之间的单词,使用append函数添加到sb中.同时,为了保证能找到开头的单词,额外添加了" ", 这样就能保证快指针一定能寻找到开头的空格了.
#### 思路三:
- 
### 关键点:
- 
### 代码:
```java
class Solution {  
    public String reverseWords(String s) {  
        StringBuilder sb = new StringBuilder();  
        // 保证能取到开头的单词!
        s = " ".concat(s);  
        char[] c1 = s.toCharArray();  
  
        int fast = 0;  
  
        for (int i = c1.length - 1; i >= 0; i--){  
            if (c1[i] != ' ') {  
                for (int j = i; j >= 0; j--) {  
                    if (c1[j-1] == ' ') {  
                    // 取非' '和' '之间的单词. 
                        sb.append(s.substring(j, i + 1)+' ');  
                        i = j;  
                        break;  
                    }  
                }  
            }  
        }  
        return sb.substring(0,sb.length()-1);  
    }  
}
```
## 55. 右旋字符串
### 题目:
字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。
### 信息:
- **难度**: null
- **重要性:** #★★☆☆☆
### 思路:
- 利用subString获得后k位和前k位,再利用+来拼接字符串.
### 关键点:
- 
### 代码:
```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        String s = scanner.next();
        
        int sLen = s.length();
        String sub1 = s.substring(sLen-k,sLen);
        String sub2 = s.substring(0,sLen-k);
        System.out.println(sub1+sub2);
    }
}
```
## 28. 找出字符串中第一个匹配项的下标
### 题目:
给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
#### 思路一:
- 暴力解法,判断所有与needle长度相同的字符串是否与needle匹配,是则返回下标.
#### 思路二:
- 思路类似,不过通过增加限制来减少匹配次数,即降低了时间复杂度. 1)若needle长度>haystack长度,不可能匹配,直接返回; 2)只有当haystack中的某个字母与needle的首字母相同时,才开始匹配操作; 3)循环i的判断不用到`<haystack.length()`,小于`haystack.length()-needle.length()`即可.易理解,在这之后的匹配并无意义,因为剩余字符串的长度小于needle的长度.
#### 思路三:
- KMP算法?
### 关键点:
- 多添加进行循环匹配的限制条件!
### 代码:
```java
class Solution {  
    public int strStr(String haystack, String needle) {  
        int hLen = haystack.length();  
        int nLen = needle.length();  
        // needle字符串更长,不可能匹配,直接返回!
        if (nLen > hLen) return -1;  
        for (int i = 0; i <= hLen-nLen;i++){ 
        // 首字母相同才进行匹配! 
            if (haystack.charAt(i) == needle.charAt(0)) {  
                    int end = nLen;  
                    String str = haystack.substring(i,end+i);  
                    if (str.equals(needle))  
                        return i;  
            }  
        }  
        return -1;  
    }  
}
```
#### 优化:
- 使用滑动窗口优化subString.当`charAt(i+j)==charAt(j)`,即代表当前首字母相同,开始滑动,即j++.此时窗口逐步增大,即while中逐个判断字符是否相等,当`j==nLen`,代表窗口长度等于needle字符串长度,即此时二者匹配!
```java
for (int i = 0; i <= hLen - nLen; i++) { 
	// 检查 haystack 从 i 开始的子串是否与 needle 相等
	int j = 0; 
	while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {
		j++; 
	} 
	if (j == nLen) return i; // 找到匹配 
	}
```
## 459. 重复的子字符串
### 题目:
给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 能由子串重复构成,代表必定存在`s.charAt(i)==s.charAt(0)`.取该子串,并对剩余字符串进行判断即可.
### 关键点:
- **能由子串重复构成,代表必定存在`s.charAt(i)==s.charAt(0)`.**
### 代码:
```java
class Solution {  
    public boolean repeatedSubstringPattern(String s) {  
        int sLen = s.length();
        // i循环条件: 剩余字符串长度应大于等于重复子串长度->i <= sLen/2
        for (int i = 1;(sLen - (i)) >= (i) ; i++){
	        // 判断是否存在首字母相同,即可能重复的子字符串.
            if (s.charAt(i) == s.charAt(0)){  
	            // 取重复子串.
                String sub = s.substring(0,i);  
                int subLen = i;  
                int j = i;  
				// 先判断是否剩余字符串长度大于重复子串.
				// 若大于,则判断接下来相同长度的子串是否跟重复子串匹配.
                while ((sLen - j + 1) >= subLen && s.substring(j,j+subLen).equals(sub)){  
                    j += subLen;  
                    // j能等于sLen,说明一直是匹配的.
                    if (j == sLen) return true;  
                }  
            }  
        }  
        return false;  
    }  
}
```