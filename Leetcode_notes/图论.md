## 图论理论基础:
### 图的概念:
图可分为无向图,有向图,无向加权图,有向加权图.

#### 度:
对于无向图,度的概念为该节点连接的边数.

对于有向图,度可分为入度和出度
	● 入度:指向该节点的边数;
	● 出度:该节点出发的边数.

#### 连通性:
连通性表示节点的连通情况.

连通图: 指的是"不存在某个节点,无法到达其他节点".

强连通图: **任意两个**节点都是可以相互到达的.

连通分量: 指的是图中的极大连通子图.

强连通分量: 有向图中极大**强连通子图**.

### 图的构造:

一般使用邻接矩阵,邻接表或者类来表示图.

#### 邻接矩阵:
已知:
对于节点数为n的无向图,最大边数为$\frac{n\times(n-1)}{2}$.

故假设节点数为8,则最大边数为28.

邻接矩阵使用**二维数组**来表示图结构. 邻接矩阵是从节点的角度来表示图, **有多少节点就申请多大的二维数组.**
例如,对于节点n=8,则申请8×8的二维数组,此时`grid[2][5]`表示节点2与节点5连通.


邻接矩阵的优点：
- 表达方式简单，易于理解
- 检查任意两个顶点间是否存在边的操作非常快
- 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

缺点：
- 遇到稀疏图，会导致申请过大的二维数组**造成空间浪费** 且遍历`边`的时候需要遍历整个`n * n`矩阵，造成时间浪费

#### 邻接表:
邻接表使用`数组 + 链表`的方式来表示. 邻接表是从边的数量来表示图，**有多少边才会申请对应大小的链表**。

例如:
- 节点1 指向 节点3 和 节点5
- 节点2 指向 节点4、节点3、节点5
- 节点3 指向 节点4
- 节点4指向节点1
![[Pasted image 20241029100431.png|450]]

邻接表的优点：
- 对于稀疏图的存储，只需要存储边，空间利用率高
- 遍历节点连接情况相对容易

缺点：
- 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
- 实现相对复杂，不易理解

### 图的遍历方法:
深度优先搜索dfs和广度优先搜索bfs.

## 779./LCR100. 所有可能的路径
### 题目:
给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

`graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 深度优先遍历典型题目,套用模板即可,注意几个关键点:
	- `graph[node]`代表的是节点node所以可能到达的路径.
	- 求解的是到达节点n-1的所有路径,所以递归返回条件即为(`currNode == graph.length-1`).
	- 遍历时,利用foreach循环遍历当前节点所有可能到达的地方,并且在遍历完要"清除现场".
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    List<List<Integer>> ans = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    int[][] graph;  
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {  
        this.graph = graph;  
        path.add(0);  
        dfs(0);  
        return ans;  
    }  
  
    void dfs(int currNode){  
        // 遍历到目标节点（n-1）  
        if (currNode == (graph.length - 1)){  
            ans.add(new ArrayList<>(path));  
            return;  
        }  
        // 遍历当前节点可到达的节点  
        for (int to : graph[currNode]){  
            path.add(to);  
            dfs(to);  
            path.remove(path.size()-1);  
        }  
    }  
}  
```












## 并查集理论介绍

并查集通常用来解决连通问题,即判断两个元素是否在同一集合内.

### 并查集方法介绍:
#### 初始化:
```java
void init(){
	for (int i = 0; i < n; i++){
		father[i] = i;
	}
}
```
#### 寻根:
- 找到节点u的根节点.
```java
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
```

```java
// 返回x的根节点:parent[i] == i;  
int find(int u){  
    while (father[u] != u){  
        u = father[u];  
    }  
    return u;  
}
```
例如,利用`join(1,3)`连接节点1和节点3,此时有`father[3]=1`,`father[1]=1`.此时调用find(3),有
```java
find(3) -> father[3]= 1 != 3 ->
find(1) -> father[1]= 1 == 1, 满足条件,返回1.
```
#### 同根判断:
```java
boolean isSame(int u,int v){
	u = find(v);
	v = find(v);
	return u == v;
}
```

#### 连接:
```java
void join(int u,int v){
	u = find(u);
	v = find(v);
	if (u == v) return;
	father[v] = u;
}
```
若调用`join(1,3)`得到`father[3]=1`,调用`join(2,3)`:
```java
u = find(2) -> u = 2;
v = find(3) -> v = 1;

=> father[1] = 2;
```
![[Pasted image 20241028225216.png]]

此时调用`find(3)`查找节点3的根节点:
```java
1.find(u=3):
father[3] = 1 != 3 

2.find(u=1):
father[1] = 2 != 1

3.find(u=2):
father[2] = 2 == 2, 返回结果2.

```



## 冗余连接II 
### 题目:
在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 待删除的就三种情况:
	- 1)入度为2,此时删除靠后的边; 2)入度为2,删除造成有向环的边; 3)入度为1,删除成环的边.![[Pasted image 20241029002205.png]]
### 代码:(GPT4给出的最优解)
```java
public int[] findRedundantDirectedConnection(int[][] edges) {
        int nodesCount = edges.length;
        int[] parent = new int[nodesCount + 1];
        int[] cand1 = null;
        int[] cand2 = null;

        // 初始化每个节点的父节点为自身
        for (int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }

        // Step 1: 检查是否存在入度为2的节点
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            if (parent[v] != v) {
                // 发现入度为2的节点，记录两条边
                cand1 = new int[]{parent[v], v};
                cand2 = new int[]{u, v};
                // 临时移除当前边
                edge[1] = 0;
            } else {
                parent[v] = u;
            }
        }

        // 重新初始化并查集
        for (int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }

        // Step 2: 检查是否存在环
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            if (v == 0) {
                continue; // 跳过被移除的边
            }
            int pu = find(parent, u);
            if (pu == v) {
                // 发现环
                if (cand1 != null) {
                    // 如果存在入度为2的节点，返回候选边1
                    return cand1;
                }
                // 否则，返回当前边
                return edge;
            }
            parent[v] = pu;
        }

        // 如果没有发现环，返回候选边2
        return cand2;
    }

    // 并查集中的查找操作（路径压缩）
    private int find(int[] parent, int node) {
        if (parent[node] != node) {
            parent[node] = find(parent, parent[node]);
        }
        return parent[node];
    }

```
