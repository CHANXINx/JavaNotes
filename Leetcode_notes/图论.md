## 图论理论基础:
### 图的概念:
图可分为无向图,有向图,无向加权图,有向加权图.

#### 度:
对于无向图,度的概念为该节点连接的边数.

对于有向图,度可分为入度和出度
	● 入度:指向该节点的边数;
	● 出度:该节点出发的边数.

#### 连通性:
连通性表示节点的连通情况.

连通图: 指的是"不存在某个节点,无法到达其他节点".

强连通图: **任意两个**节点都是可以相互到达的.

连通分量: 指的是图中的极大连通子图.

强连通分量: 有向图中极大**强连通子图**.

### 图的构造:

一般使用邻接矩阵,邻接表或者类来表示图.

#### 邻接矩阵:
已知:
对于节点数为n的无向图,最大边数为$\frac{n\times(n-1)}{2}$.

故假设节点数为8,则最大边数为28.

邻接矩阵使用**二维数组**来表示图结构. 邻接矩阵是从节点的角度来表示图, **有多少节点就申请多大的二维数组.**
例如,对于节点n=8,则申请8×8的二维数组,此时`grid[2][5]`表示节点2与节点5连通.


邻接矩阵的优点：
- 表达方式简单，易于理解
- 检查任意两个顶点间是否存在边的操作非常快
- 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

缺点：
- 遇到稀疏图，会导致申请过大的二维数组**造成空间浪费** 且遍历`边`的时候需要遍历整个`n * n`矩阵，造成时间浪费

#### 邻接表:
邻接表使用`数组 + 链表`的方式来表示. 邻接表是从边的数量来表示图，**有多少边才会申请对应大小的链表**。

例如:
- 节点1 指向 节点3 和 节点5
- 节点2 指向 节点4、节点3、节点5
- 节点3 指向 节点4
- 节点4指向节点1
![[Pasted image 20241029100431.png|450]]

邻接表的优点：
- 对于稀疏图的存储，只需要存储边，空间利用率高
- 遍历节点连接情况相对容易

缺点：
- 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
- 实现相对复杂，不易理解

### 图的遍历方法:
深度优先搜索dfs和广度优先搜索bfs.

## 779./LCR100. 所有可能的路径
### 题目:
给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

`graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 深度优先遍历典型题目,套用模板即可,注意几个关键点:
	- `graph[node]`代表的是节点node所以可能到达的路径.
	- 求解的是到达节点n-1的所有路径,所以递归返回条件即为(`currNode == graph.length-1`).
	- 遍历时,利用foreach循环遍历当前节点所有可能到达的地方,并且在遍历完要"清除现场".
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    List<List<Integer>> ans = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    int[][] graph;  
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {  
        this.graph = graph;  
        path.add(0);  
        dfs(0);  
        return ans;  
    }  
  
    void dfs(int currNode){  
        // 遍历到目标节点（n-1）  
        if (currNode == (graph.length - 1)){  
            ans.add(new ArrayList<>(path));  
            return;  
        }  
        // 遍历当前节点可到达的节点  
        for (int to : graph[currNode]){  
            path.add(to);  
            dfs(to);  
            path.remove(path.size()-1);  
        }  
    }  
}  
```

## 岛屿问题
>[[#200. 岛屿数量]]

岛屿问题是一个图问题，grid网格就可视为各节点连通的图，一般都采用深度优先搜索遍历，可被分类为**网格类DFS问题**。
![[Pasted image 20241109100321.png|200]]

基本dfs框架为：
1. 可采用“先污染，再治理”的手段:
```java
// 该形参可视为网格的节点
void(int) dfs(int[][] grid,int x,int y){
// 返回条件为：超过边界、已遍历过或者非岛屿
	if ((x >= m || x < 0 || y >= n || y < 0 || grid[x][y] != '1')
		return;
		
	//标记节点，代表已遍历
	grid[x][y] = 2; 	
		
	// 遍历四个方向
	dfs(grid,x+1,y);
	dfs(grid,x-1,y);
	dfs(grid,x,y+1);
	dfs(grid,x,y-1);
}		
```

2. 也采用方向数组来表示遍历方向:
```java
private static final int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
void(int) dfs(int[][] grid,int x,int y){
	if ((x >= m || x < 0 || y >= n || y < 0 || grid[x][y] != '1')
		return;
		
	for (int[] dir : DIRS){
		nx = x + dir{0};
		ny = y + dir{1};
		dfs(grid,nx,ny);
	}
}
```

## 200. 岛屿数量
### 题目:
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 每次递归都会把连通的岛屿标记，这样之后的遍历就不会再遍历到该节点了。 main方法中的`dfs(grid,i,j)`的每次调用都会标记一个岛屿，所以调用一次，ans+1.
### 代码:
```java
class Solution {
    static int n;
    static int m;
    public int numIslands(char[][] grid) {
        n = grid.length;
        m = grid[0].length;
        int ans = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == '1') { // 找到了一个新的岛
                    dfs(grid, i, j); // 把这个岛插满旗子，这样后面遍历到的 '1' 一定是新的岛
                    ans++;
                }
            }
        }
        return ans;
    }
    // 遍历图: h表示水平方向，v表示垂直方向
    static void dfs(char[][] grid,int h,int v){
    // 判断是否是岛屿或是否越界
    if (h >= n || h < 0 || v >= m || v < 0 || grid[h][v] != '1'){
        return; 
    }  
    // 插旗。
    grid[h][v] = '2';

    // 向右
    dfs(grid,h+1,v);
    // 向左
    dfs(grid,h-1,v);
    // 向上
    dfs(grid,h,v+1);
    // 向下
    dfs(grid,h,v-1);
    }
}
```

## 463. 岛屿的周长
### 题目:
给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。

网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。![[Pasted image 20241109102610.png]]
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 可以采用dfs的方法来做： 以上图为例，**水面是会被重复遍历的**，所以遍历1次周长+1即可
	- 若陆地与水面接壤，则周长+1；
	- 若陆地与边界接壤，则周长+1；
	- 若陆地与陆地接壤，则不增加周长.
![[Pasted image 20241109104055.png|300]]
- 还可以采用数学方法1来做，若遇到陆地，则判断四个方向的情况：若为水面或者超出边界，则周长+1；若为陆地，则周长不改变。
- 数学方法2：遍历到陆地，则直接周长+4，若遇到土地接壤，则减掉2个边长，避免重复遍历，所以只需判断右侧和下侧是否为土地。
### 代码:
```java
class Solution {
    private static int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int m,n;
    int ans = 0;
    public int islandPerimeter(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    ans += dfs(grid,i,j);
                }
            }
        }
        return ans;

    }
    // 参数为遍历节点的索引
    int dfs(int[][] grid,int x, int y){
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0){
            return 1;
        }
        if (grid[x][y] == 2){
            return 0;
        }

        grid[x][y] = 2;
        int tmp = 0;
        for (int[] dir : DIRS){
            int nx = x + dir[0];
            int ny = y + dir[1];
            tmp += dfs(grid,nx,ny);
        }
        return tmp;
    }
}
```

### 数学解法:
```java
class Solution {
    private static int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int m,n;
    int ans = 0;
    public int islandPerimeter(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        int perimeter = 0;

        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    // // 检查四个方向
                    // if (i == 0 || grid[i - 1][j] == 0) perimeter++; // 上
                    // if (i == m - 1 || grid[i + 1][j] == 0) perimeter++; // 下
                    // if (j == 0 || grid[i][j - 1] == 0) perimeter++; // 左
                    // if (j == n - 1 || grid[i][j + 1] == 0) perimeter++; // 右
                    
					perimeter += 4;
                    if (j+1 < n && grid[i][j+1] == 1) perimeter -= 2;
                    if (i+1 < m && grid[i+1][j] == 1) perimeter -= 2;
                }
            }
        }
        return perimeter;
    }
}
```

## [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/) 
### 题目: 
给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆ 
### 思路:
- 依旧是dfs，不过需要有返回值，每次递归都返回`当前陆地+四个方向的面积`.
### 代码:
```java
class Solution {
    int n;
    int m;
    public int maxAreaOfIsland(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        int ans = 0;
        for (int i = 0;i < n; i++){
            for (int j = 0;j < m;j++){
                if(grid[i][j] == 1){
                    ans = Math.max(ans,dfs(grid,i,j));
                }
            }
        }
        return ans;

    }
    int dfs(int[][] grid,int x,int y){
        // 边界
        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] != 1){
            return 0;
        }
        // 标记已遍历岛屿
        grid[x][y] = 2;

        // 当前岛屿的面积
        int count = 1;

        int up = dfs(grid,x+1,y);
        int down = dfs(grid,x-1,y);
        int right = dfs(grid,x,y+1);
        int left = dfs(grid,x,y-1);

        return count+(up+down+right+left);
    }
}
```

## [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/) 
### 题目:
给你一个大小为 `n x n` 二进制矩阵 `grid` 。**最多** 只能将一格 `0` 变成 `1` 。

返回执行此操作后，`grid` 中最大的岛屿面积是多少？

**岛屿** 由一组上、下、左、右四个方向相连的 `1` 形成。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 需要两次遍历：
	- 第一次遍历保存每个岛屿的面积以及编号。为了避免重复以及与0,1区分开，将编号设置为岛屿数量+2，例如岛屿1的编号为2，岛屿2的编号为3.
	- 第二次遍历用于填充海面，获取填充后的最大值，具体实现为：
		- 碰到海面，判断四个方向是否为岛屿，若为岛屿则累加面积。为了避免重复添加相同岛屿，可通过定义一个Set集合来实现，若`Set.add()`成功，说明并未添加重复岛屿。
		  ![[Pasted image 20241109112429.png|400]]
- 特判全0的情况，`return ans == 0 ? n*n : ans;`，处理grid全为1则ans不更新的情况。
### 代码:
```java
class Solution {
    int m,n;
    int[][] DIRS = {{1,0},{-1,0},{0,1},{0,-1}};
    public int largestIsland(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        List<Integer> areas = new ArrayList<>();
        for (int i = 0;i < m;i++){
            for(int j = 0;j < n;j++){
                if (grid[i][j] == 1){
                    areas.add(dfs(grid,i,j,areas.size()+2));
                }
            }
        }
        int ans = 0;
        int newArea = 1; // 初始化为填充后面积
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < m; i++){
            for(int j = 0; j < n;j++){
                // set用来保存每个海面四周的面积情况，所以需要情况
                set.clear();
                newArea = 1;
                // 遇到海面，遍历四个方向
                if (grid[i][j] != 0) {
                    continue;
                }
                for (int[] dir : DIRS){
                    int x = i + dir[0];
                    int y = j + dir[1];
                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != 0){
                        // 将编号加入set中
                        if(set.add(grid[x][y])){
                            // set成功才累加面积，避免重复添加（面积通过(编号-2)得到）
                            newArea += areas.get(grid[x][y]-2);
                        }
                    }
                }
                // if (set.size()==0) continue;
                ans = Math.max(ans,newArea);
            }
        }
        return ans == 0 ? n*n : ans;
    }
    int dfs(int[][] grid,int x, int y,int id){
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1){
            return 0;
        }
        grid[x][y] = id;
        int area = 1;
        for (int[] dir : DIRS){
            int nx = x + dir[0];
            int ny = y + dir[1];
            area += dfs(grid,nx,ny,id);
        }

        return area;
    }
}
```

## 并查集理论介绍

并查集通常用来解决连通问题,即判断两个元素是否在同一集合内.

### 并查集方法介绍:
#### 初始化:
```java
void init(){
	for (int i = 0; i < n; i++){
		father[i] = i;
	}
}
```
#### 寻根:
- 找到节点u的根节点.
```java
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
```

```java
// 返回x的根节点:parent[i] == i;  
int find(int u){  
    while (father[u] != u){  
        u = father[u];  
    }  
    return u;  
}
```
例如,利用`join(1,3)`连接节点1和节点3,此时有`father[3]=1`,`father[1]=1`.此时调用find(3),有
```java
find(3) -> father[3]= 1 != 3 ->
find(1) -> father[1]= 1 == 1, 满足条件,返回1.
```
#### 同根判断:
```java
boolean isSame(int u,int v){
	u = find(v);
	v = find(v);
	return u == v;
}
```

#### 连接:
```java
void join(int u,int v){
	u = find(u);
	v = find(v);
	if (u == v) return;
	father[v] = u;
}
```
若调用`join(1,3)`得到`father[3]=1`,调用`join(2,3)`:
```java
u = find(2) -> u = 2;
v = find(3) -> v = 1;

=> father[1] = 2;
```
![[Pasted image 20241028225216.png]]

此时调用`find(3)`查找节点3的根节点:
```java
1.find(u=3):
father[3] = 1 != 3 

2.find(u=1):
father[1] = 2 != 1

3.find(u=2):
father[2] = 2 == 2, 返回结果2.

```



## 冗余连接II 
### 题目:
在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 待删除的就三种情况:
	- 1)入度为2,此时删除靠后的边; 2)入度为2,删除造成有向环的边; 3)入度为1,删除成环的边.![[Pasted image 20241029002205.png]]
### 代码:(GPT4给出的最优解)
```java
public int[] findRedundantDirectedConnection(int[][] edges) {
        int nodesCount = edges.length;
        int[] parent = new int[nodesCount + 1];
        int[] cand1 = null;
        int[] cand2 = null;

        // 初始化每个节点的父节点为自身
        for (int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }

        // Step 1: 检查是否存在入度为2的节点
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            if (parent[v] != v) {
                // 发现入度为2的节点，记录两条边
                cand1 = new int[]{parent[v], v};
                cand2 = new int[]{u, v};
                // 临时移除当前边
                edge[1] = 0;
            } else {
                parent[v] = u;
            }
        }

        // 重新初始化并查集
        for (int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }

        // Step 2: 检查是否存在环
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            if (v == 0) {
                continue; // 跳过被移除的边
            }
            int pu = find(parent, u);
            if (pu == v) {
                // 发现环
                if (cand1 != null) {
                    // 如果存在入度为2的节点，返回候选边1
                    return cand1;
                }
                // 否则，返回当前边
                return edge;
            }
            parent[v] = pu;
        }

        // 如果没有发现环，返回候选边2
        return cand2;
    }

    // 并查集中的查找操作（路径压缩）
    private int find(int[] parent, int node) {
        if (parent[node] != node) {
            parent[node] = find(parent, parent[node]);
        }
        return parent[node];
    }

```
