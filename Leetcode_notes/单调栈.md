## 适用范围:
**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置.**


## 42. 接雨水
### 题目:
给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。![[Pasted image 20241026105028.png]]
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- **单调栈解法:** 将高度入栈,若遇到低的,则弹出,计算高度差之间的雨水体积。
![[Pasted image 20241026105809.png]]
![[Pasted image 20241026114430.png]]
### 代码:
```java
public int trap(int[] height) {  
    Deque<Integer> st = new ArrayDeque<>();  
    int n = height.length;  
    int ans = 0;  
    for (int i = 0; i < n; i++) {  
        while (!st.isEmpty() && height[i] >= height[st.peek()]){  
            int bottomH = height[st.pop()];  
            if (st.isEmpty()){  
                break;  
            }  
            int left = st.peek();  
            // 高  
            int dh = Math.min(height[left],height[i]) - bottomH;  
            ans += dh * (i-left-1);  
        }  
        st.push(i);  
    }  
    return ans;  
}
```

## 84. 柱状图中的最大矩形 
### 题目:
给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 计算以每个柱子作为高度的最大面积!故,需要找到柱子左右两端比他低的柱子,这就是高度.
  ![[Pasted image 20241026144606.png]]
- 转换思路后,难点在于如何求解每个柱子左右的低柱子!
	- 栈中不会存储比`heights[i]`更低的元素! 假设遍历到`heights[4]=2`,则此时`heights[0]`肯定不在栈中,因为右侧有`heights[i]=1`比他小,所以`heights[2]`会被弹出.
	- **对于左侧:** 利用栈存储元素,若`heights[m]`小于栈顶元素,则持续弹出,直到`heights[m]`能成为栈中最小的元素,这样就能保证栈顶能为柱子i的左侧第一个比他小的元素.
	- **对于右侧:** 从右往左遍历,也是遇到比`heights[m]`小的元素
### 代码:
```java
public int largestRectangleArea(int[] heights) {  
    //思路：计算以每个i作为最高点的面积  
    Deque<Integer> st = new ArrayDeque<>();  
    int n = heights.length;  
    // 存放i左边的“最远”元素  
    int[] left = new int[n];  
  
    for (int i = 0; i < n; i++) {  
        int x = heights[i];  
        while (!st.isEmpty() && x <= heights[st.peek()]){  
            st.pop();  
        }  
        // 边界的特殊处理  
        left[i] = st.isEmpty() ? -1 : st.peek();  
        st.push(i);  
    }  
    st.clear();  
    // 存放i右边最远的元素  
    int[] right = new int[n];  
    for (int i = n-1; i >= 0 ; i--) {  
        int x = heights[i];  
        while (!st.isEmpty() && x <= heights[st.peek()]){  
            st.pop();  
        }  
        right[i] = st.isEmpty() ? n : st.peek();  
        st.push(i);  
    }  
    int ans = 0;  
    for (int i = 0; i < n; i++) {  
        ans = Math.max(heights[i] * (right[i] - left[i] - 1),ans);  
    }  
    return ans;  
}

```
