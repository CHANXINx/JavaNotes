如果某一问题有很多重叠子问题，使用动态规划是最有效的。
所以动态规划中**每一个状态一定是由上一个状态推导出来的**，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

- **重叠子问题**：通过递归的方式解决同样的子问题，很多次计算相同的子问题。
- **最优子结构**：大问题的最优解可以通过子问题的最优解来递推。

**动态规划五部曲:**
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# 01背包问题

## 问题描述:
有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。
## 解决思路:
### 1. **确定dp数组以及下标的含义:**
- 有两个维度的数据: 1)物品; 2)背包容量(重量). 
- 物品的重量以及价值如下图所示
![[Pasted image 20241016144113.png]]
#### **填充物品dp数组:**
>因为要获取最大价值,所以表格内的数据应当是**当前情况下所能取得的最大价值.**

考虑**仅有物品1**的情况,遍历所有背包容量,此时可以填充第一行:
![[Pasted image 20241016143756.png|450]]

继续填充第二行,即物品0和物品1,遍历所有的背包容量: (注意,物品1的重量为3!)
![[Pasted image 20241016143924.png|450]]

继续填充第三行,此时有3个物品,遍历所有背包容量:
![[Pasted image 20241016144741.png|450]]
>[!注意:]
>**明确dp[i][j]的含义:在物品0~i中选择物品,在不超过容量j的情况下,使得背包总价值最大!**

最终,我们要获取的结果即为`dp[2][4]`!

### 2. 确定递推公式:
以`dp[1][4]`举例,分为两种情况:**放物品1或不放物品1.**
	放物品1时,需要保留物品1的容量,并且考虑到物品1的重量为3,所以可由"**`dp[0][1]`+物品1**"获得.
	不放物品1时,此时由`dp[0][4]`获得.

**上述情况可抽象为:**
- 不放物品i: 背包容量为j,不放物品i的最大价值为`dp[i-1][j]`.
- 放物品i: 最大价值为`dp[i-1][j-weight[i]]+value[i]`.
所以,要获取`dp[i][j]`的最大价值,即取上述两种情况的较大值:
`dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])`

### 3. dp数组的初始化:
即考虑上述表格的边界条件: i=0/j=0的情况:
![[Pasted image 20241016150727.png|450]]

### 4. 确定遍历顺序:
>一般来说,先遍历物品,或者先遍历背包容量都可以.

根据我的思维,一般喜欢先遍历物品,然后遍历背包容量,即i=0时,j从0~4;i=1,j从0~4;i=2,j从0~4.\
```java
for (int i = 1; i < weight.size();i++){
	for (int j = 0; j <= bagWeight; j++){
		if (j < weight[i]) dp[i][j] = dp[i-1][j];
		else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]]);
	}
}
```
## 滚动数组优化:
>在01背包问题中,可以用一维滚动数组来代替二维数组,进行时间,空间复杂度上的优化.
![[Pasted image 20241017085159.png|450]]
1. dp数组的定义: `dp[j]`表示容量为j的背包,所背的物品最大价值为`dp[j]`.
2. ==**递推公式:**== `dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i])`;
3. 初始化:`dp[j]`表示**容量为j的背包**,所背的物品最大价值为`dp[j]`,所以初始化`dp[0]=0`;
4. ==**遍历顺序:**== 
	正序遍历时,情况如下,可以看到`dp[2]`实质上是将物品0放入了2次!
	`dp[1] = max(dp[1],dp[1-1]+15) = max(dp[1],dp[0]+15)=15`;
	`dp[2] = max(dp[2],dp[2-1]+15 = max(dp[2],dp[1]+15)=30`;
	逆序遍历:
	`dp[2] = max(dp[2],dp[2-1]+15) = max(dp[2],dp[1]+15)=15` (此时`dp[0]`为初始化的0)
	`dp[1] = max(dp[1],dp[1-1]+15 = max(dp[1],dp[0]+15)=15`

```java
for (int i = 0; i < size; i++){
	for (int j = bagWeight; j >= weight[i]; j--){
		dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])
	}
}
```
# 完全背包问题:
>**与01背包的区别在于:完全背包中某个物品可以添加多次.**

回想前面01背包问题的正序遍历,会导致物品被重复添加,而这正是完全背包需要的效果,所以在完全背包问题中,遍历代码为:
>	这里遍历时从`weight[i]`开始,**是保证最少能取一个物品**,毕竟容量小于物品重量时,无太大意义.

```java
for (int i = 0; i < weight.size(); i++){ // 遍历物品
	for (int j = weight[i]; j <= bagWeight; j++){   //遍历背包容量(正序)
		dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);
	}
}
```
>对于下面的求解"最少个数"的问题,遍历一般如下:
>	1. 首先要先初始化;
>	2. 先遍历物品,再遍历容量,并且注意物品是可以重复使用的(所以内层循环也是正序);
>	3. 注意对于某些问题,判断`dp[j-coins[i]]`是否可达!
```java
Arrays.fill(dp,Integer.MAX_VALUE);
dp[0]=0;

for (int i = 0; i < n; i++) {   // 物品  
    for (int j = coins[i]; j <= amount; j++) {   // 容量  
        if (dp[j - coins[i]] != Integer.MAX_VALUE) {  
            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);  
        }  
    }  
}
```

## 518. 零钱兑换II
### 题目:
给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。

题目数据保证结果符合 32 位带符号整数。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 硬币可以重复选择,所以是完全背包问题.
- `dp[j] += dp[j-coins[i]]`:是一直在**更新(累加)**`dp[j]`的可能性
![[Pasted image 20241017140738.png|500]]
### 代码:
```java
class Solution {  
    public int change(int amount, int[] coins) {  
        int n = coins.length;  
        // dp[j]表示容量为j的背包的最大价值,在这里,物品价值与重量一样  
        int[] dp = new int[amount+1];  
        dp[0] = 1;  
        for (int i = 0; i < n; i++) {  
            for (int j = coins[i]; j <= amount; j++) {  
                dp[j] += dp[j-coins[i]];  
            }  
        }  
        return dp[amount];  
    }  
}  
```

## 377. 组合总数IV
### 题目:
给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素**组合的个数**。

题目数据保证答案符合 32 位整数范围。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 与[[#518. 零钱兑换II]]几乎一样,但是518是求组合,本题是求排列! 对于求排列问题,**需要在外层遍历背包容量,内层遍历物品,否则只会有{1,3}组合,而不会有{3,1}组合,因为总是先放置物品1.**
### 代码:
```java
class Solution {  
    public int combinationSum4(int[] nums, int target) {  
        int n = nums.length;  
        int[] dp = new int[target+1];  
        dp[0] = 1;  
  
        for (int i = 0; i <= target ; i++) {  
            for (int j = 0; j < n; j++) {  
                if (i - nums[j] >= 0) { // 容量大于物品重量时，才放  
                    dp[i] += dp[i-nums[j]];  
                }  
            }  
        }  
        return dp[target];  
    }  
}

```
## 70. 爬楼梯
### 题目:
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 与[[#377. 组合总数IV]]思路一致!
### 代码:
```java
class Solution {  
    public int climbStairs(int n) {  
        int[] dp = new int[n+1];  
        dp[0] = 1;  
  
        for (int i = 1; i <= n; i++) {  
            for (int j = 1; j <= 2; j++) {  
                if (i >= j)  
                    dp[i] += dp[i-j];  
            }  
        }  
        return dp[n];  
    }  
}
```

## 322. 零钱兑换 
### 题目:
给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 思路与[[#279. 完全平方数]]一致,区别在于这里需要判断`dp[j-coins[i]]`是否可达!
	- 例如对于`coins=[2],amount=3`,此时`dp[3]`就是不可达的!
### 代码:
```java
class Solution {  
    public int coinChange(int[] coins, int amount) {  
        int n = coins.length;  
        int[] dp = new int[amount + 1];  
        for (int i = 0; i < dp.length; i++) {  
            dp[i] = Integer.MAX_VALUE;  
        }  
        dp[0] = 0;  
  
        for (int i = 0; i < n; i++) {   // 物品  
            for (int j = coins[i]; j <= amount; j++) {   // 容量  
                if (dp[j - coins[i]] != Integer.MAX_VALUE) {  
                    dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);  
                }  
            }  
        }  
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];  
    }  
}  
```
## 279. 完全平方数
### 题目:
给你一个整数 `n` ，返回 **_和为 `n` 的完全平方数的最少数量_** 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- `dp[j] = Math.min(dp[j],dp[j-square]+1)`,平方数的更新逻辑,举例说明:
```
i=1时,即squqre=1,此时
dp[1~12] = 1~12;

i=2时,即squqre=4,此时
dp[1~4]都可以不用更新,因为4比他们的容量都大!
dp[5~12]都可以更新,即
	dp[4] = Math.min(dp[4], dp[4 - 4] + 1) = Math.min(4, 0 + 1) = 1
	dp[5] = Math.min(dp[5], dp[5 - 4] + 1) = Math.min(5, 1 + 1) = 2
	dp[6] = Math.min(dp[6], dp[6 - 4] + 1) = Math.min(6, 2 + 1) = 3
	dp[7] = Math.min(dp[7], dp[7 - 4] + 1) = Math.min(7, 3 + 1) = 4
	dp[8] = Math.min(dp[8], dp[8 - 4] + 1) = Math.min(8, 4 + 1) = 2
	dp[9] = Math.min(dp[9], dp[9 - 4] + 1) = Math.min(9, 5 + 1) = 3
	dp[10] = Math.min(dp[10], dp[10 - 4] + 1) = Math.min(10, 6 + 1) = 4
	dp[11] = Math.min(dp[11], dp[11 - 4] + 1) = Math.min(11, 7 + 1) = 5
	dp[12] = Math.min(dp[12], dp[12 - 4] + 1) = Math.min(12, 8 + 1) = 3
	dp[13] = Math.min(dp[13], dp[13 - 4] + 1) = Math.min(13, 9 + 1) = 4
后面也同理可得!
```

- `if (dp[j-square] != Integer.MAX_VALUE) `,这个条件判断是个重点,是为了保证`dp[j-squqre]`实质上已被"初始化",即**存在可能的组合**;若`dp[j-squqre]==MAX`,则代表此时还不存在任何组合满足要求.
	- 但是对于本题,实质上无需这个条件判断也可,因为存在i=1(可重复使用),所以任意`dp[j-squqre]`实质上都是可达的!
### 代码:
```java
//leetcode submit region begin(Prohibit modification and deletion)  
class Solution {  
    public int numSquares(int n) {  
        // dp[j]表示组成j的最少平方数  
        int[] dp = new int[n+1];  
        Arrays.fill(dp, Integer.MAX_VALUE);  
        dp[0] = 0;  
  
        for (int i = 1; i*i <=n;i++) {  
            int square = i * i;  
            System.out.printf("square = %d\n",square);  
            for (int j = square; j <= n; j++) {  
                dp[j] = Math.min(dp[j], dp[j - square] + 1);  
            }  
        }  
        return dp[n];  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

## 139. 单词拆分
### 题目:
给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
### 信息:
- **难度**: meidum
- **重要性:** #★★★★☆
### 思路:
- `dp[i]`表示前i个字符能否被字典中的单词拼接.
- 因为是要求排列问题,所以先遍历背包,再遍历物品.
### 代码:
```java
class Solution {  
    public boolean wordBreak(String s, List<String> wordDict) {  
        int n = s.length();  
        boolean[] dp = new boolean[n+1];  
        HashSet<String> set = new HashSet<>(wordDict);  
		dp[0] = true;  // 定义空字符串也可拆分.
        // 完全背包.  
        for (int i = 1; i <= n; i++) {        // 背包.  
            for (int j = 0; j < i; j++) {     // 物品.  
                String str = s.substring(j,i);  
                if (set.contains(str) && dp[j]) {  
                    dp[i] = true;  
                }  
            }  
        }  
        return dp[n];  
    }  
}  
```
### 优化时空复杂度:
```java
class Solution {  
    public boolean wordBreak(String s, List<String> wordDict) {  
        int n = s.length();  
        boolean[] dp = new boolean[n+1];  
        HashSet<String> set = new HashSet<>(wordDict);  
        dp[0] = true;  
  
        int maxLen = 0;  
        for (String word : wordDict) {  
            maxLen = Math.max(maxLen, word.length());  
        }  
  
        // 完全背包.  
        for (int i = 1; i <= n; i++) {        // 背包.  
            for (int j = Math.max(0, i - maxLen); j < i; j++) {    // 物品.  
                String str = s.substring(j,i);  
                if (set.contains(str) && dp[j]) {  
                    dp[i] = true;  
                    break;  
                }  
            }  
        }  
        return dp[n];  
    }  
}  
```
# 背包问题总结:
**递推公式**
> 👉 问能否装满背包（或者最多装多少）：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`
> 
> 👉 问装满背包几种方法：`dp[j] += dp[j - nums[i]]`
> 
> 👉 问装满背包最大价值：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
> 
> 👉 问装满背包最小个数：`dp[j] = min(dp[j], dp[j - coins[i]] + 1)`

**遍历顺序**

> 👉 01背包  
> 二维 dp 数组：先遍历物品或背包皆可，且第二层是从小到大遍历。  
> 一维 dp 数组：先遍历物品再遍历背包，且第二层是从大到小遍历。
> 
> 👉 完全背包（一维 dp 数组）  
> **求组合数：** 先遍历物品再遍历背包，且第二层是从小到大遍历。  
> **求排列数：** 先遍历背包再遍历物品，且第二层是从小到大遍历。  
> **求最小值：** 先遍历物品或背包皆可，且第二层是从小到大遍历。


# 树形DP:
## 377. 打家劫舍III
### 题目:

### 信息:
- **难度**:
- **重要性:** #★★★★☆
### 思路1:
- 通过递归+记忆化搜索来实现,即分为两种情况:
	1. 选择root节点,则儿子不能选,只能选孙子;
	2. 不选择root节点,则儿子可以选.
- 对于树形的记忆化搜索,利用HashMap做缓存.最后选择两种情况的最大值.
### 代码:
```java
class Solution {  
    HashMap<TreeNode,Integer> map = new HashMap<>();  
    public int rob(TreeNode root){  
        return rob1(root);  
    }  
  
    public int rob1(TreeNode root) {  
        if (root == null) return 0;  
  
        if (map.containsKey(root)) return map.get(root);  
  
        int money = root.val;  
  
        if (root.left != null){  
            money += (rob1(root.left.left)+rob1(root.left.right));  
        }  
        if (root.right != null){  
            money += rob1(root.right.left)+rob1(root.right.right);  
        }  
        int ans = Math.max(money,rob1(root.left)+rob1(root.right));  
        map.put(root,ans);  
        return ans;  
    }  
}  
//leetcode submit region end(Prohibit modification and deletion)
```

### 思路2:
- 动态规划进行优化,定义二维数组`ans`,`ans[0]`存放放根节点的,`ans[1]`存放不放根节点的,这两种情况就代表了当前节点的两种情况!(取最大值即为当前节点的最大价值)
- `ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);`代表了当前节点不偷的情况,而这种情况包含**子节点偷(`[1]`)/不偷(`[0]`)**.
- `ans[1] = left[0] + right[0] + root.val;`代表了当前节点偷的情况,即**此时子节点不能偷**!所以此时只能取`left[0]`与`right[0]`.

```java hl:16-17
class Solution {  
    public int rob(TreeNode root){  
        int[] ans = rob1(root);  
        return Math.max(ans[0],ans[1]);  
    }  
  
    public int[] rob1(TreeNode root) {  
        int[] ans = new int[]{0,0};  
        // 到底,返回.  
        if (root == null) return ans;  
        // 存储 不放根节点+放根节点  
        // 左儿子,右儿子  
        int[] left = rob1(root.left);  
        int[] right = rob1(root.right);  
  
        ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);   //不放根节点: 儿子偷!  
        ans[1] = left[0] + right[0] + root.val;  // 放根节点: 儿子不偷+根节点  
  
        return ans;  
    }  
}
```


# 股票问题:
**初始化逻辑:** 
- **第`j`次交易不持股的状态**初始化为:`Integer.MIN_VALUE`,以便于后面买入时更新.
	- `dp[j][1]=Integer.MIN_VALUE`
- **第`j`次交易持股的状态**初始化为`0`,即不持股时没有任何收益
	- `dp[j][0]=0`
**遍历顺序:**
- `for (int i = 0; i < n; i++)`:即
## 121. 买卖股票的最佳时机
### 题目:
你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路1:
- 持续更新最小成本作为买入价格,遍历所有`price[i]`计算利润.
### 代码1:
```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int minPrice = prices[0];
        for (int p : prices) {
            ans = Math.max(ans, p - minPrice);
            minPrice = Math.min(minPrice, p);
        }
        return ans;
    }
}
```

### 思路2:
- 前i天分别有两种状态:持有股票和不持有股票,所以`dp[i][j]`表示下标为 `i` 这一天结束的时候，手上持股状态为 `j` 时，我们持有的现金数。
	- `dp[i][0]`:表示第i天,不持有股票时,持有的现金数.
	- `dp[i][1]`:表示第i天,持有股票时,持有的现金数.
- 将`dp[i][1]`初始化为`-price[i]`,这样能保证在计算利润时,即`prices[i] + dp[i-1][1]`,能更方便获取买入价格.
### 代码2:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // dp[i][0]表示第i天不持有股票所得最多现金.  
        // dp[i][1]表示第i天持有股票所得最多现金.  
        int[][] dp = new int[n][2];  
        dp[0][0] = 0;  
        dp[0][1] = -prices[0];  
        //int ans = 0;  
        for (int i = 1; i < n; i++) {  
            dp[i][0] = Math.max(prices[i] + dp[i-1][1],dp[i-1][0]);  
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);   //持续获取最低买入价格.
        }  
        return Math.max(dp[n-1][0],dp[n-1][1]);  
    }  
}
```

## 122. 买卖股票的最佳时机II
### 题目:
给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- 与[[#121. 买卖股票的最佳时机]]思路一致,不过这里的状态转移(递推公式)不太一样:
- `dp[i][0]`:当天不持有股票的情况,此时可能为 
	 **1)前一天持有,当天卖出; 2)前一天不持有,当天继续不持有,利润与前一天相同**
- `dp[i][1]`:当天持有股票的情况,此时可能为
	 **1)前一天持有,今天继续持有,利润不变; 2)前一天不持有(此时可能有利润),今天买入,需要减去买入价格**
```java
// price[i]+dp[i-1][1]:前一天持有,今天卖出;
// dp[i-1][0]:继续不持有
dp[i][0] = Math.max(prices[i] + dp[i-1][1],dp[i-1][0]);

// dp[i-1][1]:今天继续持有
// dp[i-1][0] - price[i]:前i-1天的利润+今天的买入价格
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
```
### 代码:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        int ans = 0;  
        //dp[i][0]:前i天不持有股票  
        //dp[i][1]:前i天持有股票  
        int[][] dp = new int[n][2];  
        dp[0][1] = -prices[0];  
        for (int i = 1; i < n; i++) {  
            // 不持有:比较 1）卖出；2）继续不持有  
            dp[i][0] = Math.max(prices[i] + dp[i-1][1],dp[i-1][0]);  
            // 持有  
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);  
        }  
        return dp[n-1][0];  
    }  
}

```
### 代码2:(一维数组优化)
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        int ans = 0;  
        //dp[i][0]:前i天不持有股票  
        //dp[i][1]:前i天持有股票  
        int[] dp = new int[2];  
        dp[1] = Integer.MIN_VALUE;  
        for (int i = 0; i < n; i++) {  
            // 不持有:比较 1）卖出；2）继续不持有  
            dp[0] = Math.max(dp[0], dp[1]+prices[i]);  
            // 持有  
            dp[1] = Math.max(dp[1], dp[0]-prices[i]);  
        }  
        return dp[0];  
    }  
}
```

## 123. 买卖股票的最佳时机III
### 题目:
给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 因为限制了只能买入两次,所以在[[#122. 买卖股票的最佳时机II]]的基础上**再增加一个维度**来记录买卖次数,即`dp[i][j][k]`.
- **递推公式:**
- `return Math.max(dp[1][0],dp[2][0])`:保证仅有一次交易时,也能返回正确的答案.
### 代码:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][][] dp = new int[n][3][2];  
        dp[0][1][1] = -prices[0];  
        dp[0][2][1] = Integer.MIN_VALUE;  
        for (int i = 1; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[i][1][0] = Math.max(dp[i-1][1][1]+prices[i],dp[i-1][1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[i][1][1] = Math.max(-prices[i],dp[i-1][1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[i][2][0] = Math.max(dp[i-1][2][1]+prices[i],dp[i-1][2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[i][2][1] = Math.max(dp[i-1][1][0]-prices[i],dp[i-1][2][1]);  
        }  
        return Math.max(dp[n-1][1][0],dp[n-1][2][0]);  
    }  
}

```

### 代码2:滚动数组优化:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][][] dp = new int[2][3][2];  
        dp[0][1][1] = -prices[0];  
        dp[0][2][1] = Integer.MIN_VALUE;  
        for (int i = 1; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[i%2][1][0] = Math.max(dp[(i-1)%2][1][1]+prices[i],dp[(i-1)%2][1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[i%2][1][1] = Math.max(-prices[i],dp[(i-1)%2][1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[i%2][2][0] = Math.max(dp[(i-1)%2][2][1]+prices[i],dp[(i-1)%2][2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[i%2][2][1] = Math.max(dp[(i-1)%2][1][0]-prices[i],dp[(i-1)%2][2][1]);  
        }  
        return Math.max(dp[(n-1)%2][1][0],dp[(n-1)%2][2][0]);  
    }  
}
```
### 代码3:使用二维数组(当天的值之与前一天的值相关)
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        // j=0,1,2:表示未操作,买入过1次,买入过2次;  
        // k=0,1:表示是否持股.  
        int[][] dp = new int[3][2];  
        //dp[1][1] = -prices[0];  
        dp[1][1] = Integer.MIN_VALUE;  
        dp[2][1] = Integer.MIN_VALUE;  
        for (int i = 0; i < n; i++) {  
            // 1)今天卖出(前一天持股); 2)今天仍不持股  
            dp[1][0] = Math.max(dp[1][1]+prices[i],dp[1][0]);  
            // 1)今天仍持股,不变; 2)今天第一次买入  
            dp[1][1] = Math.max(-prices[i],dp[1][1]);  
            // 第二次(不持股): 1)今天卖出 ;2)前面不持股+仍不持股.  
            dp[2][0] = Math.max(dp[2][1]+prices[i],dp[2][0]);  
            // 第二次(持股): 1)买入; 2)继续持股  
            dp[2][1] = Math.max(dp[1][0]-prices[i],dp[2][1]);  
        }  
        return Math.max(dp[1][0],dp[2][0]);  
    }  
}
```
## 188. 买卖股票的最佳时机IV
### 题目:
给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 使用二维数组进行优化,因为当天的值只与前一天的值有关,所以可以**通过状态压缩来节省内存空间.** 具体而言就是在循环中不断更新`dp[j][1/0]`!
- 更进一步的优化,源于ChatGPT的思路,见代码2.
- **初始化: 将第一次买入的价格置为最小值,便于后面的更新.**
- **根本的递推思路都没变**:(j表示交易次数)
	- **持股时:** 1)前一天不持股+今天买入; 2)前一天持股,今天继续持股;
		- `dp[j][1] = Math.max(dp[j-1][0]-prices[i-1],dp[j][1])`
			- **今天买入,此时对应前一天应该是第j-1次交易!**
	- **不持股时:** 1)前一天持股,今天卖出; 2)前一天不持股+今天继续不持股;
		- `dp[j][0] = Math.max(dp[j][1]+price[i-1],dp[j][0])`
### 代码1:
```java hl:13,14
class Solution {  
    public int maxProfit(int k, int[] prices) {  
        int n = prices.length;  
  
        int[][] dp = new int[k+1][2];  
        for (int i = 0; i <= n; i++) {  
            for (int j = 0; j <= k; j++) {  
                dp[j][1] = Integer.MIN_VALUE;  
            }  
        }  
        for (int i = 1; i <= n; i++) {  
            for (int j = 1; j <= k; j++) {  
                dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i - 1]);  
                dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i - 1]);  
            }  
        }  
        // 说明：第一维和第二维状态都具有前缀性质的，输出最后一个状态即可  
        return dp[k][0];  
    }  
}
```
### 代码2:
```java hl:17-18
class Solution {  
    public int maxProfit(int k, int[] prices) {  
        int n = prices.length;  
        if (n == 0 || k == 0) return 0;  
        // dp[j][0]：第j次交易后，不持股的最大利润  
        // dp[j][1]：第j次交易后，持股的最大利润  
        int[] dp0 = new int[k + 1];  // dp[j][0] 简化为 dp0[j]        
        int[] dp1 = new int[k + 1];  // dp[j][1] 简化为 dp1[j]  
        // 初始化 dp1 数组为最小值，因为开始时我们还没有进行任何交易  
        for (int j = 0; j <= k; j++) {  
            dp1[j] = Integer.MIN_VALUE;  
        }  
  
        for (int price : prices) {  
            for (int j = 1; j <= k; j++) {  
                dp1[j] = Math.max(dp1[j], dp0[j - 1] - price); // 买入  
                dp0[j] = Math.max(dp0[j], dp1[j] + price);     // 卖出  
            }  
        }  
        return dp0[k];  
    }  
}
```

### 剪枝操作:
- 如果可交易次数大于交易天数的一半,则可以累加所以的正利润
	- 例如:`[1,2,3,4,5,6],k=3`,最大利润为5,可通过累加获得!
```java
if (k >= n / 2) {  
    // 如果可以进行的交易次数大于等于可交易的天数的一半，使用贪心法  
    int maxProfit = 0;  
    for (int i = 1; i < n; i++) {  
        if (prices[i] > prices[i - 1]) {  
            maxProfit += prices[i] - prices[i - 1]; // 累加所有正利润  
        }  
    }  
    return maxProfit;  
}
```

## 309. 买卖股票的最佳时机含冷冻期
### 题目:
给定一个整数数组 `prices`，其中第 `prices[i]` 表示第 `_i_` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★ 
### 思路:
- **`dp[i][j]`表示第i天,状态为j时,所拥有的现金数.** 根据题目要求,定义3种状态:0,1,2.
```java
// dp[i][0]: 手上不持有股票，并且今天不是由于卖出股票而不持股，我们拥有的现金数
// dp[i][1]: 手上持有股票时，我们拥有的现金数
// dp[i][2]: 手上不持有股票，并且今天是由于卖出股票而不持股，我们拥有的现金数
```
### 代码:
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        int n = prices.length;  
        if (n==1) return 0;  
  
        int[][] dp = new int[n][3];  
        dp[0][0] = 0;  
        dp[0][1] = -prices[0];  
        dp[0][2] = 0;  
  
        for (int i = 1; i < n; i++) {  
            // 1)卖出; 2)继续不持股  
            dp[i][0] = Math.max(dp[i-1][2],dp[i-1][0]);  
            // 1)买入; 2)继续持股  
            dp[i][1] = Math.max(dp[i-1][0]-prices[i],dp[i-1][1]);  
            // 1)卖出;  
            dp[i][2] = dp[i-1][1]+prices[i];  
        }  
        return Math.max(dp[n-1][0],dp[n-1][2]);  
    }  
}
```

## 714. 买卖股票的最佳时机含手续费
### 题目:
给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
### 信息:
- **难度**: meidum
- **重要性:** #★★★☆☆
### 思路:
- 在每次买入时加入手续费即可,基本的动态规划思路不变!
### 代码:
```java hl:6,11,13
class Solution {  
    public int maxProfit(int[] prices, int fee) {  
        int n = prices.length;  
        int[][] dp = new int[n][2];  
  
        dp[0][1] = -prices[0] - fee; // 买入时加入手续费  
        dp[0][0] = 0;  
  
        for (int i = 1; i < n; i++) {  
            // 1)卖出 2)继续不持股  
            dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i-1][0]);  
            // 1)keep not holding 2)buy  
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);  
        }  
        return dp[n - 1][0];  
    }  
}  
```


# 子序列问题:
>**在解决字符串或数组匹配、对比的问题时，动态规划通常是一种有效的方法，尤其当问题涉及子序列、子数组或子串时**


## 300. 最长递增子序列
### 题目:
给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- `dp[i]`表示以`nums[i]`结尾的上升子序列的长度.
- **状态转移:** `dp[i]`可由`dp[j]+1`获得,其中有`nums[j]<nums[i]`.
### 代码:
```java
class Solution {  
    public int lengthOfLIS(int[] nums) {  
        int n = nums.length;  
        if (n == 1) return 1;  
        int[] dp = new int[n];  
        Arrays.fill(dp,1);  
        int ans = 0;  
        for (int i = 1; i < n; i++) {  
            for (int j = 0; j < i; j++) {  
                if (nums[j] < nums[i]) {  
                    dp[i] = Math.max(dp[j]+1,dp[i]);  
                }  
            }  
            ans = Math.max(ans,dp[i]);  
        }  
        return ans;  
    }  
}  
```
## 718. 最长重复子数组
### 题目:
给两个整数数组 `nums1` 和 `nums2` ，返回 _两个数组中 **公共的** 、长度最长的子数组的长度_ 。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- `dp[i][j]`表示`nums1`中前`i`个元素和`nums2`的前`j`个元素中所能构成的最长公共子数组.
- `dp[i][0]`和`dp[0][j]`都初始化为0,代表长度为0,也便于后面的推导.
- **递推数组:** `dp[i][j] = dp[i-1][j-1] + 1` 
	- 由递推数组也可以看出`dp[i][0]`和`dp[0][j]`都应初始化为0.
### 代码:
```java
class Solution {  
    public int findLength(int[] nums1, int[] nums2) {  
        int n1 = nums1.length;  
        int n2 = nums2.length;  
        int[][] dp = new int[n1+1][n2+1];  
        int ans = 0;  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (nums1[i-1] == nums2[j-1]) {  
                    dp[i][j] = dp[i-1][j-1] + 1;  
                }  
                ans = Math.max(dp[i][j],ans);  
            }  
        }  
        return ans;  
    }  
}
```
## 1143. 最长公共子序列:
### 题目:
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
### 信息:
- **难度**: medium
- **重要性:** #★★★★☆
### 思路:
- `dp[i][j]`表示`text1[0:i-1]`和`text2[0:j-1]`元素的最长公共子序列.
- **递推公式:** 
	- 当`text1[i-1]==text2[j-1]`时,则子序列长度+1 -> `dp[i][j] = dp[i-1][j-1]+1`;
	- 当`text1[i-1]!=text2[j-1]`时,取`dp[i-1][j]`和`dp[i][j-1]`的最大值.
![[Pasted image 20241023092053.png|450]]
### 代码:
```java
class Solution {  
    public int longestCommonSubsequence(String text1, String text2) {  
        int n1 = text1.length();  
        int n2 = text2.length();  
        int[][] dp = new int[n1+1][n2+1];  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (text1.charAt(i-1) == text2.charAt(j-1)){  
                    dp[i][j] = dp[i-1][j-1] + 1;  
                }else {  
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);  
                }  
            }  
        }  
        return dp[n1][n2];  
    }  
}
```

## 53. 最大子数组和
### 题目:
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。
### 信息:
- **难度**: medium
- **重要性:** #★★☆☆☆
### 思路:
- 两种可能性:
	- 若`前i-1个最大和+nums[i]`可能小于0,此时需要从nums[i]重新开始计算;
	- 若`前i-1个最大和+nums[i]`比`前i-1个最大和`还要大,则继续累加
### 代码:
```java
class Solution {  
    public int maxSubArray(int[] nums) {  
        int n = nums.length;  
        if (n == 1) return nums[0];  
        int sum = 0;  
        // dp[i]表示前i个元素的最大和  
        int[] dp = new int[n];  
        dp[0] = nums[0];  
        int ans = dp[0];  
        for (int i = 1; i < n; i++) {  
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);  
            ans = Math.max(dp[i],ans);  
        }  
        return ans;  
    }  
}
```

观察代码可发现,递推公式就是:`dp[i] = Math.max(nums[i],dp[i-1]+nums[i])`,即只需要与前一个状态关联即可,所以可将dp数组优化为curr与prev,代码如下:
### 代码2: 使用curr与prev优化
```java
class Solution {  
    public int maxSubArray(int[] nums) {  
        int n = nums.length;  
		  
		int curr = 0;  //当前状态
        int prev = nums[0];  //前一个状态,初始化为nums[0]
        int ans = prev;  // 最终结果,需要不断比较,取最大值.
  
        for (int i = 1; i < n; i++) {  
            curr = Math.max(nums[i],prev+nums[i]);  
            ans = Math.max(curr,ans);
            // ans = curr > ans ? curr : ans;  
            // 更新前一个状态
            prev = curr;  
        }  
        return ans;  
    }  
}
```

## 392. 判断子序列
### 题目:
给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路:
- indexS和indexT进行判断,indexT不断自增,而indexS只有在相等时才自增,最后若indexS到达了末尾,则返回true,否则返回false
### 代码:
```java
class Solution {  
    public boolean isSubsequence(String s, String t) {  
        int indexS = 0, indexT = 0;  
        int n1 = s.length(), n2 = t.length();  
  
        while (indexS < n1 && indexT < n2) {  
            if (s.charAt(indexS) == t.charAt(indexT)) {  
                indexS++;  
            }  
            indexT++;  
        }  
        return indexS == n1;  
    }  
}
```
### 同样的思路:(灵神代码)
- 定义索引i(相当于遍历s字符串),当存在`charAt(i)==c`,此时i++,最后若`i == s.length()`,则说明为子序列了,返回true.
```java
class Solution {  
    public boolean isSubsequence(String s, String t) {  
        if (s.isEmpty()) return true;  
  
        int i = 0;  
        for (char c : t.toCharArray()){  
            if (c == s.charAt(i) && (++i) == s.length()) return true;  
        }  
        return false;  
    }  
}
```

## ==115. 不同的子序列==
### 题目:
给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。

**示例 1：**
**输入：** s = "rabbbit", t = "rabbit"
输出：**`3`
**解释：**
如下所示, 有 3 种可以从 s 中得到 `"rabbit" 的方案`。
`rabbbit`
`rabbbit`
`rabbbit`
### 信息:
- **难度**: hard
- **重要性:** #★★★★☆
### 思路:
- 定义dp数组`dp[i][j]`:以`i-1为结尾的s子序列`中出现`以j-1为结尾的t`的个数.
- **初始化:** 
	- 当 `j = 0` 时，无论 `i` 的值如何，`dp[i][0]` 都应该为 `1`。因为空字符串是任何字符串的子序列。
	- 当 `i = 0` 且 `j > 0` 时，`dp[0][j]` 应为 `0`，因为没有字符的 `s` 不能形成非空的 `t`。
- **递推公式:** 
    - 如果 `s[i-1]` 和 `t[j-1]` 相等：有两种选择：
		1. **选择这个字符**：在 `s` 中包含这个字符，那么我们可以通过 `dp[i-1][j-1]` 来找到子序列。
		2. **不选择这个字符**：继续在 `s` 中寻找 `t[j-1]`，那么数量为 `dp[i-1][j]`。
        - 所以，状态转移方程为：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`
    - 如果 `s[i-1]` 和 `t[j-1]` 不相等：
        - 我们只能选择不包含 `s[i-1]`，因此：`dp[i][j] = dp[i-1][j]`

![[Pasted image 20241022142834.png|450]]
### 代码:
```java hl:11,13
public int numDistinct(String s, String t) {  
    int n1 = s.length();  
    int n2 = t.length();  
    int[][] dp = new int[n1 + 1][n2 + 1];  
    for (int i = 0; i <= n1; i++) {  
        dp[i][0] = 1;  
    }  
    for (int i = 1; i <= n1; i++) {  
        for (int j = 1; j <= n2; j++) {  
            if (s.charAt(i - 1) == t.charAt(j - 1))  
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];  
            else  
                dp[i][j] = dp[i - 1][j];  
        }  
    }  
    return dp[n1][n2];  
}
```
## 583. 两个字符串的删除操作
### 题目:
给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

**输入:** word1 = "sea", word2 = "eat"
**输出:** 2
**解释:** 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"

**示例 2:**

**输入：** word1 = "leetcode", word2 = "etco"
**输出：** 4
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 思路是找到word1和word2的最长公共子序列,然后返回`(n1-dp[i][j])+(n2-dp[i][j])`即可.
### 优化:
- 分析递推公式,仅与前一行状态有关,所以可采用滚动数组优化!
### 代码:
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[n1+1][n2+1];  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i][j] = dp[i-1][j-1]+ 1;  
                }else {  
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);  
                }  
            }  
        }  
        return n1 + n2 - 2 * dp[n1][n2];  
    }  
}

```
### **优化后代码:**

```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[2][n2+1];  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i%2][j] = dp[(i-1)%2][j-1]+ 1;  
                }else {  
                    dp[i%2][j] = Math.max(dp[(i-1)%2][j],dp[i%2][j-1]);  
                }  
            }  
        }  
        return n1 + n2 - 2 * dp[n1%2][n2];  
    }  
}
```


## ==72. 编辑距离== 
### 题目:
给你两个单词 `word1` 和 `word2`， _请返回将 `word1` 转换成 `word2` 所使用的最少操作数_ 。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- **dp数组定义:**
	- `dp[i][j]` 表示将`word1`的前`i`个字符转换为`word2`的前`j`个字符所需的最少操作数。
- **初始化:**
	- `dp[0][0] = 0`:将空字符串转换为空字符串不需要任何操作.
	- `dp[i][0] = i`:将`word1`的前`i`个字符转换为空字符串需要`i`次删除操作
	- `dp[0][j] = j`:将空字符串转换为 `word2` 的前 `j` 个字符需要 `j` 次插入操作。
- **递推公式:**
	- **字符相等时**:(`words1[i-1]==words2[j-1]`)
		- `dp[i][j] = dp[i-1][j-1]`，因为不需要额外的操作
	- **字符不相等时**:(`words1[i-1]!=words2[j-1]`)
		- **插入**：在`word1`的前`i`个字符中插入一个字符使其与 `word2` 的前 `j` 个字符匹配，操作数为 `dp[i][j-1] + 1`。
		- **删除**：在 `word1` 中删除一个字符，操作数为 `dp[i-1][j] + 1`。
		- **替换**：将 `word1[i-1]` 替换为 `word2[j-1]`，操作数为 `dp[i-1][j-1] + 1`。
### 代码:
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        // 转换为寻找最长公共子序列  
        int n1 = word1.length();  
        int n2 = word2.length();  
  
        int[][] dp = new int[n1+1][n2+1];  
        for (int i = 0; i <= n1; i++) {  
            // word2为空,则必为子序列.  
            dp[i][0] = i;  
        }  
        for (int i = 0; i <= n2; i++) {  
            // word2为空,则必为子序列.  
            dp[0][i] = i;  
        }  
  
        for (int i = 1; i <= n1; i++) {  
            for (int j = 1; j <= n2; j++) {  
                if (word1.charAt(i-1) == word2.charAt(j-1)) {  
                    dp[i][j] = dp[i-1][j-1];  
                }else {  
                    dp[i][j] = Math.min(dp[i][j-1]+1,Math.min(dp[i-1][j-1]+1,dp[i-1][j]+1));  
                }  
            }  
        }  
        //System.out.println(dp[n1][n2]);  
        return dp[n1][n2];  
    }  
}
```

## 516. 最长回文子序列
### 题目:
给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路:
- **dp数组定义:**
	- `dp[i][j]` 表示在字符串的子串`s[i]`到`s[j]`范围内的最长回文子序列的长度。
- **初始化:**
	- 当 `i == j` 时，表示只有一个字符的情况，因此 `dp[i][i] = 1`，是一个回文字符串.
- **递推公式:**
	- **相等情况**:(`s.charAt(left) == s.charAt(right)`)
		- 此时将相同的两个字符都加上
			- `dp[left][right]=dp[left+1][right−1]+2`
	- **不相等情况**:(`s.charAt(left) != s.charAt(right)`)
		- 字符不相等,所以同时加两个字符串,故比较"加左字符"和"加右字符"的较大值.
			- `dp[left][right]=max(dp[left+1][right],dp[left][right−1])`
- **遍历顺序:**
  - 注意下文的填充顺序,所以外层循环应该是`从n-2倒序遍历`;内层循环`从i+1开始正序遍历.`
  ![[Pasted image 20241023144055.png|450]]
### 代码:
```java hl:10-11
public int longestPalindromeSubseq(String s) {  
	int n = s.length();  
	if (n == 1) return n;  
	int[][] dp = new int[n][n];  

	for (int i = 0; i < n; i++) {  
		dp[i][i] = 1;  
	}  

	for (int left = n-2; left >= 0; left--) {  
		for (int right = left+1; right < n; right++) {  
			if (s.charAt(left) == s.charAt(right)) {  
				dp[left][right] = dp[left + 1][right - 1] + 2;  
			} else {  
				dp[left][right] = Math.max(dp[left + 1][right], dp[left][right - 1]);  
			}  
		}  
	}  
	return dp[0][n-1];  
}  
```
