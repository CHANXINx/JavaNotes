# 栈与队列


## 232. 用栈实现队列
### 题目:
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 用栈实现队列,即通过栈的"先进后出"实现队列的"先进先出".利用两个栈`stackIn`和`stackOut`,`stackOut`用于存储元素的倒序版本,从而正确模拟队列出队操作.
- ~~实现队列/栈,只要保证能实现基本操作即可.例如栈实现队列,保证能符合队列的进出,获取元素即可,无需过分关注内部如何存储.~~
- `dumpStackIn()`函数,是用于将stackIn的元素放入StackOut,因为栈是先进后出,所以将stackIn的元素放入stackOut,此时后进的元素就变为了先进的元素!
>[!GPTANSWER]
>**如果每次调用 `dumpStackIn` 时都将 `stackIn` 中的元素倒入 `stackOut`，会导致 `stackOut` 中的元素顺序被打乱，无法保证队列的顺序性。**
- 例如,先将1放入了stackOut,此时再将3,2也放入了stackOut,此时就变成了`[2,3,1]`,此时就变成了2先出栈,故会错误! 保证stackOut即保证了"先进先出"!
### 关键点:
- 运用两个队列来保证队列的出队操作.
- 需要理解好模拟的出队操作,尤其是当stackOut为空时才往里面添加元素.
### 代码:
```java
class MyQueue {  
    Stack<Integer> stackIn;  
    Stack<Integer> stackOut;  
  
    public MyQueue() {  
        stackIn = new Stack<>();  
        stackOut = new Stack<>();  
  
    }  
  
    public void push(int x) {  
        stackIn.push(x);  
    }  
  
    public int pop() {  
        dumpStackIn();  
        return stackOut.pop();  
    }  
  
    public int peek() {  
        dumpStackIn();  
        return stackOut.peek();  
    }  
  
    public boolean empty() {  
        return stackIn.isEmpty() && stackOut.isEmpty();  
    }  
  
    private void dumpStackIn(){  
        if (stackOut.isEmpty()){  
            while (!stackIn.isEmpty()){  
                stackOut.push(stackIn.pop());  
            }  
        }  
    }  
}  
```
## 225. 用队列实现栈
### 题目:
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
实现 `MyStack` 类：
- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
**注意：**
- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 可以使用单向队列或双向队列来实现,使用双向队列则更简单.
- 可以使用"循环队列"来实现先进后出.
- 使用队列实现栈的出栈操作: 因为出栈是末尾弹出,所以当队列有size个元素,即**将前size-1个元素先出队,再入队**.就能在**保证末尾元素被出队,同时保存前面元素顺序不变!**
- 获得栈顶元素,就是将末尾元素出队,再入队.故先调用pop()方法,再push.
### 关键点:
- 循环队列!
### 代码:
```java
class MyStack {  
//    使用Queue实现,不使用末尾弹出.  
    Queue<Integer> queue1;  
  
    public MyStack() {  
        queue1 = new LinkedList<>();  
    }  
  
    public void push(int x) {  
        queue1.add(x);  
    }  
  
    public int pop() {  
        if (!empty()) {  
            int size = queue1.size();  
            while (size > 1) {  
                size--;  
                queue1.add(queue1.poll());  
            }  
            return queue1.poll();  
        }  
        return -1;  
    }  
  
    public int top() {  
        int res = pop();  
        push(res);  
        return res;  
    }  
  
    public boolean empty() {  
        return queue1.isEmpty();  
    }  
}

```
## 20. 有效的括号
### 题目:
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。
### 信息:
- **难度**: easy
- **重要性:** #★★★★☆
### 思路:
- 遇到左括号就入栈一个相应的右括号.遇到右括号就弹出栈顶元素进行匹配.此时
### 关键点:
- **遇到左括号,入栈对应右括号!**
### 代码:
```java
class Solution {  
    public boolean isValid(String s) {  
        if ((s.length() % 2) != 0) return false;  
        Stack<Character> stack = new Stack<>();  
  
        for (int i = 0; i < s.length(); i++){  
            char c = s.charAt(i);  
            if (c == '(') stack.push(')');  
            else if (c == '{') stack.push('}');  
            else if (c == '[') stack.push(']');  
            else if (stack.isEmpty() || stack.peek() != c) return false;  
            else stack.pop();  
        }  
        return stack.isEmpty();  
    }  
}
```
## 1047. 删除字符串中的所有相邻重复项
### 题目:
给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆
### 思路:
- 将当前元素与前一个入栈的元素进行比较.
- 若栈为空或字母与栈顶元素不匹配,则入栈;否则,将栈顶元素弹出.
### 关键点:
- 无.
### 代码:
```java
class Solution {  
    public String removeDuplicates(String s) {  
        Stack<Character> stack = new Stack<>();  
        if (s.length() == 1) return s;  
        for (int i = 0; i < s.length();i++){  
            char c = s.charAt(i);  
            if (stack.isEmpty() || stack.peek() != c) stack.push(c);  
            else stack.pop();  
        }  
        StringBuilder sb = new StringBuilder();  
        while (!stack.isEmpty()) sb.append(stack.pop());  
        return sb.reverse().toString();  
    }  
}
```


## 150. 逆波兰表达式求值
### 题目:
给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
**注意：**
- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路:
- 遇到这种需要返回前面的两个元素的,可以采用栈来实现.
- 若采用队列,则无法返回刚入栈的两个元素,而是返回最先入栈的两个元素.看似队列没问题,实则仔细思考,在`["4","13","5","/","+"]`时,此时采用队列的话,就会是4/13,无法获得正确答案!
### 关键点:
- 需要获得当前字符的前n个元素,可采用栈来实现!!!
### 代码:
```java
class Solution {  
    public int evalRPN(String[] tokens) {  
        Deque<Integer> stack = new LinkedList<>();  
        for (String s : tokens){  
	        // 判断当前字符数s是+,-,或/.
            if ("+-*/".contains(s)){  
                int a = stack.pop();  
                int b = stack.pop();  
                switch (s) {  
                // 弹出后两个计算,并再次入栈.
                    case "+" -> stack.push(b+a);  
                    case "-" -> stack.push(b-a);  
                    case "*" -> stack.push(b*a);  
                    case "/" -> stack.push(b/a);  
                }  
            }else  
	            // Integer.valueOf将字符串转换为Integer型.
                stack.push(Integer.valueOf(s));  
        }  
        return stack.pop();  
    }  
}
```
## 239. 滑动窗口最大值
### 题目:
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值.
### 信息:
- **难度**: hard
- **重要性:** #★★★★★
### 思路:
- 这题是单调队列的题目!获得窗口内的最值.
- 单调队列,用于获取队列/窗口内的最值,所以队顶必须为当前窗口内的最值.作为处理这类题目的特殊的队列,**与常规队列不同,无需维护窗口内的所有元素,只需要维护窗口内的最值即可**!
### 关键点:
- 单调队列的构造,无需维护窗口内所有元素.
### 代码:
```java
class Solution {  
    public int[] maxSlidingWindow(int[] nums, int k) {  
        MyQueue queue = new MyQueue();  
        int n = nums.length;  
        int[] res = new int[n-k+1];  
        if (n == 1 || k == 1) return nums;  
		// 先入队k-1个.
        for (int i = 0;i < k-1; i++){  
            queue.push(nums[i]);  
        }  
        // 入队,获得当前窗口最大值,出队.
        for (int i = 0; i <= (n-k);i++){  
            queue.push(nums[i+k-1]);  
            res[i] = queue.max();  
            queue.pop(nums[i]);  
        }  
        return res;  
    }  
}  
  
class MyQueue{  
	// 频繁增删,用LinkedList.
    Deque<Integer> que = new LinkedList<>();  
	// 为空则入队;或队底的元素小于当前元素,则弹出小的,推入大的.
    public void push(int n){  
        while (!que.isEmpty() && que.peekLast() < n){  
            que.pollLast();  
        }  
        que.add(n);  
    }  
	// 队顶始终为最大值,故返回peek()即可.
    public int max(){  
        return que.peek();  
    }  
	// 若移出窗口的元素在队顶,则移出.
    public void pop(int n){  
        if (!que.isEmpty() && n == que.peek()) que.poll();  
    }  
}
```

## 347. 前 K 个高频元素

### 题目:
给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路:
- 回想到之前存放字母出现的频次,因为小写字母只有26个,故可以用数组来存储.但对于数字,只能采用Map来存储,其中key为数字值,value为出现频次.
- 返回高频元素,可以采用优先级队列`PriorityQueue`.优先级队列是将入队元素按Comparator的顺序排列(即出现频次排列,默认为小顶堆).
>[!函数式接口Comparator中的方法compare(T o1,T o2)]
>当返回值为负数时,代表o1小于o2,返回值为正数时,代表o1>o2.
>**return o1-o2 ,代表升序排列.**

>[!小顶堆和大顶堆]
>小顶堆即队首元素最小,按升序排列;大顶堆则反过来,队顶元素最大,按降序排列. 对于此题,采用小顶堆较方便,因为可以更好的弹出频次较低的元素.
### 关键点:
- 采用Map存储数字的出现频次.
- 选取优先级队列存储,便于获得出现频次前k的元素.
### 代码:
此处的Comparator.comparingInt(map::get)不太好理解,可以转换成:
`(a,b) -> Integer.compare(map.get(a)-map.get(b))`
```java
class Solution {  
    public int[] topKFrequent(int[] nums, int k) {  
        HashMap<Integer,Integer> map = new HashMap<>();  
        // 存储数字出现的频次.
        for (int i = 0; i < nums.length;i++){  
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);  
        }  
	//优先级队列:指定队列大小为k,按Comparator.comparingInt(map::get)排序.
        Queue<Integer> queue1 = new PriorityQueue<>(k,Comparator.comparingInt(map::get));  
        // 入队,
        for (Integer key : map.keySet()){  
            queue1.add(key);  
            if (queue1.size() > k) queue1.poll();  
        }  
        int[] res = new int[k];  
        // 存储前k个高频元素.
        for (int i = 0; i < k; i++){  
            res[i] = queue1.poll();  
        }  
        return res;  
    }  
}
```