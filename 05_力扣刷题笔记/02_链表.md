## 203.移除链表元素
### 题目:
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
**输入:head = `[1,2,6,3,4,5,6]`, val = 6 输出：**`[1,2,3,4,5]`
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆

### 思路一：哨兵节点

**涉及到删除操作，一般需要考虑哨兵节点。**

执行删除节点node操作，可以通过修改next指针完成，所以应该在node的前一个节点处执行删除操作。

考虑到头节点没有“前一个节点”，所以必须使用哨兵节点dummy。

**具体如何执行？**
- 从哨兵节点开始遍历，判断其next节点的值是否为val：若是，则删除；若不是，往后遍历；
- 若成功删除，此时无需更新curr指针，因为在删除时已经更新过一次curr指针！若再次更新，则会错过节点。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null){
            if (curr.next.val == val){
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
            
        }
        return dummy.next;
    }
}
```

## 707.设计链表
### 题目:
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路一：
- 定义虚拟头节点，此时无论是添加节点到头部、还是删除头部节点，都会更方便。
- **初始化链表**：因为是无参构造器，所以直接初始化虚拟头节点与size即可。
- 要删除某个节点、添加节点到某个位置，都要注意**健壮性保证**：idx不能小于0，也不能大于等于size。
- **对于index的遍历，`for(int i = 0; i <=index; i++)`会刚好移动到`index`节点上！而对于添加到末尾，则直接`for(int i = 0; i < size; i++)`也会刚好移动到末尾。**
- 注意需要不断维护size的大小。

```java
class ListNode{
    int val;
    ListNode next;

    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
    public ListNode(int val,ListNode next){
        this.val = val;
        this.next = next;
    }
}

class MyLinkedList {
    private ListNode dummy;
    private int size;

    public MyLinkedList() {
        dummy = new ListNode(0);
        size = 0;
    }
    
    public int get(int index) {
        if (index >= size || index < 0) return -1;
        // 将curr移动到需要返回的节点上
        ListNode curr = dummy;
        for (int i = 0; i <= index; i++){
            curr = curr.next;
        }
        return curr.val;
    }
    
    public void addAtHead(int val) {
        ListNode newHead = new ListNode(val);
        // 更换头节点
        newHead.next = dummy.next;
        dummy.next = newHead;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);
        // 移动到末尾节点。
        ListNode curr = dummy;
        for (int i = 0; i < size; i++){
            curr = curr.next;
        }
        curr.next = tail;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        // 超出长度，不会插入
        if (index > size) return;
        // 插入到末尾
        if (index == size) {addAtTail(val);return;}
        
        ListNode newNode = new ListNode(val);
        // 移动到index节点之前。
        ListNode curr = dummy;
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        newNode.next = curr.next;
        curr.next = newNode;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        ListNode curr = dummy;
        // 移动到index前一个节点
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        curr.next = curr.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```
## 206.反转链表
### 题目
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
不涉及到头节点的增、删，无需使用哨兵节点。
涉及到操作`node.next`，必须使用next变量提前保存节点。

**具体算法流程：**
![[Pasted image 20241213102208.png]]

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode prev = null;  
        ListNode cur = head;  
        ListNode next = null;  
        while (cur != null){  
            next = cur.next;  
            cur.next = prev;  
            
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：利用栈暂存节点
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        Deque<ListNode> sta = new ArrayDeque<>();
        ListNode curr = head;
        while (curr != null){
            sta.push(curr);
            curr = curr.next;
        }
        if (sta.isEmpty()) return null;
        ListNode newHead = sta.pop();
        curr = newHead;

        while (!sta.isEmpty()){
            curr.next = sta.pop();
            curr = curr.next;
        }
        curr.next = null;
        return newHead;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 92. 反转链表 II
>**时间**：2025-03-01 10:11:23
### 题目
给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #链表 
### 思路一：利用栈实现
利用栈暂存需要交换的节点，并记录需要交换的头节点前的第一个、尾节点后的第一个节点，用于连接翻转后的子链表。
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // dummy节点, 便于头节点需要翻转时方便, 以及能快速返回结果.
        ListNode dummy = new ListNode(0,head);
        ListNode prev = dummy;
        // 找到需要交换的节点的前一个位置
        for (int i = 0; i < left-1; i++) {
            prev = prev.next;
        }
        // curr为第一个需要交换的节点
        ListNode curr = prev.next;
        Deque<ListNode> sta = new ArrayDeque<>();
        for (int i = 0; i < (right-left+1); i++) {
            sta.push(curr);
            curr = curr.next;
        }
        // 记录尾节点的后一个节点, 用于连接.
        // 注意, curr是否可能为null?    
        ListNode last = curr;

        while (!sta.isEmpty()) {
            prev.next = sta.pop();
            prev = prev.next;
        }
        prev.next = last;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：
反转思路与反转链表一致，不过这里需要额外记录反转前的头节点`p0`，便于反转后进行连接。
最后的连接思路：
- `p0.next.next = curr;`：由于p0.next这个指针并未被"斩断"，此时`p0.next`指向的是反转前的`left`节点，因此`p0.next.next = curr`表示末端的连接。
- `p0.next = prev;`：代表与反转后的头节点进行连接。

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 懂了, 先记住反转前的头尾节点, 然后常规反转即可, 最后再进行连接.
        ListNode dummy = new ListNode(0,head);
        ListNode p0 = dummy;
        for (int i = 0; i < left-1; i++) {
            p0 = p0.next;
        }
        ListNode prev = null;
        ListNode curr = p0.next;
        for (int i = 0; i < (right-left+1); i++) {
            ListNode next = curr.next;
            curr.next = prev;
            
            prev = curr;
            curr = next;
        }
        p0.next.next = curr;
        p0.next = prev;

        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 25. K 个一组翻转链表
### 题目
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #链表 #递归 
### 思路一：
![[Pasted image 20241215122040.png]]
![[Pasted image 20250122212418.png]]
**具体算法流程：**
1. 获取链表长度，便于判断剩余节点是否大于k；
2. 定义变量：`prev, curr, next`用于进行k个一组翻转操作，`p0` 用来标记当前要处理的节点之前的节点。
3. k个一组翻转链表；
	- ![[Pasted image 20250303120620.png]]
4. **连接反转后的部分与未反转的部分。**
	- `p0`初始为**反转前部分的头节点的前一个**，最开始为dummy节点；
	- 翻转后，要将翻转前部分与翻转后部分连接起来，即：
		- **保存next节点，用于更新p0**：首先保存p0.next，这是后续的p0节点；
		- **连接已翻转部分与后续尚未翻转部分**：将p0.next.next指向后续的头节点，也就是未翻转部分的头节点【】；
		- **与刚翻转部分的头节点连接**：与将p0.next指向翻转后的头节点，也就是curr；
		- **更新p0**：更新p0，继续执行下一次翻转操作。

```java 
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int sz = 0;
        ListNode curr = head;
        // 获取链表长度
        while (curr != null) {
            curr = curr.next;
            sz++;
        }
        curr = head;
        ListNode dummy = new ListNode(0,head);
        ListNode prev = null;
        ListNode next = null;
        ListNode p0 = dummy;
        // 至少含有k个节点才进行翻转
        while (sz >= k){
            // k个一组翻转
            for (int i = 0; i < k; i++){
                next = curr.next;
                curr.next = prev;

                prev = curr;
                curr = next;
            }
            // 保存next节点，用于后续更新p0
            next = p0.next;
            // 已翻转部分与未翻转部分的连接(尾连接)
            p0.next.next = curr;
            // 连接已翻转的头节点(头连接)
            p0.next = prev;
            // 更新p0节点，以进行后续的翻转操作
            p0 = next;
            sz -= k;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 24.两两交换链表中的节点
### 题目:
- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路一：
定义虚拟头节点，方便对头节点执行交换操作。

注意，在交换过程中，**节点2到节点3的指针**和**节点0到节点1的指针**会断，所以此时必须提前保存节点1和节点3.

为了方便操作，我们可以提前保存`node0``node1``node2``node3`，不过node2的提前保存，是为了操作的便利性与美观，即使不保存也可以完成所有的交换逻辑。（见思路二）

**三步交换：**
1. `node0→node2`（这一步，0到1的指针断了，故需要提前保存）
2. `node2→node1`（在这一步，2到3的指针断掉，故需要提前保存）
3. `node1→node3`（将node1的下一位更新为提前保存好的node3节点）

**node节点更新操作：**
因为节点交换后，链表变为`(0)→2→1→3→4`，所以更新操作为：
1. `node0 = node1`；
2. `node1 = node3`

![[Pasted image 20241206151338.png|400]]

**交换节点时，按照2、1、0的顺序交换。**
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = head;
        
        while (node1 != null && node1.next != null) {
            ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node2.next = node1;
            node1.next = node3;
            node0.next = node2;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
### 思路二：
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            // ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node0.next = node1.next;
            node1.next.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
## 19.删除链表的倒数第N个节点 
### 题目
- 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
### 信息
- **难度：**medium
- **重要性：** #★★★☆☆
### 思路一：快慢指针
利用快慢指针获取倒数第n个节点。
**证明：**
设链表长度为size，则要到达倒数第n个节点，需要正向遍历size-n次。

所以，先让快指针向右移动n次，然后快慢指针再同时移动。此时快指针只能再向后移动$size-n$次。那么此时，慢指针与快指针同步移动，代表着慢指针也只能移动$size-n$次！

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        // 快指针先向右移动n次
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        // 移动sz-n次, 此时slow指向待删除节点的前一个节点。
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        // 删除！
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```
时间复杂度：$O(N)$
空间复杂度：$O(1)$
### 思路二：两次遍历
第一次遍历，先获取链表尺寸；
第二次遍历，根据sz-n，移动到指定位置进行删除操作。
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 难点在于：如何找到第n个结点？
        // 两次遍历:第一次获取size,第二次遍历size-n次即可.
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        int sz = 0;
        while (curr.next != null){
            curr = curr.next;
            sz++;
        }
        curr = dummy;
        for (int i = 0; i < sz-n; i++){
            curr = curr.next;
        }
        if (curr.next.next != null) curr.next = curr.next.next;
        else curr.next = null;

        return dummy.next;
    }
}
```
## 141. 环形链表
### 题目
给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：快慢指针
**弗洛伊德判圈问题**！

定义快慢指针，快指针每次走2步，慢指针每次走1步。若有环，则二者最终会相遇。

**具体算法流程：**
1. 定义slow和fast指针起点相同；
2. 循环退出条件为`fast==null || fast.next ==null`，即存在null节点。（`fast.next != null`是为了保证接下来更新操作的正确）
3. slow每次走1步，fast每次走2步；
4. 若出现相等，则返回true；若fast出现null，则退出循环，返回false。
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 面试题 02.07. 链表相交
### 题目:
- 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
### 信息:
- **难度：** easy
- **重要性：** #★★★☆☆
### 思路一：双指针
将两条链表相连，可以使他们走过相同长度的路径。

当指针curr指向null时，切换到另一条链表遍历，最后会出现两种情况：
- 存在相交节点，此时指针currA和currB会指向同一个节点，退出循环；
- 不存在相交节点，此时currA和currB会同时指向null，退出循环。
所以最终直接返回currA或currB即可。
```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode currA = headA;  
        ListNode currB = headB;  
        while (currA != currB){  
            if (currA != null) {  
                currA = currA.next;  
            }else {  
                currA = headB;  
            }  
            if (currB != null) {  
                currB = currB.next;  
            }else {  
                currB = headA;  
            }  
        }  
        return currA;  
    }  
}
```
### 思路二：利用Set判重
利用Set判重：
- 假设有相交节点，那么代表一定会添加重复节点，此时返回该节点即可；
- 利用`change`变量，避免在另一条链表中重复遍历。（假设无change变量判断，那么在更换到另一条链表遍历时，到达null后会再次循环。）
```java 
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode curr = headA;
        boolean change = false;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
                if (curr == null && !change){
                    curr = headB;
                    change = true;
                }    
            }else {
                return curr;
            }
        }
        return null;
    }
}
```
## 142. 环形链表II
### 题目
- 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。**不允许修改链表。** 
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- 
### 思路一：快慢指针
- 带有考察数学知识的题目.需要进行细心的推理!**首先**,明确一点,当有环时,可以转化为一个追赶问题,即**步长为2的快指针一定会追赶上步长为1的慢指针**,因为他们之间的距离是以不断减1的!据此,是否有环的逻辑完成,接下来就是判断环的起点!这里用一个图和公式进行说明:![[LinkedListPart2_img2.png]]
当**快慢指针相遇**时,有以下情况:
- 慢指针走过的节点数为$x+y$,快指针走过的节点数为$x+y+n(y+z)$,并且由于慢指针的步长为1,快指针的步长为2,所以有$(x+y)\times2=x+y+n(y+z)$
- 据此可推出→ $x+y=n(y+z)$.即头节点到环形入口节点的节点数目$x=n(y+z)-y$
- 理解一下,当n=1时,此时$x=z$;当n≠1时,此时$x=n(y+z)-y$,即走过了n个环的节点数$n(y+z)$-环形入口到相遇节点的节点数y.
```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        if (head == null || head.next == null) {  
            return null;  
        }  
        ListNode fast = head;  
        ListNode slow = head;  
  
        while (fast != null && fast.next != null){  
            fast = fast.next.next;  
            slow = slow.next;  
  
            if (fast == slow) {  
                slow = head;  
  
                while (fast != slow) {  
                    fast = fast.next;  
                    slow = slow.next;  
                }  
                return fast;  
            }  
        }  
        return null;  
    }  
}
```
#### 思路一的另外写法：
- 退出循环有两种条件：`fast == slow`，或f`ast == null || fast.next == null`，因此我们可以第二个条件来判断无环；
- 如何找到入环节点：令slow回到头节点，fast保持不变，让二者走过相同的距离，则当二者相遇，即为入环节点。
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        if (fast == null || fast.next == null) return null;
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

### 思路二：O(n)空间复杂度解决
利用Set判重：
- 当set添加失败后，则说明当前节点是入口，返回该节点即可。
- 如果一直添加失败，说明无环，返回null.
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 思路一：O(n)复杂度解决，利用Set判重。
        Set<ListNode> set = new HashSet<>();
        ListNode curr = head;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
            }else {
                return curr;
            }
        }
        return null;
    }
}
```

## 287. 寻找重复数
### 题目
给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

	输入：nums = [1,3,4,2,2]
	输出：2
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #数组 #二分查找 #双指针 
### 思路一：构造链表
思路很牛逼。因为题目所给条件为数组下标由`[0,n+1]`，而数组的值为`0,n`。因此，若根据数组的值与下标构建映射关系，不会出现越界的情况。即不会出现：数组索引为`0,3`，而数组的值出现`nums[i] == 4`的情况。

根据上述推断，我们可以构建`i -> nums[i]`的映射关系。对于`[1,3,4,2,2]`，就可以构建出**环形链表**：![[Pasted image 20250109110043.png]]
既然已经构建出了环形链表，那么就转换为了“**龟兔赛跑问题**”！使用**Floyd判圈算法**求解！！！
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
		// 提前走, 以保证能进入while(slow!=fast)循环
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast){
            // slow走一步，fast走两步
            slow = nums[slow];
            fast =nums[nums[fast]];
        }
        // 相遇后，slow从头开始
        slow = 0;
        while (fast != slow){
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 234. 回文链表
### 题目
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：转换为list判回文
将链表判回文**转换为数组判回文**！转换后利用双指针判是否回文即可！！！
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        int n = 0;
        ListNode curr = head;
        List<Integer> nums = new ArrayList<>();
        // 获取值列表
        while (curr != null){
            nums.add(curr.val);
            curr = curr.next;    
        }
        int l = 0;
        int r = nums.size()-1;
        while (l < r){
            if (nums.get(l++) != nums.get(r--)) return false;
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：通过翻转链表转换为两个链表判相等

**具体算法流程：**
- 获取链表长度，将后半部分链表翻转；
- 翻转链表后，转换为两个链表判相等的问题。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode curr1 = head;
        int n = 0;
        // 获取链表长度
        while (curr1 != null){
            n++;
            curr1 = curr1.next;
        }
        // 寻找中间节点
        ListNode curr2 = head;
        for (int i = 0; i < n/2; i++){
            curr2 = curr2.next;
        }
        ListNode prev = null;
        ListNode next = null;
         
        // 翻转后半部分链表
        while (curr2 != null){
            next = curr2.next;
            curr2.next = prev;

            prev = curr2;
            curr2 = next;
            
        }
        // 转换为两个链表判相等
        curr1 = head;
        curr2 = prev;
        while(curr1 != null && curr2 != null){
            if (curr1.val != curr2.val) return false;
            curr1 = curr1.next;
            curr2 = curr2.next;
        }
        return true;
    }
}
```


## 21. 合并两个有序链表
### 题目
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 
### 思路一：双指针
定义dummy节点，便于返回最终头节点。

**具体算法流程：**
- 当$list1$和$list2$均不为空时，比较$list1$和$list2$的值，$curr.next$指向较小一个；然后更新$list1$或$list2$，更新$curr$。
- 若某一个为空，则$curr.next$直接执行不为空的$list$。

>**注意，直接操作list节点即可，无需使用额外curr1指向list1。**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null){
            return list1 == null ? list2 : list1;
        }
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        
        while (list1 != null && list2 != null){
            if (list1.val < list2.val){
                curr.next = list1;
                list1 = list1.next;
            }else {
                curr.next = list2;
                list2 = list2.next;
            }
            curr = curr.next;
        }
        curr.next = list1 == null ? list2 : list1;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(M+N)$ 
**空间复杂度：** $O(1)$

## 2. 两数相加
### 题目
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
利用car变量保存进位；构建新节点时，利用$car\%10$获取个位；利用$car/10$获取十位（**`car>=10`时，进位为1，`car<10`时，进位为0，所以可以通过car/=10获取！**）

**具体算法流程：**
1. 当`l1 != null || l2 != null || car != 0`时进入循环，此时都需要构建新节点；
2. 利用car变量保存`进位+l1+l2`的值；
3. 构建新节点：节点值为$car\%10$；
4. $car/=10$获取进位，开始下一次循环。
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        int car = 0;
        while (l1 != null || l2 != null || car != 0){
            if (l1 != null){
                car += l1.val;
                l1 = l1.next;
            }
            if (l2 != null){
                car += l2.val;
                l2 = l2.next;
            }
            curr.next = new ListNode(car % 10);
            car /= 10;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$，返回值不计入。
### 思路二：递归
递归解决子问题，需要传递进位。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwo(l1,l2,0);
    }
    ListNode addTwo(ListNode l1, ListNode l2, int car){
        if (l1 == null && l2 == null){
            return car == 0 ? null : new ListNode(car);
        }
		// 交换l1和l2，避免后面l1.next的分类讨论，简化代码。
        if (l1 == null){
            l1 = l2;
            l2 = null;
        }
        int sum = l1.val + car + (l2 == null ? 0 : l2.val);

        l1.val = sum % 10;
        l1.next = addTwo(l1.next,l2 == null ? null : l2.next,sum / 10);
        return l1;
    }
}
```
## 138. 随机链表的复制
### 题目
给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
![[Pasted image 20241216113122.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #哈希表 
### 思路一：哈希表
本题的难点在于，构建新链表时如何连接next与curr指针，因为此时他们可能尚未创建出来！因此我们提前创建节点，并**利用哈希表存储原节点和新节点的对应关系**，之后再遍历原链表，根据原节点获取新节点，并进行连接。最终通过head指针即可获取并返回新链表的头节点。


```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node,Node> map = new HashMap<>();
        Node curr =  head;
        
        while (curr != null){
            // 深拷贝
            map.put(curr,new Node(curr.val,curr.random));
            curr = curr.next;
        }
        curr = head;
        while (curr != null){
            // 根据原链表的连接关系构建新链表
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        return map.get(head);
        
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：交错链表
**具体算法流程：**
1. 将原链表更新成交错链表：
![[Pasted image 20241216130441.png|600]]
2. 根据原链表的random，设置新链表的random；
3. 最后恢复原链表！
```java

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        Node curr = head;
        // 1. 设置交错链表
        while (curr != null){
            Node newNode = new Node(curr.val);
            Node tmp = curr.next;
            curr.next = newNode;
            newNode.next = tmp;
			
            // curr.next = new Node(curr.val, curr.next);

            curr = curr.next.next;
        }
        //  2. 根据原节点设置新节点的random
        curr = head;
        while (curr != null){
            if (curr.random != null){
                curr.next.random = curr.random.next;
            }
            curr = curr.next.next;
        }
        // 3. 构建新链表，恢复原链表
        Node newHead = head.next; // 开头保证了head != null
        curr = head;
        while (curr.next.next != null){
            Node copy = curr.next;
            curr.next = copy.next;
			copy.next = copy.next.next;    // 保证curr.next.next != null

            curr = curr.next;
        }
        curr.next = null;
        return newHead;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 23. 合并 K 个升序链表
### 题目
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
### 信息
- **难度：** hard
- **重要性：** #★★★★☆
- **标签：** #链表 #堆（优先级队列） #排序 
### 思路一：小根堆
因为K个链表都是升序的，所以当前的最小值只可能出现在头节点中。因此：
1. 将K个链表的头节点都加入优先队列中；
2. 当某个链表的头节点被弹出后，将其的next节点也加入到链表中；
3. 直至K个链表都为空。
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // 按节点值升序排列
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        // 添加头节点
        for (ListNode node : lists){
            if (node != null) pq.add(node);
        }
        ListNode dummy = new ListNode();
        ListNode curr = dummy;
        while (!pq.isEmpty()){
            // 取最小值
            ListNode min = pq.poll();
            curr.next = min;
            // 将对应链表的下个节点也加入堆中
            if (min.next != null){
                pq.add(min.next);
            }
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$

## 148. 排序链表
### 题目
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 #分治 #排序 #归并排序
### 思路一：优先队列
使用优先队列将链表按值由小到大排序，然后利用哨兵节点连接排序后的节点。最后记得断开末尾节点的next指针。
```java
class Solution {
    public ListNode sortList(ListNode head) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        ListNode curr = head;
        while (curr != null){
            pq.add(curr);
            curr = curr.next;
        }
        ListNode dummy = new ListNode();
        curr = dummy;
        while (!pq.isEmpty()){
            curr.next = pq.poll();
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路二：使用ArrayList进行排序
```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        ListNode curr = head;
        while (curr != null){
            list.add(curr);
            curr = curr.next;
        }
        Collections.sort(list,(a,b) -> a.val - b.val);
        ListNode dummy = new ListNode();
        curr = dummy;
        for (ListNode node : list){
            curr.next = node;
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路三：归并排序

## 146. LRU 缓存
### 题目
请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #链表 #哈希表 
### 思路一：循环双向链表+哈希表
**先明确几个关键点：**
1. 使用的是双向循环链表，便于快速获取尾节点；
2. 链表节点需要存储Key值，是为了在Map中定位节点并删除（`map.remove(lastNode.key)`）；
	- 如果只有value，那么因为value是可能重复的，则无法在map中定位并获取节点。
3. 需要定义三个私有方法：`getNode()`、`remove()`、`pushFront()`；并且每次`getNode()`都需要`remove&pushFront`!
```java
class Node {
    int val;
    int key;
    Node prev;
    Node next;
    public Node(int key,int value){
        this.key = key;
        this.val = value;
    }
}
class LRUCache {
    private Map<Integer,Node> map;
    private Node dummy;
    private int capacity;
    public LRUCache(int capacity) {
        map = new HashMap<>();
        this.capacity = capacity;
        dummy = new Node(0,0);
        dummy.next = dummy;
        dummy.prev = dummy;

    }
    
    public int get(int key) {
        Node node = getNode(key);
        return node != null ? node.val : -1;
    }
    
    public void put(int key, int value) {
        Node node = getNode(key);
        // 已存在，变更数据值   
        if (node != null) {
            node.val = value;
            return;
        }
        // 不存在，插入数据
        node = new Node(key,value);
        map.put(key,node);
        pushFront(node);
        
        // 超过容量，移除元素
        if (map.size() > capacity){
            Node lastNode = dummy.prev;
            map.remove(lastNode.key);
            remove(lastNode);
        }
    }
    // 移除节点
    void remove(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    // 将节点放置到链表头
    void pushFront(Node node){
        node.next = dummy.next;
        dummy.next.prev = node;
        dummy.next = node;
        node.prev = dummy;
    }
    // 根据key获取某个节点
    Node getNode(int key){
        // 判断节点是否存在 
        Node node = map.get(key);
        if (node == null) return node;
        
        remove(node);
        pushFront(node);

        return node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

## 86. 分隔链表
>**时间**：2025-02-08 16:52:06
### 题目
给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：O(N)空间复杂度
分别使用两个集合存储较小的节点和较大的节点。
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        List<ListNode> lowList = new ArrayList<>();
        List<ListNode> highList = new ArrayList<>();

        ListNode curr = head;
        while (curr != null){
            if (curr.val >= x){
                highList.add(curr);
            }else {
                lowList.add(curr);
            }
            curr = curr.next;
        }
        ListNode dummy = new ListNode(0);
        curr = dummy;
        for (int i = 0; i < lowList.size(); i++){
            curr.next = lowList.get(i);
            curr = curr.next;
        }
        for (int i = 0; i < highList.size(); i++){
            curr.next = highList.get(i);
            curr = curr.next;
        }
        curr.next = null;
        return dummy.next;
    } 
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

### 思路二：双指针
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode lowDummy = new ListNode(0);
        ListNode highDummy = new ListNode(0);

        ListNode lowP = lowDummy;
        ListNode highP = highDummy;

        ListNode curr = head;
        while (curr != null){
            if (curr.val < x){
                lowP.next = curr;
                lowP = lowP.next;
            }else {
                highP.next = curr;
                highP = highP.next;
            }
            curr = curr.next;
        }
        lowP.next = highDummy.next;
        highP.next = null;

        return lowDummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 1206. 设计跳表
>**时间**：2025-03-03 17:06:09
### 题目
不使用任何库函数，设计一个 **跳表** 。

**跳表** 是在 `O(log(n))` 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

例如，一个跳表包含 `[30, 40, 50, 60, 70, 90]` ，然后增加 `80`、`45` 到跳表中，以下图的方式操作：
![](https://pic.leetcode.cn/1702370216-mKQcTt-1506_skiplist.gif)

跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 `O(n)`。跳表的每一个操作的平均时间复杂度是 `O(log(n))`，空间复杂度是 `O(n)`。

了解更多 : [https://oi-wiki.org/ds/skiplist/](https://oi-wiki.org/ds/skiplist/)

在本题中，你的设计应该要包含这些函数：

- `bool search(int target)` : 返回target是否存在于跳表中。
- `void add(int num)`: 插入一个元素到跳表。
- `bool erase(int num)`: 在跳表中删除一个值，如果 `num` 不存在，直接返回false. 如果存在多个 `num` ，删除其中任意一个即可。

注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #设计 #链表 
### 思路一：
`forward`指针的含义：
- `forward[i]`代表当前节点在第i层的下一个节点。以下图为例，`Node(30)`的`forward[0]=Node(40)`, `Node(40)`的`forward[0]=Node(50)`，Node
![[Pasted image 20250303170906.png]]
```java
class Skiplist {
    // 定义节点
    class Node {
        int val;
        Node[] forward;
        
        public Node(int val, int level) {
            this.val = val;
            // 每个节点维护一个 forward 数组，表示在每一层的下一个节点指针
            forward = new Node[level];
        }
    }
    
    private static final int MAX_LEVEL = 16; // 最大层数
    private static final double P = 0.5;       // 随机提升的概率因子
    private Node head;                       // 跳表头节点
    private int level;                       // 当前跳表最高层
    
    /** 初始化跳表 */
    public Skiplist() {
        head = new Node(-1, MAX_LEVEL); // 哨兵节点，值可以任意设置
        level = 1;
    }
    
    /** 随机生成节点的层数 */
    private int randomLevel() {
        int lvl = 1;
        // 当随机数小于 P 时增加层数，最高不超过 MAX_LEVEL
        while (Math.random() < P && lvl < MAX_LEVEL) {
            lvl++;
        }
        return lvl;
    }
    
    /** 返回 target 是否存在于跳表中 */
    public boolean search(int target) {
        Node curr = head;
        // 从最高层开始查找
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < target) {
                curr = curr.forward[i];
            }
        }
        curr = curr.forward[0];
        return (curr != null && curr.val == target);
    }
    /** 插入一个元素到跳表中 */
    public void add(int num) {
        Node[] update = new Node[MAX_LEVEL];
        Node curr = head;
        // 找到每一层中，应该插入新节点的位置的前驱节点
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < num) {
                curr = curr.forward[i];
            }
            update[i] = curr;
        }
        
        // 生成新节点的层数
        int lvl = randomLevel();
        // 如果新节点层数超过当前跳表层数，需要更新 update 数组为头节点
        if (lvl > level) {
            for (int i = level; i < lvl; i++) {
                update[i] = head;
            }
            level = lvl;
        }
        Node newNode = new Node(num, lvl);
        // 在各层中插入新节点
        for (int i = 0; i < lvl; i++) {
            newNode.forward[i] = update[i].forward[i];
            update[i].forward[i] = newNode;
        }
    }
    
    /** 在跳表中删除一个值，若存在多个相同值则删除其中一个，返回是否删除成功 */
    public boolean erase(int num) {
        Node[] update = new Node[MAX_LEVEL];
        Node curr = head;
        // 找到各层中待删除节点的前驱节点
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < num) {
                curr = curr.forward[i];
            }
            update[i] = curr;
        }
        curr = curr.forward[0];
        // 如果目标节点不存在，返回 false
        if (curr == null || curr.val != num) {
            return false;
        }
        // 在每一层中更新指针，跳过待删除的节点
        for (int i = 0; i < level; i++) {
            if (update[i].forward[i] != curr) {
                break;
            }
            update[i].forward[i] = curr.forward[i];
        }
        // 如果最高层变空，则降低跳表层数
        while (level > 1 && head.forward[level - 1] == null) {
            level--;
        }
        return true;
    }
}
```
