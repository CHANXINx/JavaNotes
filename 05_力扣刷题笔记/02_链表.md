## 203.移除链表元素
### 题目:
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
**输入:head = `[1,2,6,3,4,5,6]`, val = 6 输出：**`[1,2,3,4,5]`
### 信息:
- **难度**: easy
- **重要性:** #★★★☆☆

### 思路一：哨兵节点

**涉及到删除操作，一般需要考虑哨兵节点。**

执行删除节点node操作，可以通过修改next指针完成，所以应该在node的前一个节点处执行删除操作。

考虑到头节点没有“前一个节点”，所以必须使用哨兵节点dummy。

**具体如何执行？**
- 从哨兵节点开始遍历，判断其next节点的值是否为val：若是，则删除；若不是，往后遍历；
- 若成功删除，此时无需更新curr指针，因为在删除时已经更新过一次curr指针！若再次更新，则会错过节点。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null){
            if (curr.next.val == val){
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
            
        }
        return dummy.next;
    }
}
```

## 707.设计链表
### 题目:
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
### 信息:
- **难度**: Medium
- **重要性:** #★★★☆☆
### 思路一：
- 定义虚拟头节点，此时无论是添加节点到头部、还是删除头部节点，都会更方便。
- **初始化链表**：因为是无参构造器，所以直接初始化虚拟头节点与size即可。
- 要删除某个节点、添加节点到某个位置，都要注意**健壮性保证**：idx不能小于0，也不能大于等于size。
- **对于index的遍历，`for(int i = 0; i <=index; i++)`会刚好移动到`index`节点上！而对于添加到末尾，则直接`for(int i = 0; i < size; i++)`也会刚好移动到末尾。**
- 注意需要不断维护size的大小。

```java
class ListNode{
    int val;
    ListNode next;

    public ListNode(){}
    public ListNode(int val){
        this.val = val;
    }
    public ListNode(int val,ListNode next){
        this.val = val;
        this.next = next;
    }
}

class MyLinkedList {
    private ListNode dummy;
    private int size;

    public MyLinkedList() {
        dummy = new ListNode(0);
        size = 0;
    }
    
    public int get(int index) {
        if (index >= size || index < 0) return -1;
        // 将curr移动到需要返回的节点上
        ListNode curr = dummy;
        for (int i = 0; i <= index; i++){
            curr = curr.next;
        }
        return curr.val;
    }
    
    public void addAtHead(int val) {
        ListNode newHead = new ListNode(val);
        // 更换头节点
        newHead.next = dummy.next;
        dummy.next = newHead;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);
        // 移动到末尾节点。
        ListNode curr = dummy;
        for (int i = 0; i < size; i++){
            curr = curr.next;
        }
        curr.next = tail;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        // 超出长度，不会插入
        if (index > size) return;
        // 插入到末尾
        if (index == size) {addAtTail(val);return;}
        
        ListNode newNode = new ListNode(val);
        // 移动到index节点之前。
        ListNode curr = dummy;
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        newNode.next = curr.next;
        curr.next = newNode;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        ListNode curr = dummy;
        // 移动到index前一个节点
        for (int i = 0; i < index; i++){
            curr = curr.next;
        }
        curr.next = curr.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```
## 206.反转链表
### 题目
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
不涉及到头节点的增、删，无需使用哨兵节点。
涉及到操作`node.next`，必须使用next变量提前保存节点。

**具体算法流程：**
![[Pasted image 20241213102208.png]]

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode prev = null;  
        ListNode cur = head;  
        ListNode next = null;  
        while (cur != null){  
            next = cur.next;  
            cur.next = prev;  
            
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：利用栈暂存节点
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        Deque<ListNode> sta = new ArrayDeque<>();
        ListNode curr = head;
        while (curr != null){
            sta.push(curr);
            curr = curr.next;
        }
        if (sta.isEmpty()) return null;
        ListNode newHead = sta.pop();
        curr = newHead;

        while (!sta.isEmpty()){
            curr.next = sta.pop();
            curr = curr.next;
        }
        curr.next = null;
        return newHead;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 92. 反转链表 II
>**时间**：2025-03-01 10:11:23
### 题目
给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #链表 
### 思路一：利用栈实现
利用栈暂存需要交换的节点，并记录需要交换的头节点前的第一个、尾节点后的第一个节点，用于连接翻转后的子链表。
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // dummy节点, 便于头节点需要翻转时方便, 以及能快速返回结果.
        ListNode dummy = new ListNode(0,head);
        ListNode prev = dummy;
        // 找到需要交换的节点的前一个位置
        for (int i = 0; i < left-1; i++) {
            prev = prev.next;
        }
        // curr为第一个需要交换的节点
        ListNode curr = prev.next;
        Deque<ListNode> sta = new ArrayDeque<>();
        for (int i = 0; i < (right-left+1); i++) {
            sta.push(curr);
            curr = curr.next;
        }
        // 记录尾节点的后一个节点, 用于连接.
        // 注意, curr是否可能为null?    
        ListNode last = curr;

        while (!sta.isEmpty()) {
            prev.next = sta.pop();
            prev = prev.next;
        }
        prev.next = last;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：
反转思路与反转链表一致，不过这里需要额外记录反转前的头节点`p0`，便于反转后进行连接。
最后的连接思路：
- `p0.next.next = curr;`：由于p0.next这个指针并未被"斩断"，此时`p0.next`指向的是反转前的`left`节点，因此`p0.next.next = curr`表示末端的连接。
- `p0.next = prev;`：代表与反转后的头节点进行连接。

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 懂了, 先记住反转前的头尾节点, 然后常规反转即可, 最后再进行连接.
        ListNode dummy = new ListNode(0,head);
        ListNode p0 = dummy;
        for (int i = 0; i < left-1; i++) {
            p0 = p0.next;
        }
        ListNode prev = null;
        ListNode curr = p0.next;
        for (int i = 0; i < (right-left+1); i++) {
            ListNode next = curr.next;
            curr.next = prev;
            
            prev = curr;
            curr = next;
        }
        p0.next.next = curr;
        p0.next = prev;

        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 25. K 个一组翻转链表
### 题目
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #链表 #递归 
### 思路一：
![[Pasted image 20241215122040.png]]
![[Pasted image 20250122212418.png]]
**具体算法流程：**
1. 获取链表长度，便于判断剩余节点是否大于k；
2. 定义变量：`prev, curr, next`用于进行k个一组翻转操作，`p0` 用来标记当前要处理的节点之前的节点。
3. k个一组翻转链表；
	- ![[Pasted image 20250303120620.png]]
4. **连接反转后的部分与未反转的部分。**
	- `p0`初始为**反转前部分的头节点的前一个**，最开始为dummy节点；
	- 翻转后，要将翻转前部分与翻转后部分连接起来，即：
		- **保存next节点，用于更新p0**：首先保存p0.next，这是后续的p0节点；
		- **连接已翻转部分与后续尚未翻转部分**：将p0.next.next指向后续的头节点，也就是未翻转部分的头节点【】；
		- **与刚翻转部分的头节点连接**：与将p0.next指向翻转后的头节点，也就是curr；
		- **更新p0**：更新p0，继续执行下一次翻转操作。

```java 
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int sz = 0;
        ListNode curr = head;
        // 获取链表长度
        while (curr != null) {
            curr = curr.next;
            sz++;
        }
        curr = head;
        ListNode dummy = new ListNode(0,head);
        ListNode prev = null;
        ListNode next = null;
        ListNode p0 = dummy;
        // 至少含有k个节点才进行翻转
        while (sz >= k){
            // k个一组翻转
            for (int i = 0; i < k; i++){
                next = curr.next;
                curr.next = prev;

                prev = curr;
                curr = next;
            }
            // 保存next节点，用于后续更新p0
            ListNode nxtP0 = p0.next;
            // 已翻转部分与未翻转部分的连接(尾连接)
            p0.next.next = curr;
            // 连接已翻转的头节点(头连接)
            p0.next = prev;
            // 更新p0节点，以进行后续的翻转操作
            p0 = nxtP0;
            sz -= k;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 24.两两交换链表中的节点
### 题目:
- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
### 信息:
- **难度**: medium
- **重要性:** #★★★★★
### 思路一：
定义虚拟头节点，方便对头节点执行交换操作。

注意，在交换过程中，**节点2到节点3的指针**和**节点0到节点1的指针**会断，所以此时必须提前保存节点1和节点3.

为了方便操作，我们可以提前保存`node0``node1``node2``node3`，不过node2的提前保存，是为了操作的便利性与美观，即使不保存也可以完成所有的交换逻辑。（见思路二）

**三步交换：**
1. `node0→node2`（这一步，0到1的指针断了，故需要提前保存）
2. `node2→node1`（在这一步，2到3的指针断掉，故需要提前保存）
3. `node1→node3`（将node1的下一位更新为提前保存好的node3节点）

**node节点更新操作：**
因为节点交换后，链表变为`(0)→2→1→3→4`，所以更新操作为：
1. `node0 = node1`；
2. `node1 = node3`

![[Pasted image 20241206151338.png|400]]

**交换节点时，按照2、1、0的顺序交换。**
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = head;
        
        while (node1 != null && node1.next != null) {
            ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node2.next = node1;
            node1.next = node3;
            node0.next = node2;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
### 思路二：
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode node0 = dummy;
        ListNode node1 = dummy.next;

        while (node1 != null && node1.next != null){
            // ListNode node2 = node1.next;
            ListNode node3 = node1.next.next;

            node0.next = node1.next;
            node1.next.next = node1;
            node1.next = node3;

            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
}
```
## 19.删除链表的倒数第N个节点 
### 题目
- 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
### 信息
- **难度：**medium
- **重要性：** #★★★☆☆
### 思路一：快慢指针
利用快慢指针获取倒数第n个节点。
**证明：**
设链表长度为size，则要到达倒数第n个节点，需要正向遍历size-n次。

所以，先让快指针向右移动n次，然后快慢指针再同时移动。此时快指针只能再向后移动$size-n$次。那么此时，慢指针与快指针同步移动，代表着慢指针也只能移动$size-n$次！

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        // 快指针先向右移动n次
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        // 移动sz-n次, 此时slow指向待删除节点的前一个节点。
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        // 删除！
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```
时间复杂度：$O(N)$
空间复杂度：$O(1)$
### 思路二：两次遍历
第一次遍历，先获取链表尺寸；
第二次遍历，根据sz-n，移动到指定位置进行删除操作。
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 难点在于：如何找到第n个结点？
        // 两次遍历:第一次获取size,第二次遍历size-n次即可.
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        int sz = 0;
        while (curr.next != null){
            curr = curr.next;
            sz++;
        }
        curr = dummy;
        for (int i = 0; i < sz-n; i++){
            curr = curr.next;
        }
        if (curr.next.next != null) curr.next = curr.next.next;
        else curr.next = null;

        return dummy.next;
    }
}
```
## 141. 环形链表
### 题目
给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：快慢指针
**弗洛伊德判圈问题**！

定义快慢指针，快指针每次走2步，慢指针每次走1步。若有环，则二者最终会相遇。

**具体算法流程：**
1. 定义slow和fast指针起点相同；
2. 循环退出条件为`fast==null || fast.next ==null`，即存在null节点。（`fast.next != null`是为了保证接下来更新操作的正确）
3. slow每次走1步，fast每次走2步；
4. 若出现相等，则返回true；若fast出现null，则退出循环，返回false。
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 面试题 02.07. 链表相交
### 题目:
- 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
### 信息:
- **难度：** easy
- **重要性：** #★★★☆☆
### 思路一：双指针
将两条链表相连，可以使他们走过相同长度的路径。

当指针curr指向null时，切换到另一条链表遍历，最后会出现两种情况：
- 存在相交节点，此时指针currA和currB会指向同一个节点，退出循环；
- 不存在相交节点，此时currA和currB会同时指向null，退出循环。
所以最终直接返回currA或currB即可。
```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode currA = headA;  
        ListNode currB = headB;  
        while (currA != currB){  
            if (currA != null) {  
                currA = currA.next;  
            }else {  
                currA = headB;  
            }  
            if (currB != null) {  
                currB = currB.next;  
            }else {  
                currB = headA;  
            }  
        }  
        return currA;  
    }  
}
```
### 思路二：利用Set判重
利用Set判重：
- 假设有相交节点，那么代表一定会添加重复节点，此时返回该节点即可；
- 利用`change`变量，避免在另一条链表中重复遍历。（假设无change变量判断，那么在更换到另一条链表遍历时，到达null后会再次循环。）
```java 
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode curr = headA;
        boolean change = false;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
                if (curr == null && !change){
                    curr = headB;
                    change = true;
                }    
            }else {
                return curr;
            }
        }
        return null;
    }
}
```
## 142. 环形链表II
### 题目
- 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。**不允许修改链表。** 
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- 
### 思路一：快慢指针
- 带有考察数学知识的题目.需要进行细心的推理!**首先**,明确一点,当有环时,可以转化为一个追赶问题,即**步长为2的快指针一定会追赶上步长为1的慢指针**,因为他们之间的距离是以不断减1的!据此,是否有环的逻辑完成,接下来就是判断环的起点!这里用一个图和公式进行说明:![[LinkedListPart2_img2.png]]
当**快慢指针相遇**时,有以下情况:
- 慢指针走过的节点数为$x+y$,快指针走过的节点数为$x+y+n(y+z)$,并且由于慢指针的步长为1,快指针的步长为2,所以有$(x+y)\times2=x+y+n(y+z)$
- 据此可推出→ $x+y=n(y+z)$.即头节点到环形入口节点的节点数目$x=n(y+z)-y$
- 理解一下,当n=1时,此时$x=z$;当n≠1时,此时$x=n(y+z)-y$,即走过了n个环的节点数$n(y+z)$-环形入口到相遇节点的节点数y.
```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        if (head == null || head.next == null) {  
            return null;  
        }  
        ListNode fast = head;  
        ListNode slow = head;  
  
        while (fast != null && fast.next != null){  
            fast = fast.next.next;  
            slow = slow.next;  
  
            if (fast == slow) {  
                slow = head;  
  
                while (fast != slow) {  
                    fast = fast.next;  
                    slow = slow.next;  
                }  
                return fast;  
            }  
        }  
        return null;  
    }  
}
```
#### 思路一的另外写法：
- 退出循环有两种条件：`fast == slow`，或f`ast == null || fast.next == null`，因此我们可以第二个条件来判断无环；
- 如何找到入环节点：令slow回到头节点，fast保持不变，让二者走过相同的距离，则当二者相遇，即为入环节点。
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        if (fast == null || fast.next == null) return null;
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

### 思路二：O(n)空间复杂度解决
利用Set判重：
- 当set添加失败后，则说明当前节点是入口，返回该节点即可。
- 如果一直添加失败，说明无环，返回null.
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 思路一：O(n)复杂度解决，利用Set判重。
        Set<ListNode> set = new HashSet<>();
        ListNode curr = head;
        while (curr != null){
            if (set.add(curr)){
                curr = curr.next;
            }else {
                return curr;
            }
        }
        return null;
    }
}
```

## 287. 寻找重复数
### 题目
给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

	输入：nums = [1,3,4,2,2]
	输出：2
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #数组 #二分查找 #双指针 
### 思路一：构造链表
思路很牛逼。因为题目所给条件为数组下标由`[0,n+1]`，而数组的值为`0,n`。因此，若根据数组的值与下标构建映射关系，不会出现越界的情况。即不会出现：数组索引为`0,3`，而数组的值出现`nums[i] == 4`的情况。

根据上述推断，我们可以构建`i -> nums[i]`的映射关系。对于`[1,3,4,2,2]`，就可以构建出**环形链表**：![[Pasted image 20250109110043.png]]
既然已经构建出了环形链表，那么就转换为了“**龟兔赛跑问题**”！使用**Floyd判圈算法**求解！！！
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
		// 提前走, 以保证能进入while(slow!=fast)循环
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast){
            // slow走一步，fast走两步
            slow = nums[slow];
            fast =nums[nums[fast]];
        }
        // 相遇后，slow从头开始
        slow = 0;
        while (fast != slow){
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 234. 回文链表
### 题目
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：转换为list判回文
将链表判回文**转换为数组判回文**！转换后利用双指针判是否回文即可！！！
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        int n = 0;
        ListNode curr = head;
        List<Integer> nums = new ArrayList<>();
        // 获取值列表
        while (curr != null){
            nums.add(curr.val);
            curr = curr.next;    
        }
        int l = 0;
        int r = nums.size()-1;
        while (l < r){
            if (nums.get(l++) != nums.get(r--)) return false;
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：通过翻转链表转换为两个链表判相等

**具体算法流程：**
- 获取链表长度，将后半部分链表翻转；
- 翻转链表后，转换为两个链表判相等的问题。
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode curr1 = head;
        int n = 0;
        // 获取链表长度
        while (curr1 != null){
            n++;
            curr1 = curr1.next;
        }
        // 寻找中间节点
        ListNode curr2 = head;
        for (int i = 0; i < n/2; i++){
            curr2 = curr2.next;
        }
        ListNode prev = null;
        ListNode next = null;
         
        // 翻转后半部分链表
        while (curr2 != null){
            next = curr2.next;
            curr2.next = prev;

            prev = curr2;
            curr2 = next;
            
        }
        // 转换为两个链表判相等
        curr1 = head;
        curr2 = prev;
        while(curr1 != null && curr2 != null){
            if (curr1.val != curr2.val) return false;
            curr1 = curr1.next;
            curr2 = curr2.next;
        }
        return true;
    }
}
```


## 21. 合并两个有序链表
### 题目
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 
### 思路一：双指针
定义dummy节点，便于返回最终头节点。

**具体算法流程：**
- 当$list1$和$list2$均不为空时，比较$list1$和$list2$的值，$curr.next$指向较小一个；然后更新$list1$或$list2$，更新$curr$。
- 若某一个为空，则$curr.next$直接执行不为空的$list$。

>**注意，直接操作list节点即可，无需使用额外curr1指向list1。**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null){
            return list1 == null ? list2 : list1;
        }
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        
        while (list1 != null && list2 != null){
            if (list1.val < list2.val){
                curr.next = list1;
                list1 = list1.next;
            }else {
                curr.next = list2;
                list2 = list2.next;
            }
            curr = curr.next;
        }
        curr.next = list1 == null ? list2 : list1;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(M+N)$ 
**空间复杂度：** $O(1)$

## 2. 两数相加
### 题目
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #递归 
### 思路一：迭代
利用car变量保存进位；构建新节点时，利用$car\%10$获取个位；利用$car/10$获取十位（**`car>=10`时，进位为1，`car<10`时，进位为0，所以可以通过car/=10获取！**）

**具体算法流程：**
1. 当`l1 != null || l2 != null || car != 0`时进入循环，此时都需要构建新节点；
2. 利用car变量保存`进位+l1+l2`的值；
3. 构建新节点：节点值为$car\%10$；
4. $car/=10$获取进位，开始下一次循环。
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        int car = 0;
        while (l1 != null || l2 != null || car != 0){
            if (l1 != null){
                car += l1.val;
                l1 = l1.next;
            }
            if (l2 != null){
                car += l2.val;
                l2 = l2.next;
            }
            curr.next = new ListNode(car % 10);
            car /= 10;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$，返回值不计入。
### 思路二：递归
递归解决子问题，需要传递进位。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwo(l1,l2,0);
    }
    ListNode addTwo(ListNode l1, ListNode l2, int car){
        if (l1 == null && l2 == null){
            return car == 0 ? null : new ListNode(car);
        }
		// 交换l1和l2，避免后面l1.next的分类讨论，简化代码。
        if (l1 == null){
            l1 = l2;
            l2 = null;
        }
        int sum = l1.val + car + (l2 == null ? 0 : l2.val);

        l1.val = sum % 10;
        l1.next = addTwo(l1.next,l2 == null ? null : l2.next,sum / 10);
        return l1;
    }
}
```
## 138. 随机链表的复制
### 题目
给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
![[Pasted image 20241216113122.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #哈希表 
### 思路一：哈希表
本题的难点在于，构建新链表时如何连接next与curr指针，因为此时他们可能尚未创建出来！因此我们提前创建节点，并**利用哈希表存储原节点和新节点的对应关系**，之后再遍历原链表，根据原节点获取新节点，并进行连接。最终通过head指针即可获取并返回新链表的头节点。


```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node,Node> map = new HashMap<>();
        Node curr =  head;
        
        while (curr != null){
            // 深拷贝
            map.put(curr,new Node(curr.val,curr.random));
            curr = curr.next;
        }
        curr = head;
        while (curr != null){
            // 根据原链表的连接关系构建新链表
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        return map.get(head);
        
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：交错链表
**具体算法流程：**
1. 将原链表更新成交错链表：
![[Pasted image 20241216130441.png|600]]
2. 根据原链表的random，设置新链表的random；
3. 最后恢复原链表！
```java

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        Node curr = head;
        // 1. 设置交错链表
        while (curr != null){
            Node newNode = new Node(curr.val);
            Node tmp = curr.next;
            curr.next = newNode;
            newNode.next = tmp;
			
            // curr.next = new Node(curr.val, curr.next);

            curr = curr.next.next;
        }
        //  2. 根据原节点设置新节点的random
        curr = head;
        while (curr != null){
            if (curr.random != null){
                curr.next.random = curr.random.next;
            }
            curr = curr.next.next;
        }
        // 3. 构建新链表，恢复原链表
        Node newHead = head.next; // 开头保证了head != null
        curr = head;
        while (curr.next.next != null){
            Node copy = curr.next;
            curr.next = copy.next;
			copy.next = copy.next.next;    // 保证curr.next.next != null

            curr = curr.next;
        }
        curr.next = null;
        return newHead;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 23. 合并 K 个升序链表
### 题目
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
### 信息
- **难度：** hard
- **重要性：** #★★★★☆
- **标签：** #链表 #堆（优先级队列） #排序 
### 思路一：小根堆
因为K个链表都是升序的，所以当前的最小值只可能出现在头节点中。因此：
1. 将K个链表的头节点都加入优先队列中；
2. 当某个链表的头节点被弹出后，将其的next节点也加入到链表中；
3. 直至K个链表都为空。
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // 按节点值升序排列
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        // 添加头节点
        for (ListNode node : lists){
            if (node != null) pq.add(node);
        }
        ListNode dummy = new ListNode();
        ListNode curr = dummy;
        while (!pq.isEmpty()){
            // 取最小值
            ListNode min = pq.poll();
            curr.next = min;
            // 将对应链表的下个节点也加入堆中
            if (min.next != null){
                pq.add(min.next);
            }
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$

## 148. 排序链表
### 题目
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #双指针 #分治 #排序 #归并排序
### 思路一：优先队列
使用优先队列将链表按值由小到大排序，然后利用哨兵节点连接排序后的节点。最后记得断开末尾节点的next指针。
```java
class Solution {
    public ListNode sortList(ListNode head) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        ListNode curr = head;
        while (curr != null){
            pq.add(curr);
            curr = curr.next;
        }
        ListNode dummy = new ListNode();
        curr = dummy;
        while (!pq.isEmpty()){
            curr.next = pq.poll();
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路二：使用ArrayList进行排序
```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        ListNode curr = head;
        while (curr != null){
            list.add(curr);
            curr = curr.next;
        }
        Collections.sort(list,(a,b) -> a.val - b.val);
        ListNode dummy = new ListNode();
        curr = dummy;
        for (ListNode node : list){
            curr.next = node;
            curr = curr.next;
        }
        // 断开最后节点引用，避免出现环
        curr.next = null;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$
### 思路三：归并排序

## 146. LRU 缓存
### 题目
请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #链表 #哈希表 
### 思路一：循环双向链表+哈希表
**先明确几个关键点：**
1. 使用的是双向循环链表，便于快速获取尾节点；
2. 为什么需要Map？因为要保证获取`get()`操作的O(1)时间复杂度。
3. **链表节点需要存储Key值，是为了在Map中定位节点并删除（`map.remove(lastNode.key)`）；**
	- 如果只有value，那么因为value是可能重复的，则无法在map中定位并获取节点。
4. 需要定义三个私有方法：`getNode()`、`remove()`、`pushFront()`；并且每次`getNode()`都需要`remove&pushFront`!
```java
class Node {
    int val;
    int key;
    Node prev;
    Node next;
    public Node(int key,int value){
        this.key = key;
        this.val = value;
    }
}
class LRUCache {
    private Map<Integer,Node> map;
    private Node dummy;
    private int capacity;
    public LRUCache(int capacity) {
        map = new HashMap<>();
        this.capacity = capacity;
        dummy = new Node(0,0);
        dummy.next = dummy;
        dummy.prev = dummy;

    }
    
    public int get(int key) {
        Node node = getNode(key);
        return node != null ? node.val : -1;
    }
    
    public void put(int key, int value) {
        Node node = getNode(key);
        // 已存在，变更数据值   
        if (node != null) {
            node.val = value;
            return;
        }
        // 不存在，插入数据
        node = new Node(key,value);
        map.put(key,node);
        pushFront(node);
        
        // 超过容量，移除元素
        if (map.size() > capacity){
            Node lastNode = dummy.prev;
            map.remove(lastNode.key);
            remove(lastNode);
        }
    }
    // 移除节点
    void remove(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    // 将节点放置到链表头
    void pushFront(Node node){
        node.next = dummy.next;
        dummy.next.prev = node;
        dummy.next = node;
        node.prev = dummy;
    }
    // 根据key获取某个节点
    Node getNode(int key){
        // 判断节点是否存在 
        Node node = map.get(key);
        if (node == null) return node;
        
        remove(node);
        pushFront(node);

        return node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

## 86. 分隔链表
>**时间**：2025-02-08 16:52:06
### 题目
给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆
- **标签：** #链表 #双指针 
### 思路一：O(N)空间复杂度
分别使用两个集合存储较小的节点和较大的节点。
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        List<ListNode> lowList = new ArrayList<>();
        List<ListNode> highList = new ArrayList<>();

        ListNode curr = head;
        while (curr != null){
            if (curr.val >= x){
                highList.add(curr);
            }else {
                lowList.add(curr);
            }
            curr = curr.next;
        }
        ListNode dummy = new ListNode(0);
        curr = dummy;
        for (int i = 0; i < lowList.size(); i++){
            curr.next = lowList.get(i);
            curr = curr.next;
        }
        for (int i = 0; i < highList.size(); i++){
            curr.next = highList.get(i);
            curr = curr.next;
        }
        curr.next = null;
        return dummy.next;
    } 
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：双指针
使用双指针，分别构建两个链表，一个用于存储较小的元素，另一个用于存储较大的元素。最终再将两个链表连接即可。
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode lowDummy = new ListNode(0);
        ListNode highDummy = new ListNode(0);

        ListNode lowP = lowDummy;
        ListNode highP = highDummy;

        ListNode curr = head;
        while (curr != null){
            if (curr.val < x){
                lowP.next = curr;
                lowP = lowP.next;
            }else {
                highP.next = curr;
                highP = highP.next;
            }
            curr = curr.next;
        }
		// 连接两个链表 
        lowP.next = highDummy.next;
		// 避免成环
        highP.next = null;

        return lowDummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 1206. 设计跳表
>**时间**：2025-03-03 17:06:09
### 题目
不使用任何库函数，设计一个 **跳表** 。

**跳表** 是在 `O(log(n))` 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

例如，一个跳表包含 `[30, 40, 50, 60, 70, 90]` ，然后增加 `80`、`45` 到跳表中，以下图的方式操作：
![](https://pic.leetcode.cn/1702370216-mKQcTt-1506_skiplist.gif)

跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 `O(n)`。跳表的每一个操作的平均时间复杂度是 `O(log(n))`，空间复杂度是 `O(n)`。

了解更多 : [https://oi-wiki.org/ds/skiplist/](https://oi-wiki.org/ds/skiplist/)

在本题中，你的设计应该要包含这些函数：

- `bool search(int target)` : 返回target是否存在于跳表中。
- `void add(int num)`: 插入一个元素到跳表。
- `bool erase(int num)`: 在跳表中删除一个值，如果 `num` 不存在，直接返回false. 如果存在多个 `num` ，删除其中任意一个即可。

注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #设计 #链表 
### 思路一：
`forward`指针的含义：
- `forward[i]`代表当前节点在第i层的下一个节点。以下图为例，`Node(30)`的`forward[0]=Node(40)`, `Node(40)`的`forward[0]=Node(50)`，Node
![[Pasted image 20250303170906.png]]
```java
class Skiplist {
    // 定义节点
    class Node {
        int val;
        Node[] forward;
        
        public Node(int val, int level) {
            this.val = val;
            // 每个节点维护一个 forward 数组，表示在每一层的下一个节点指针
            forward = new Node[level];
        }
    }
    
    private static final int MAX_LEVEL = 16; // 最大层数
    private static final double P = 0.5;       // 随机提升的概率因子
    private Node head;                       // 跳表头节点
    private int level;                       // 当前跳表最高层
    
    /** 初始化跳表 */
    public Skiplist() {
        head = new Node(-1, MAX_LEVEL); // 哨兵节点，值可以任意设置
        level = 1;
    }
    
    /** 随机生成节点的层数 */
    private int randomLevel() {
        int lvl = 1;
        // 当随机数小于 P 时增加层数，最高不超过 MAX_LEVEL
        while (Math.random() < P && lvl < MAX_LEVEL) {
            lvl++;
        }
        return lvl;
    }
    
    /** 返回 target 是否存在于跳表中 */
    public boolean search(int target) {
        Node curr = head;
        // 从最高层开始查找
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < target) {
                curr = curr.forward[i];
            }
        }
        curr = curr.forward[0];
        return (curr != null && curr.val == target);
    }
    /** 插入一个元素到跳表中 */
    public void add(int num) {
        Node[] update = new Node[MAX_LEVEL];
        Node curr = head;
        // 找到每一层中，应该插入新节点的位置的前驱节点
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < num) {
                curr = curr.forward[i];
            }
            update[i] = curr;
        }
        
        // 生成新节点的层数
        int lvl = randomLevel();
        // 如果新节点层数超过当前跳表层数，需要更新 update 数组为头节点
        if (lvl > level) {
            for (int i = level; i < lvl; i++) {
                update[i] = head;
            }
            level = lvl;
        }
        Node newNode = new Node(num, lvl);
        // 在各层中插入新节点
        for (int i = 0; i < lvl; i++) {
            newNode.forward[i] = update[i].forward[i];
            update[i].forward[i] = newNode;
        }
    }
    
    /** 在跳表中删除一个值，若存在多个相同值则删除其中一个，返回是否删除成功 */
    public boolean erase(int num) {
        Node[] update = new Node[MAX_LEVEL];
        Node curr = head;
        // 找到各层中待删除节点的前驱节点
        for (int i = level - 1; i >= 0; i--) {
            while (curr.forward[i] != null && curr.forward[i].val < num) {
                curr = curr.forward[i];
            }
            update[i] = curr;
        }
        curr = curr.forward[0];
        // 如果目标节点不存在，返回 false
        if (curr == null || curr.val != num) {
            return false;
        }
        // 在每一层中更新指针，跳过待删除的节点
        for (int i = 0; i < level; i++) {
            if (update[i].forward[i] != curr) {
                break;
            }
            update[i].forward[i] = curr.forward[i];
        }
        // 如果最高层变空，则降低跳表层数
        while (level > 1 && head.forward[level - 1] == null) {
            level--;
        }
        return true;
    }
}
```

## 61. 旋转链表
>**时间**：2025-03-05 10:13:11
### 题目
给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。
![[Pasted image 20250305101335.png]]
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 #模拟 
### 思路一：区别于轮转数组
区别于轮转数组，旋转链表实质上只需要三个指针的改变（见图），因此我们获取尾节点、以及第`sz-k`个节点即可。
![[Pasted image 20250305102134.png]]
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null) return head;
        // 与轮转数组不同, 旋转列表的最终结果, 实质上只是两个指针的改变.
        int sz = 0;
        ListNode curr = head;
		// 用于获取尾节点
        ListNode last = new ListNode();
        while (curr != null) {
            if (curr.next == null) last = curr;
            curr = curr.next;
            sz++;
        }
        
        ListNode dummy = new ListNode(0,head);
        k %= sz;
        curr = dummy;
        // 移动到旋转后的头结点之前(第sz-k个节点)
        for (int i = 0; i < sz-k; i++) {
            curr = curr.next;
        }
        // 1. 尾和头相连
        last.next = head;
        // 2. 重新选取头节点
        dummy.next = curr.next;
        // 3. 断开连接
        curr.next = null;

        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 1290. 二进制链表转整数
>**时间**：2025-03-29 14:31:45
### 题目
给你一个单链表的引用结点 `head`。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 **十进制值** 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆ 
- **标签：** #链表 
### 思路一：
每一次往后递推，都需要将前面计算的结果再乘2，因为相当于位数左移了，因此幂次需要增加。
```java
class Solution {
    public int getDecimalValue(ListNode head) {
        ListNode curr = head;
        int ans = 0;
        while (curr != null) {
            ans = ans * 2 + curr.val;
            curr = curr.next;
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：回溯
```java
class Solution {
    public int getDecimalValue(ListNode head) {
        return dfs(head,0);
        
    }
    int dfs(ListNode node, int res){
        if (node == null) return res;
        
        res = res * 2 + node.val;
        
        return dfs(node.next, res);
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 2181. 合并零之间的节点
>**时间**：2025-03-29 20:28:09
### 题目
给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。

对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。

 返回修改后链表的头节点 `head` 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆ 
- **标签：** #链表  
### 思路一：一次遍历
基本思路：遍历链表，遇到0则开始记录sum值，直到遇到下一个0后，将创建新节点，并继续下一轮遍历。
```java
class Solution {
    public ListNode mergeNodes(ListNode head) {
        ListNode dummy = new ListNode();
        ListNode newCurr = dummy;
        // 从第一个非0开始遍历
        ListNode curr = head.next;

        while (curr != null) {
            int sum = 0;
            // 累加两个0之间的和
            while (curr.val != 0) {
                sum += curr.val;
                curr = curr.next;
            }
            // 创建新节点, 开启下一次遍历.
            newCurr.next = new ListNode(sum);
            newCurr = newCurr.next;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 725. 分隔链表
>**时间**：2025-03-29 21:07:38
### 题目
给你一个头结点为 `head` 的单链表和一个整数 `k` ，请你设计一个算法将链表分隔为 `k` 个连续的部分。

每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。

这 `k` 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。

返回一个由上述 `k` 部分组成的数组。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆ 
- **标签：** #链表 
### 思路一：
由于需要保证每部分长度尽可能相等，因此需要先遍历一次获取总长度，以判断每部分长度是多少。 由于不完全匹配，因此可能会有余数remain，这部分可以平均分配到前remain部分（通过`i < remain`来判断）

在分配好`ans[i]`后，需要将末尾与后续链表断掉。同时更新curr指针，以进行下一次遍历。
```java
// 记录next节点
ListNode next = curr.next;
// 断开连接
curr.next = null;
curr = next;
```

```java
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        // 获取链表长度, 根据链表长度与k值判断每个位置应该放置多少元素.
        ListNode curr = head;
        int len = 0;
        while (curr != null) {
            len++;
            curr = curr.next;
        }
        
        ListNode[] ans = new ListNode[k];
        int per = len / k;
        // remain为多余元素,平均分配到前面的数组中
        int remain = len % k;
        
        curr = head;
        for (int i = 0; i < k && curr != null; i++) {
            ans[i] = curr;
            // 至少放置len / k个元素.
            int tmp = per + (i < remain ? 1 : 0);
            while (tmp > 1) {
                curr = curr.next;
                tmp--;
            }
            ListNode next = curr.next;
            curr.next = null;
            curr = next;
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 83. 删除排序链表中的重复元素
>**时间**：2025-03-30 22:38:43
### 题目
给定一个已排序的链表的头 `head` ， _删除所有重复的元素，使每个元素只出现一次_ 。返回 _已排序的链表_ 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #链表 
### 思路一：一次遍历
基本思路：头节点是肯定保留的，因此从头节点开始，判断是否存在重复元素，若存在，则将当前节点的next指向下下个节点。
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        // 从头节点开始判断
        ListNode curr = dummy.next;
        if (curr == null) return head;
        while (curr.next != null) {
	        // 存在重复元素, 进行删除操作.
            if (curr.next.val == curr.val) {
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 82. 删除排序链表中的重复元素 II
>**时间**：2025-03-30 23:28:33
### 题目
给定一个已排序的链表的头 `head` ， _删除原始链表中所有重复数字的节点，只留下不同的数字_ 。返回 _已排序的链表_ 。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #链表 
### 思路一：
思路：先判断是否存在重复元素，若存在重复元素，则往后遍历，直到找到第一个不重复的节点，更新next指针。
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        while (curr.next != null && curr.next.next != null) {
            int val = curr.next.val;
            // 出现重复元素
            if (curr.next.next.val == val) {
                // 从重复元素第一个开始遍历, 找到第一个不是重复元素的节点
                while (curr.next != null && curr.next.val == val) {
                    curr.next = curr.next.next;
                }
            }else {
                curr = curr.next;
            }
        }
        return dummy.next;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 2487. 从链表中移除节点
>**时间**：2025-03-31 22:21:35
### 题目
给你一个链表的头节点 `head` 。

移除每个右侧有一个更大数值的节点。

返回修改后链表的头节点 `head` 。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆ 
- **标签：** #链表 #递归 #单调栈 
### 思路一：单调栈 + 双端队列
很明显的单调栈题目，使用单调栈，存储节点值。获取节点后，使用双端队列的双端特性构造新链表，或者使用头插法。
```java
class Solution {
    public ListNode removeNodes(ListNode head) {
        Deque<ListNode> sta = new ArrayDeque<>();
        int cnt = 0;
        while (head != null) {
            // System.out.println(head.val);
            while (!sta.isEmpty() && sta.peek().val < head.val) {
                // System.out.println("弹出次数：" + cnt++);
                sta.pop();
            }
            sta.push(head);
            head = head.next;
        }
        ListNode dummy = new ListNode();
        ListNode curr = dummy;
        while (!sta.isEmpty()) {
            curr.next = sta.pollLast();
            curr = curr.next;
        }
        curr.next = null;
        return dummy.next;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：单调栈 + 头插法
```java
class Solution {
    public ListNode removeNodes(ListNode head) {
        Deque<ListNode> sta = new ArrayDeque<>();
        int cnt = 0;
        while (head != null) {
            // System.out.println(head.val);
            while (!sta.isEmpty() && sta.peek().val < head.val) {
                // System.out.println("弹出次数：" + cnt++);
                sta.pop();
            }
            sta.push(head);
            head = head.next;
        }
        ListNode dummy = new ListNode();
        ListNode curr = dummy;
        while (!sta.isEmpty()) {
	        // 头插法
            ListNode p = sta.pop();
            p.next = dummy.next;
            dummy.next = p;
        }
        return dummy.next;
    }
}
```
### 思路三：递归
```java
class Solution {
    public ListNode removeNodes(ListNode head) {
        if (head.next == null) {
            return head;
        }
        ListNode node = removeNodes(head.next);
        // 下一个节点值更大, 删除当前节点
        if (node.val > head.val) {
            return node;
        }
        // 保留当前节点
        head.next = node;
        return head;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路四：迭代 
反转链表后再进行正序遍历，此时的正序相当于逆序。

注意：这里使用`if-else`进行节点删除！这样，只要下一个节点比当前节点值大，就会持续删除，直到下一个节点值相等或者更小，此时才会走else分支，更新curr指针。
```java
class Solution {
    public ListNode removeNodes(ListNode head) {
        head = reverse(head);
        ListNode curr = head;
        while (curr.next != null) {
	        // 使用if-else进行节点删除
            if (curr.val > curr.next.val) {
                curr.next = curr.next.next;
            }else {
                curr = curr.next;
            }
        }
        return reverse(head);
    }
    // 反转链表
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            
            prev = curr;
            curr = next;   
        }
        return prev;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 2807. 在链表中插入最大公约数
>**时间**：2025-04-01 22:17:39
### 题目
给你一个链表的头 `head` ，每个结点包含一个整数值。

在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 **最大公约数** 。

请你返回插入之后的链表。

两个数的 **最大公约数** 是可以被两个数字整除的最大正整数。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #链表 
### 思路一：
这题，不会对链表头节点进行删除操作，所以无需定义dummy节点，这里要注意。

其次是，如何求解最大公约数呢？
笨方法是：取`i = Math.min(val1,val2)`遍历到`i=1`，找到符合`val1%i == 0 && val2 % i == 0`的数。
```java
class Solution {
    public ListNode insertGreatestCommonDivisors(ListNode head) {
        
        ListNode curr = head;
        while (curr.next != null) {
            ListNode newNode = new ListNode(getCommonDivisor(curr.val, curr.next.val),curr.next);
            curr.next = newNode;
            curr = newNode.next;
        }
        return head;
    }
    private int getCommonDivisor(int a, int b) {
        while (a != 0) {
            int temp = a;
            a = b % a;
            b = temp;
        }
        return b;

    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## CR 029. 循环有序列表的插入
>**时间**：2025-04-01 23:13:09
### 题目
给定**循环单调非递减列表**中的一个点，写一个函数向这个列表中插入一个新元素 `insertVal` ，使这个列表仍然是循环升序的。

给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。

如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。

如果列表为空（给定的节点是 `null`），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆ 
- **标签：** #链表 
### 思路一：
分类讨论：实质上就只有三种插入的情况，因此，判断三种情况，符合条件则退出遍历即可。
![[Pasted image 20250401231641.png]]
```java
class Solution {
    public Node insert(Node head, int insertVal) {
        Node newNode = new Node(insertVal);
        if (head == null) {
            head = newNode;
            head.next = head;
            return head;
        }
        // Node dummy = new Node(insert, head);
        Node curr = head;
        while (curr.next != head) {
            if (curr.next.val < curr.val) {
                if (curr.next.val >= insertVal && insertVal <= curr.val) break;
                if (curr.next.val <= insertVal && insertVal >= curr.val) break;
            }
            if (curr.val <= insertVal && insertVal <= curr.next.val) break;
            curr = curr.next;
        }
        newNode.next = curr.next;
        curr.next = newNode;
        
        return head;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 147. 对链表进行插入排序
>**时间**：2025-04-01 23:28:55
### 题目
给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 _排序后链表的头_ 。

**插入排序** 算法的步骤:
1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
3. 重复直到所有输入数据插入完为止。

下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #链表 #排序 
### 思路一：
使用curr进行遍历，找到需要进行插入的节点，利用tmp变量保存，从头节点开始遍历，找到插入位置。由于使用tmp变量进行插入操作，因此寻找需要插入节点的curr指针是不变的，这样就**保证了能遍历到所有节点**。
```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode curr = head;
        while (curr != null && curr.next != null) {
            if (curr.val <= curr.next.val) {
                curr = curr.next;
            }else {
                ListNode tmp = curr.next;
                curr.next = curr.next.next;

                ListNode prev = dummy;
                while (prev.next.val <= tmp.val) {
                    prev = prev.next;
                }
                // 插入到prev之后
                tmp.next = prev.next;
                prev.next = tmp;
            }
        }
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N^2)$
**空间复杂度：** $O(1)$

## 2074. 反转偶数长度组的节点
>**时间**：2025-04-07 01:01:04
### 题目
给你一个链表的头节点 `head` 。

链表中的节点 **按顺序** 划分成若干 **非空** 组，这些非空组的长度构成一个自然数序列（`1, 2, 3, 4, ...`）。一个组的 **长度** 就是组中分配到的节点数目。换句话说：

- 节点 `1` 分配给第一组
- 节点 `2` 和 `3` 分配给第二组
- 节点 `4`、`5` 和 `6` 分配给第三组，以此类推

注意，最后一组的长度可能小于或者等于 `1 + 倒数第二组的长度` 。

**反转** 每个 **偶数** 长度组中的节点，并返回修改后链表的头节点 `head` 。
### 信息
- **难度：** medium
- **重要性：** #★★★★★ 
- **标签：** #链表 
### 思路一：翻转链表
基本思路是：
- 利用tmp变量来遍历当前组，判断当前组的元素的个数是奇数还是偶数；
- 根据奇偶的不同，进行不同的操作：
	- 若是偶数，则进行翻转操作；
	- 若是奇数，而直接略过当前组。

在遍历、翻转过程中明确几个变量：
- `prevGroup`：用于标注当前组的前一个节点，用于连接反转后的链表；
- `tmp`：用于遍历链表，判断小组长度；
- `curr`：指向当前小组的头节点。

当翻转完后，连接操作的基本逻辑：
此时`curr`指向后一组的头节点、`prev`指向反转后的头节点、`prevGroup`为上一组的尾节点。因此，我们：
1. 先保存`prevGroup.next`，也就是保留翻转后的尾节点（用于连接操作）； 
2. 连接反转后的尾节点与下一组的头节点：`prevGroup.next.next = curr;`
3. 连接上一组的尾巴与当前组的头节点：`prevGroup.next = prev;`
4. 更新上一组的头节点（其实也就是更新为原来的`prevGroup.next`）
```java
class Solution {
    public ListNode reverseEvenLengthGroups(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode curr = head;
        ListNode prevGroup = dummy;
        
        int group = 1;
        // 每次遍历时, curr指向当前group的开头元素
        while (curr != null) {
            int count = 0;
            ListNode tmp = curr;
            while (tmp != null && count < group) {
                tmp = tmp.next;
                count++;
            }
            if (count % 2 == 0) {
                ListNode prev = null;
                ListNode next = null;

                // 开始翻转
                for (int i = 0; i < count; i++) {
                    next = curr.next;
                    curr.next = prev;

                    prev = curr;
                    curr = next;
                }
                // 连接尾巴
                ListNode p0 = prevGroup.next;
                prevGroup.next.next = curr;
                prevGroup.next = prev;
                prevGroup = p0;
            }else {
                for (int i = 0; i < count; i++) {
                    prevGroup = curr;
                    curr = curr.next;
                }
            }
            group++;
        }
        return dummy.next;
    } 
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 095. 删除链表的中间节点
>**时间**：2025-04-07 21:26:46
### 题目
你一个链表的头节点 `head` 。**删除** 链表的 **中间节点** ，并返回修改后的链表的头节点 `head` 。

长度为 `n` 链表的中间节点是从头数起第 `⌊n / 2⌋` 个节点（下标从 **0** 开始），其中 `⌊x⌋` 表示小于或等于 `x` 的最大整数。

- 对于 `n` = `1`、`2`、`3`、`4` 和 `5` 的情况，中间节点的下标分别是 `0`、`1`、`1`、`2` 和 `2` 。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆ 
- **标签：** #双指针 #链表 
### 思路一：两次遍历
第一次遍历获取长度，第二次根据长度遍历到链表中间节点的前面一个节点的位置。
```java
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode curr = head;
        int n = 0;
        while (curr != null) {
            curr = curr.next;
            n++;
        }
        curr = dummy;
        for (int i = 0; i < n/2; i++) {
            curr = curr.next;
        }
        curr.next = curr.next.next;
        return dummy.next;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：快慢指针(一次遍历)
![[Pasted image 20250407213656.png]]
```java
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode slow = dummy;
        ListNode fast = dummy;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 

## 143. 重排链表
>**时间**：2025-04-07 22:18:02
### 题目
给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：
`L0 → L1 → … → Ln - 1 → Ln`
请将其重新排列后变为：
`L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆ 
- **标签：** #链表 #双指针 
### 思路一：
翻转后半部分后，进行连接。

注意，最后一个节点无需进行连接。
![[Pasted image 20250407222239.png]]
```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode newHead = reverse(slow);
        ListNode dummy = new ListNode(0, head);
        
        ListNode curr = head;
        ListNode next = null;
        while (newHead.next != null) {
            ListNode tmp = newHead.next;

            next = curr.next;
            newHead.next = curr.next;
            curr.next = newHead;
            
            newHead = tmp;
            curr = next;
        }
        System.out.println(newHead.val);
        
    }
    ListNode reverse(ListNode head) {
        ListNode next = null;
        ListNode curr = head;
        ListNode prev = null;
        
        while (curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }
}

```
**时间复杂度：** 
**空间复杂度：** 