## 242. 有效的字母异位词
### 题目
- 给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。
- **字母异位词** 是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。
### 信息
- **难度：** Easy
- **重要性**： #★★★☆☆
- **标签：** #字符串 #哈希表 
### 思路一：哈希表
ASCII码的范围为0~127，所以定义一个128长度的哈希表$cnt[128]$即可。

**具体算法流程：**
- 遍历字符串s，获取每个字母出现次数；
- 遍历字符串t，扣减每个字母出现次数；若扣减后出现次数小于0，说明不符合条件，返回false。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int[] cnt = new int[26];
        for (char c : s.toCharArray()) {
            cnt[c-'a']++;
        }
        for (char c : t.toCharArray()) {
            if (--cnt[c-'a'] < 0){
                return false;
            }
        }
        return true;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 349. 两个数组的交集
### 题目:
- 给定两个数组 `nums1` 和 `nums2`,返回它们的交集。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
### 信息:
- **难度**: easy
- **重要性:** #★☆☆☆☆
### 思路一：利用`cnt[]`数组
遍历数组1，使用cnt数组存储元素出现次数；再次遍历数组2，因为要找到相同元素，则遇到`cnt[num]!=0`，说明遇到了相同元素，添加到结果集中。

为了避免结果集出现重复元素，可以采用两种方式：①set集合保存结果；②使用cnt2数组保存数组2出现的元素，只有`cnt1[num] != 0 && cnt2[num] == 0`，才将元素添加到结果集。

>[!集合→数组]
>利用stream流：`list.stream().mapToInt(Integer::intValue).toArray();`

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] cnt1 = new int[1001];
        int[] cnt2 = new int[1001];

        for (int num : nums1){
            cnt1[num]++;
        }
        List<Integer> list = new ArrayList<>();
        for (int num : nums2){
            if (cnt1[num] != 0 && cnt2[num] == 0){
                list.add(num);
            }
            cnt2[num]++;
        }
        return list.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

## 202. 快乐数
### 题目
- 编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：利用哈希表判重
注意，题目说明：无限循环但始终变不到1，那么说明会有重复元素！故可以采用哈希表判重，出现重复时说明不是快乐数。
>[!获取各位数技巧]-
获取各位数的通用方法：
当n为个位数后，`n/10`等于0，就会退出循环。
>```java
>while(n != 0){
>	x = n % 10;
>	n /=10;
>}
>```

```java
class Solution {
    public boolean isHappy(int n) {
        // 快乐数: 将该数替换成每个s
        // 退出条件：无限循环(利用set判断是否重复)
        Set<Integer> set = new HashSet<>();
        while (!set.contains(n)) {
            set.add(n);
            int sum = 0;
            while (n != 0) {
                sum += Math.pow(n % 10, 2);
                n /= 10;
            }
            n = sum;
            if (n == 1) return true;
        } 
        return false;
    }
}
```
### 思路二：快慢指针
因为若不存在，则会有无限循环，那么说明会有一个"隐藏的环形链表"，故可以使用**快慢指针查找法**来找到交点。
**具体算法流程：**
1. slow指针走一步，fast指针走两步；
2. 最终会出现两种情况：
	1. fast指针先到达快乐数；
	2. slow和fast指针相交，此时说明不是快乐数。

这里使用了do-while循环，用于确保至少先前进一/两步，以便能进入`while(slow!=fast)`的循环。
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = n,fast = n;
        do{
            slow = sum(slow);
            fast = sum(sum(fast));
        }while(slow != fast);
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```
或者也可以先手动走一/两步，让其能进入循环：
```java
class Solution {
    public boolean isHappy(int n) {
        int slow = sum(n),fast = sum(sum(n));
        while (slow != fast){
            slow = sum(slow);
            fast = sum(sum(fast));
        }
        return fast == 1;
    }
    int sum(int n){
        int sum = 0;
        while (n != 0){
            sum += Math.pow(n%10,2);
            n /= 10;
        }
        return sum;
    }
}
```

## 1. 两数之和
### 题目
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #哈希表 #数组 
### 思路一：哈希表寻找符合要求的两个数
对于这类**无序数组**，且要求寻找符合要求的两个数时，非常适合用哈希表来进行优化。如果直接遍历寻找则需要$O(N^2)$的复杂度，而使用哈希表相当于「空间换时间」，将时间复杂度变成了$O(N)$。

具体算法流程：
- 构建Map存储`Key=nums[i],Value=i;`，利用哈希表的`containsKey()`判断另一个数是否已存在；
- 若已存在，则直接返回答案；
- 若不存在，则存储当前元素，继续往后遍历。
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target - nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 454. 四数相加II

### 题目:
- 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
	- `0 <= i, j, k, l < n`
	- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
### 信息:
- **难度**: medium
- **重要性:** #★★★☆☆
### 思路一：暴力搜索【超时】
暴力回溯，通过map映射每个数组，通过k选取数组。

此解法会超时。
```java
class Solution {
    private int ans;
    private int[][] map;
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        map = new int[][]{nums1,nums2,nums3,nums4};
        dfs(0,0);
        return ans;
        
    }
    void dfs(int k,int sum){
        if (k == 4){
            if (sum == 0){
                ans++;
            }
            return;
        }
        for (int i = 0; i < map[k].length; i++){
            sum += map[k][i];
            dfs(k+1,sum);
            sum -= map[k][i];
        }
        
    }
}
```
**时间复杂度：** $O(n^4)$
**空间复杂度：** $O(1)$
### 思路二：哈希表
对应四个数组，那么暴力一般都会超时！那么如何避免超时呢？首先想到的就是“记忆化搜索”！

**如何记忆化呢？**
将4层嵌套循环遍历数组 变为 分别遍历两个数组。首先遍历$nums1+nums2$，利用map保存所有的相加结果；然后再遍历$nums3+nums4$，判断相加结果是否出现在哈希表中，若出现了则累加结果$ans$.

通过分别遍历，可以降低时间复杂度。
```java
class Solution {  
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
        int count = 0;  
        HashMap<Integer, Integer> map1 = new HashMap<>();  
        for (int i : nums1) {  
            for (int j : nums2) {  
                map1.put(i+j,map1.getOrDefault(i+j, 0) + 1);  
            }  
        }  
//        ArrayList<Integer> sum2 = new ArrayList<>();  
        for(int i :nums3) {  
            for (int j : nums4) {  
//                a+b+c+d=0  
//                sum1存储了a+b,判断是0-(c+d)的值是否存在  
                if (map1.containsKey(-(i+j))) {  
                    count += map1.get(-(i+j));  
                }  
            }  
        }  
        return count;  
    }  
}
```
**时间复杂度：** $O(n^2)$
**空间复杂度：** $O(n^2)$，最差情况下，需要$n^2$来保存所有$i+j$.
## 383. 赎金信
### 题目:
- 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
### 信息:
- **难度**: easy
- **重要性:** #★★☆☆☆
### 思路一：
利用`cnt[]`数组存储字符出现次数。遍历另一个数组，出现相同字符则扣减，扣减后小于0，则返回false。
```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] cnt = new int[128];
        for (int i = 0; i < magazine.length(); i++){
            cnt[magazine.charAt(i)]++;
        }
        for (int i = 0; i < ransomNote.length(); i++){
            if (--cnt[ransomNote.charAt(i)] < 0){
                return false;
            }
        }
        return true;

    }
}
```
## 49. 字母异位词分组 
### 题目
给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #排序 
### 思路一：
如何判断是否是异位词是本题的关键。
- 如果每次判断都通过逐个判断来进行，那么是个大工程。

但是，如果将字符串按照ASCII码顺序进行排列，那么异位词最终都会是相同的顺序！因此，可以**先转换为$char$类型数组进行排序**。

第二个问题，是保存异位词相同的对应字符串，可以通过哈希表实现，其中$Key$为排序后的异位词，$Value$为原单词构成的集合。这样就能保证不同异位词对应同一个$Entry$，并且通过$List<String>$可以很方便获取结果。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length; i++){
            char[] str = strs[i].toCharArray();
            Arrays.sort(str);
            String tmp = new String(str);
            // 获取每个idx对应的排序后字符串
            map.computeIfAbsent(tmp, j -> new ArrayList<>()).add(strs[i]);
        }         
        return new ArrayList<>(map.values());
    }
}
```

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map = new HashMap<>();
        for (String str : strs){
            char[] tmp = str.toCharArray();
            Arrays.sort(tmp);
            // 获取排序后的字符串
            String sortedStr = new String(tmp);
            if (!map.containsKey(sortedStr)){
               map.put(sortedStr,new ArrayList<>());
            }
            map.get(sortedStr).add(str);
        }
        return new ArrayList<>(map.values());
    }
}
```
**时间复杂度：** $O(N \times klogk)$，遍历所有$strs$的时间复杂度$O(N)$，每个字符排序的时间复杂度为$O(klogK)$。
**空间复杂度：** $O(N\times k)$

## 128. 最长连续序列
### 题目
给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：通过contains方法降低时间复杂度
如果排序后，就转换为最长连续子序列问题，不过时间复杂度为$O(NlogN)$，因此本题不适用。

采用$O(N)$的方式，就要求只能一层循环遍历数组。因此，**考虑使用哈希表**，存储所有元素并去重。然后，对于集合中的数，**通过$contains()$方法来寻找其下一个数是否存在，直到下一个数不存在，更新长度。**

在这要注意避免大量重复计算：若对于某个$num$，$num-1$也存在，那说明以$num-1$作为起点开始计算的长度肯定大于以$num$作为起点开始计算的长度，因此可以跳过！
```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            set.add(num);
        }
        int ans = 0;
        for (int num : set){
            if (set.contains(num - 1)) {
                continue;
            }

            int y = num+1;
            while (set.contains(y)){
                y++;
            }
            ans = Math.max(ans,y-num);
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int n = nums.length;
        for (int i = 0; i < n; i++){
            map.put(nums[i],i);
        }
        int ans = 0;
        for (int num : map.keySet()){
            int tmp = num;
            if (map.containsKey(num-1)) continue;
            while (map.containsKey(tmp+1)){
                tmp = tmp + 1;
            }
            ans = Math.max(tmp - num + 1, ans);
        }
        
    }
}
```
**时间复杂度：** 
**空间复杂度：** 
## 438. 找到字符串中的所有字母异位词
### 题目
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #哈希表 #滑动窗口 #字符串 
### 思路一：定长滑动窗口+哈希表
异位词的意思是相同长度的字符串，字母出现次数相等。因此，使用$cnt$数组记录元素出现次数，并通过`Arrays.equals()`方法判断两个数组是否相等来判断是否为异位词。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] sCnt = new int[26];
        int[] pCnt = new int[26];

        for (char c : p.toCharArray()){
            pCnt[c-'a']++;
        }
        int l = 0;
        List<Integer> ans = new ArrayList<>();
        for (int r = 0; r < s.length(); r++){
            char cur = s.charAt(r);
            sCnt[cur-'a']++;
            if (r < p.length()-1) continue;

            if (Arrays.equals(sCnt,pCnt)){
                ans.add(l);
            }
            
            sCnt[s.charAt(l)-'a']--;
            l++;
        }
        return ans;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 

## 76. 最小覆盖子串
### 题目
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★
- **标签：** #字符串 #哈希表 #滑动窗口 
### 思路一：利用remain变量
这题的思路很有意思，利用一个remain变量来记录仍需字符个数。

具体而言，利用cnt数组存储T中字符出现个数，利用cnt数组判断移入和移出窗口的元素是否在T数组中。具体判断逻辑为：
1. `if(--cnt[s[r]]) >= 0`，表示若扣减了仍大于等于0，说明原本此时**cnt中该元素的个数不等于0**，即T中含有该字符！
2. `if (++cnt[s[l]] > 0)`，表示若添加了则大于0，说明++前此时cnt中的值最少为0，即被扣减前大于0！
	- 即不在T中的字符在前面被`--cnt[s[r]]`扣减至了负数，即原本为0，因此无法通过此if判断。
```java
class Solution {
    public String minWindow(String S, String T) {
        // 记录T中字符出现次数
        int[] cnt = new int[128];
        char[] s = S.toCharArray();
        char[] t = T.toCharArray();
        // 记录满足覆盖子串仍所需字符个数
        int remain = t.length;
        for (char c : t){
            cnt[c]++;
        }
        int ans = Integer.MAX_VALUE;
        int l = 0;
        int start = 0;
        for (int r = 0; r < s.length; r++){
            // t中存在该字符，则添加
            if (--cnt[s[r]] >= 0) {
                remain--;
            }
            if  (r < t.length-1) continue;
            // 符合条件了，左移窗口，找到最小子串
            while (remain == 0){
                if (r-l+1 < ans){
                    ans = r-l+1;
                    start = l;
                }
                // 判断移出窗口的元素是否为T中字符
                if (++cnt[s[l]] > 0) {
                    remain++;
                }
                l++;
            }
        }
        return ans == Integer.MAX_VALUE ? "" : S.substring(start,start+ans);
    }
}
```
**时间复杂度：** $O(M+N)$
**空间复杂度：** $O(1)$
### 思路一：滑动窗口+哈希表
获取最小子串，那么就是使用滑动窗口。并且需要比较字母出现次数，那么就使用哈希表！

具体算法流程：
3. 初始化最小子串为$ansL=-1,ansR=m$；
4. 不断移动右窗口，直到窗口内包含所有$t$中的字符；
5. 若窗口内已包含t内所有字符，则不断移动左窗口，并最小子串！
6. 若最后ansL被更新了，说明存在最小子串，否则返回空字符串""。

具体的比对是否包含所有的$t$子串，可以定义一个$isCovered$函数来实现。
```java
class Solution {
    public String minWindow(String s, String t) {
        int[] cntS = new int[128];
        int[] cntT = new int[128];

        int m = s.length();
        int n = t.length();

        for (char c : t.toCharArray()){
            cntT[c]++;
        }
        int ansR = m;
        int ansL = -1;
        int l = 0;
        for (int r = 0; r < m; r++){
            cntS[s.charAt(r)]++;
            while (isCovered(cntS,cntT)){
                if (r - l < ansR - ansL){
                    ansL = l;
                    ansR = r;
                }
                cntS[s.charAt(l)]--;
                l++;
            }
        }
        return ansL < 0 ? "" : s.substring(ansL,ansR+1);
    }
    boolean isCovered(int[] cntS, int[] cntT){
        for (int i = 'A'; i <= 'Z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        for (int i = 'a'; i <= 'z'; i++){
            if (cntS[i] < cntT[i]){
                return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(52m + n)$
**空间复杂度：** $O(128)$

## 3298. 统计重新排列后包含另一个字符串的子字符串数目 II
### 题目
给你两个字符串 `word1` 和 `word2` 。

如果一个字符串 `x` 重新排列后，`word2` 是重排字符串的 前缀 ，那么我们称字符串 `x` 是 **合法的** 。

请你返回 `word1` 中 **合法** 子字符串 的数目。

**注意** ，这个问题中的内存限制比其他题目要 **小** ，所以你 **必须** 实现一个线性复杂度的解法。
### 信息
- **难度：** hard
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #滑动窗口 
### 思路一：
```java
class Solution {
    public long validSubstringCount(String word1, String word2) {
        int[] cnt = new int[26];
        int less = 0;
        for (char c : word2.toCharArray()){
            cnt[c-'a']++;
            if (cnt[c-'a']==1) less++;
        }

        int l = 0;
        long ans = 0;
        for (int r = 0; r < word1.length(); r++){
            char c = word1.charAt(r);
            // 移入窗口内的元素
            cnt[c-'a']--;
            // 若为0，说明原本为1
            if (cnt[c-'a'] == 0){
                less--;
            }
            while (less == 0){
                char out = word1.charAt(l);
                if (cnt[out-'a'] == 0){
                    less++;
                }
                l++;
                cnt[out-'a']++;
            }
            ans += l;
        }
        return ans;
    }

}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
## 41. 缺失的第一个正数
### 题目
给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #数组 #哈希表 
### 思路一：原地哈希
目标：找到第一个缺失的正整数。数组的索引为`[0,n-1]`，因此，可以将正整数x都放在x-1的索引位置上，即满足`nums[x-1] = x`.

**具体算法流程：**
1. 遍历`i`，目的是让当前i上的索引**回到其应在的位置上**；
	- 交换条件为：当前元素在数组索引范围内，并且不满足`nums[x-1] = x`.
2. 再次遍历，判断位置不符的元素；若所以位置都相符，则返回$n+1$。
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        // 最小的正整数
        int n = nums.length;
        for (int i = 0; i < n; i++){
            // 交换条件：元素的值在[1,n]的范围内
            // int x = nums[i];
            // 不断交换，直至符合条件。
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i]-1] != nums[i]){
                int tmp = nums[i];
                nums[i] = nums[tmp-1];
                nums[tmp-1] = tmp;
            }
        }
        // 找出不符合条件的元素
        for (int i = 0; i < n; i++) {
            if (nums[i] != i+1) return i+1;
        }
        // 如果都满足,则为超出[1,n]范围的n+1.
        return n+1;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：哈希表
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i : nums) {
            set.add(i);
        }
        int missing = 1;
        while (set.contains(missing)) {
            missing++;
        }
        return missing;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路三：排序
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int missing = 1;
        for (int i : nums){
            if (i == missing){
                missing++;
            }
        }
        return missing;
    }
}
```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(1)$
## 1338. 数组大小减半
### 题目
给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。

返回 至少 能删除数组中的一半整数的整数集合的最小大小。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 #贪心 #堆（优先级队列） #排序 
### 思路一：Map哈希表
3. 利用Map作哈希表，保存元素数量；
4. 利用`values()`方法获取每个元素对应的数量，并调用`list.sort()`方法进行倒排；
5. 贪心获取元素数量，若ans已超过$\frac{n}{2}$，则直接返回。
```java
class Solution {
    public int minSetSize(int[] arr) {
        int n = arr.length;
        Map<Integer,Integer> map = new HashMap<>();
        for (int num : arr){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        List<Integer> cnt = new ArrayList<>(map.values());
        cnt.sort((a,b) -> b-a);
        int ans = 0;
        for (int i = 0; i < cnt.size(); i++){
            ans += cnt.get(i);
            if (ans >= n/2){
                return i+1;
            }
        }
        return -1;
    }
}
```
**时间复杂度：** $O(NlogN)$，瓶颈在于排序。
**空间复杂度：** $O(N)$
### 思路二：数组哈希表
获取$arr$的最大值$mx$，通过
```java
class Solution {
    public int minSetSize(int[] arr) {
        int n = arr.length;
        int mx = 0;
        for (int num : arr){
            mx = mx >= num ? mx : num;
        }
        int[] cnt = new int[mx+1];
        for (int num : arr){
            cnt[num]++;
        }
        Arrays.sort(cnt);
        int ans = 0;
        for (int i = cnt.length-1; i >= 0; i--){
            ans += cnt[i];
            if (ans >= n/2){
                return cnt.length-i;
            }
        }
        return -1;
    }
}
```
**时间复杂度：** $O(N+UlogU)$，其中U为arr的最大值
**空间复杂度：** $O(U)$

## 3159. 查询数组中元素的出现位置
### 题目
给你一个整数数组 `nums` ，一个整数数组 `queries` 和一个整数 `x` 。

对于每个查询 `queries[i]` ，你需要找到 `nums` 中第 `queries[i]` 个 `x` 的位置，并返回它的下标。如果数组中 `x` 的出现次数少于 `queries[i]` ，该查询的答案为 -1 。

请你返回一个整数数组 `answer` ，包含所有查询的答案。
### 信息
- **难度：** medium
- **重要性：** #★☆☆☆☆
- **标签：** #数组 #哈希表 
### 思路一：Map哈希表
queries数组给出的第i次出现，i是从1开始的，所以我们保存时应该也要从1开始，故使用哈希表是从idx=1开始。
获取结果时，遍历queries数组，若`queries[i]`作为Key在map中出现，则直接赋值；否则令`queries[i]=-1`。
```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        // 记录第i次出现x的位置
        Map<Integer, Integer> map = new HashMap<>();
        int idx = 1;
        for (int i = 0; i < nums.length; i++){
            // 存储x出现的位置
            if (nums[i] == x){
                map.put(idx,i);
                idx++;
            }
        }
        for (int i = 0; i < queries.length; i++){
            // 存在
            if (map.containsKey(queries[i])){
                queries[i] = map.get(queries[i]);
            }else{
                queries[i] = -1;
            }
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$
### 思路二：数组哈希表
思路一致，只不过采用数组作为哈希表，利用数组下标作为出现次数。

```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        int[] position = new int[nums.length+1];
        int idx = 1;
        // 找到所有x出现的位置
        Arrays.fill(position,-1);
        for (int i = 0; i < nums.length; i++){
            if (nums[i] == x){
                position[idx] = i;
                idx++;
            }
        }       
        
        for (int i = 0; i < queries.length; i++){
            int curr = queries[i];
            if (curr < position.length && position[curr] != -1){
                queries[i] = position[curr];
            }else {
                queries[i] = -1;
            }
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$

### 思路二：List哈希表
最佳思路，既避免了使用HashMap需要计算哈希值造成的效率偏低一丢丢；也避免了数组造成的初始化空间过大。

**具体算法流程：**
- 初始化ArrayList，遍历nums数组，存储所有x出现的位置。
- 遍历queries：
	- 若出现`queries[i]`的位置大于list的大小，说明不存在；
	- 若`queries[i]`小于size，说明存在，直接`get(queries[i]-1)`获取第`queries[i]`次出现的位置。
```java
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        List<Integer> pos = new ArrayList<>();
        for (int i = 0; i < nums.length; i++){
            if (nums[i] == x){
                pos.add(i);
            }
        }
        for (int i = 0; i < queries.length; i++){
            queries[i] = queries[i] > pos.size() ? -1 : pos.get(queries[i]-1);
        }
        return queries;
    }
}
```
**时间复杂度：** $O(N+M)$
**空间复杂度：** $O(M)$

## 3046. 分割数组
### 题目
给你一个长度为 **偶数** 的整数数组 `nums` 。你需要将这个数组分割成 `nums1` 和 `nums2` 两部分，要求：
- `nums1.length == nums2.length == nums.length / 2` 。
- `nums1` 应包含 **互不相同** 的元素。
- `nums2`也应包含 **互不相同** 的元素。

如果能够分割数组就返回 `true` ，否则返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★☆☆☆
- **标签：** #数组 #哈希表 
### 思路一：
因为数组是偶数的，并且nums1和nums2的长度相同，因此我们对每个元素计数，若出现元素的个数大于2，说明不能正常分割，否则可以。
```java
class Solution {
    public boolean isPossibleToSplit(int[] nums) {
        int[] cnt = new int[101];
        for (int num : nums){
            cnt[num]++;
            if (cnt[num] > 2){
                return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 1366. 通过投票对团队排名
### 题目
现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。

排名规则如下：

- 参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。
- 如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。

给你一个字符串数组 `votes` 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。

请你返回能表示按排名系统 **排序后** 的所有团队排名的字符串。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #哈希表 #排序 
### 思路一：哈希表+计数
这题的基本思路就是：利用哈希表存储每个队伍的得票数，然后再根据票数排序。根据题意，队伍为26个字母，最多只有26个，故定义二维数组：`第一维维度=26`，`第二维维度=str.length()`。
**具体算法流程：**
6. 定义二维数组`cnt[26][teamNum+1]`，第一维表示队伍，第二维表示票数；
7. 将cnt数组中的`cnt[teamNum]`设为对应字母，便于后续票数相同时根据字母排序，以及最后的结果构造；
8. 遍历votes数组，更新每个队伍的票数；
9. 数组排序，自定义排序规则：先按照票数排序，最后才按照字母排序。由于票数有多个，因此需要使用for循环，相当于选票1相同，按照选票2排序，选票2相同，按照选票3排序等等等；
10. 构造答案。
```java
class Solution {
    public String rankTeams(String[] votes) {
        // 投票人数
        int peopleNum = votes.length;
        // 队伍数
        int teamNum = votes[0].length();
        // 第一维用于表示队伍
        // 第二维用于表示获取的投票数
        int[][] cnt = new int[26][teamNum+1];

        for (int i = 0; i < 26; i++){
            cnt[i][teamNum] = i;
        }

        for (String vote : votes){
            // 遍历String，更新排名
            char[] tmp = vote.toCharArray();
            for (int i = 0; i < teamNum; i++){
                cnt[tmp[i]-'A'][i]++;
            }
        }
        StringBuilder ans = new StringBuilder();
        // 自定义排序，按照1,2
        Arrays.sort(cnt, (a,b) -> {
            for (int i = 0; i < teamNum; i++){
                if (a[i] != b[i]){
                    return b[i] - a[i];
                }
            }
            return a[teamNum] - b[teamNum];
        });
        // 根据排名构造答案
        for (int i = 0; i < teamNum; i++){
            ans.append((char)(cnt[i][teamNum] + 'A'));
        }
        return ans.toString();
    }
}
```
**时间复杂度：** $O(N^2logN)$
**空间复杂度：** $O(26\times N)$

## 347. 前 K 个高频元素
### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #数组 #哈希表 #排序 #堆（优先级队列） #桶排序
### 思路一：优先队列
使用Map作为哈希表存储每一个元素的出现次数。之后在将每一个Key放入优先队列中，根据其频次进行排序。最后出队k个元素，存入结果。
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        PriorityQueue<Integer> pq = new PriorityQueue((a,b) -> map.get(b) - map.get(a));
        for (int num : nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        for (int key : map.keySet()){
            pq.add(key);
        }
        
        int[] ans = new int[k];
        for (int i = 0; i < k; i++){
            ans[i] = pq.poll();
        }
        
        return ans;
    }
}

```
**时间复杂度：** $O(NlogN)$
**空间复杂度：** $O(N)$

### 思路二：桶排序
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num,map.getOrDefault(num,0)+1);
        }
        // 元素最多只能出现n次
        List<Integer>[] cnt = new List[n+1];
        for (int i = 0; i <= n; i++) {
            cnt[i] = new ArrayList<>();
        }
        for (int key : map.keySet()) {
            // 将对应出现频次的元素添加到list中. 
            cnt[map.get(key)].add(key);
        }
        int[] ans = new int[k];
        int idx = 0;
        // 获取前k高频
        for (int i = n; i >= 0; i--) {
            for (int num : cnt[i]) {
                ans[idx++] = num;
                if (idx == k) {
                    return ans;
                }
            }
        }
        return ans;

    }
}
```
**时间复杂度：** $O(N)$ 
**空间复杂度：** $O(N)$

## 73. 矩阵置零
>**时间**：2025-02-19 17:38:31
### 题目
给定一个 `m x n` 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：O(1)做法
利用第一行和第一列存储对应行或列是否存在零元素。并且提前遍历第一行和第一列，若存在0，则提前存储，并在最后置0结束后单独将第一行或第一列置零。

	为什么可以存储呢？不会导致第一行或第一列原来的值丢失吗？
- 假设第一行的索引`i`上的元素是1，但由于该行存在0元素，因此被置0. 但由于该行存在0，该行所有元素都会被置0，因此无需保存原来的值。并且我们提前遍历了第一行，若元素原本是0，则该行都会被置0，我们相当于用`rowZero`来保存了原来的0，以便后续将第一行所有元素置0.

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        // 利用第一行和第一列做标记，因为被做标记后，元素肯定会被置0，因此无需记录原本的值。
        // 但是要注意，可能第一行和第一列原本就存在0，所以需要提前记录，否则可能会导致第一行和第一列未被正确置0.
        int m = matrix.length;
        int n = matrix[0].length;
        boolean rowZero = false;
        boolean colZero = false;
        for (int i = 0; i < m; i++){
            if (matrix[i][0] == 0) {
                colZero = true;
                break;
            }
        }
        for (int i = 0; i < n; i++){
            if (matrix[0][i] == 0) {
                rowZero = true;
                break;
            }
        }
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                if (matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                if (matrix[i][0] == 0 || matrix[0][j] == 0){
                    matrix[i][j] = 0;
                }
            }
        }
        for (int i = 0; i < m; i++){
            if (colZero){
                matrix[i][0] = 0;
            }
        }
        for (int i = 0; i < n; i++){
            if (rowZero){
                matrix[0][i] = 0;
            }
        }
    }
}
```
**时间复杂度：** $O(M\times N)$
**空间复杂度：** $O(1)$

## 30. 串联所有单词的子串
>**时间**：2025-02-20 14:40:56
### 题目
给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含  `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。
### 信息
- **难度：** hard
- **重要性：** #★★★★★ 
- **标签：** #哈希表 #数组 
### 思路一：多起点滑动窗口
```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        // 记录索引位置
        List<Integer> ans = new ArrayList<>();
        if(s == null || s.length() == 0 || words == null || words.length == 0) {
            return ans;
        }

        // s字符串的长度
        int n = s.length();
        // 单个单词长度（所有单词长度相同）
        int wordLen = words[0].length();
        // 单词个数
        int wordCnt = words.length;
        // 单词总长度
        int totalLen = wordCnt * wordLen;
        

        // map用于统计出现次数
        Map<String,Integer> map = new HashMap<>();
        for (String word : words){
            map.put(word,map.getOrDefault(word,0)+1);
        } 

        for (int i = 0; i < wordLen; i++) {
            Map<String,Integer> curr = new HashMap<>();
            // 用于记录窗口长度
            int l = i;
            int same = 0;
            for (int r = i; r <= n - wordLen; r += wordLen){
                // 当前子串
                String sub = s.substring(r,r+wordLen);
                // 存在该字符
                if (map.containsKey(sub)) {
                    curr.put(sub,curr.getOrDefault(sub,0)+1);
                    same++;
                    // 如果当前单词出现次数超出要求，收缩窗口
                    while (curr.get(sub) > map.get(sub)){
                        String left = s.substring(l,l+wordLen);
                        curr.put(left, curr.get(left)-1);
                        same--;
                        l += wordLen;
                    }
                    if (same == wordCnt) {
                        ans.add(l);
                        String left = s.substring(l,l+wordLen);
                        curr.put(left, curr.get(left) - 1);
                        same--;
                        l += wordLen;
                    }
                }else {
                    curr.clear();
                    same = 0;
                    l = r + wordLen;
                }
            }
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 205. 同构字符串
>**时间**：2025-02-21 15:17:13
### 题目
给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #哈希表 #字符串 
### 思路一：哈希表
利用哈希表存储映射关系s到t和t到s的映射关系。

具体算法流程：
1. 定义两个哈希表存储映射关系mapST和mapTS，并填充-1，通过-1来判断是否更新过映射关系；
2. 当两个map的值都为-1时，说明此时映射关系暂未被更新，则更新映射关系，并继续往后判断；
3. 若映射关系已被更新（即两个map中存在不为-1的值），则判断映射关系是否正确：`mapST[c1] != c2 && mapTS[c2] != c1`.
```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] mapST = new int[128];
        int[] mapTS = new int[128];
		// 利用-1来判断是否已有映射关系
        Arrays.fill(mapST, -1);
        Arrays.fill(mapTS, -1);
        
        for (int i = 0; i < s.length(); i++) {
            char c1 = s.charAt(i);
            char c2 = t.charAt(i);
            if (mapST[c1] == -1 && mapTS[c2] == -1) {
                mapST[c1] = c2;
                mapTS[c2] = c1;
            } else if (mapST[c1] != c2 && mapTS[c2] != c1) {
                return false;
            }
        }
        return true;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$

## 36. 有效的数独
>**时间**：2025-02-19 19:59:28
### 题目
请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）
### 信息
- **难度：** medium
- **重要性：** #★★★★☆
- **标签：** #数组 #哈希表 
### 思路一：Set作哈希表
利用三个哈希表分别存储行、列和九宫格中是否出现过数字1~9. 那么如何实现判断数字是否存在的哈希表呢？数组、HashMap、HashSet都可以实现！
```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        Set<String> set = new HashSet<>();
        for (int i = 0; i < board.length; i++){
            for (int j = 0; j < board[0].length; j++){
                char c = board[i][j];
                if (c != '.'){
                    int val = c - '0';
                    // System.out.println(val);
                    String row = "row" + i + val;
                    System.out.println(row);                    
                    String col = "col" + j + val;
                    // int idx = i/3 + j/3;
                    String nine = "nine" + i/3 + j/3 + val;
                    if (set.contains(row) || set.contains(col) || set.contains(nine)){
                        return false;
                    }
                    set.add(row);
                    set.add(col);
                    set.add(nine);
                }
            }
        }
        return true;
    }
}
```
**时间复杂度：** $O(1)$
**空间复杂度：** $O(1)$

### 思路二：数组作哈希表
九宫格一共9个，因此需要利用将行i和列j转换为索引0~8，即`int idx = (i/3) * 3 + j/3;`！
```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] row = new boolean[9][10];
        boolean[][] col = new boolean[9][10];
        boolean[][] nine = new boolean[9][10];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++){
                char c  = board[i][j];
                if (c != '.') {
                    int val = c - '0';
                    // 九宫格的0~8.
                    int idx = (i/3) * 3 + j/3;
                    if (row[i][val] || col[j][val] || nine[idx][val]){
                        return false;
                    }
                    row[i][val] = true;
                    col[j][val] = true;
                    nine[idx][val] = true;
                }
            }
        }
        return true;
    }
}
```
**时间复杂度：** $O(1)$
**空间复杂度：** $O(1)$

## 1512. 好数对的数目
>**时间**：2025-02-22 14:40:33
### 题目
给你一个整数数组 `nums` 。

如果一组数字 `(i,j)` 满足 `nums[i]` == `nums[j]` 且 `i` < `j` ，就可以认为这是一组 **好数对** 。

返回好数对的数目。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #数组 #哈希表 
### 思路一：枚举右，维护左
利用cnt数组维护数字出现的次数，然后枚举右指针，通过`cnt[nums[j]]`以$O(1)$时间复杂度获取相同数字出现的次数，并且由于是枚举右维护左，自然满足`i < j`，因此`ans+=cnt[nums[i]]`即可获得正确答案。
```java
class Solution {
    public int numIdenticalPairs(int[] nums) {
        // 枚举右, 维护左
        int n = nums.length;
        int[] cnt = new int[101];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += cnt[nums[i]];
            cnt[nums[i]]++;
        }
        return ans;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$

## 2506. 统计相似字符串对的数目
>**时间**：2025-02-22 14:46:42
### 题目
给你一个下标从 **0** 开始的字符串数组 `words` 。

如果两个字符串由相同的字符组成，则认为这两个字符串 **相似** 。
- 例如，`"abca"` 和 `"cba"` 相似，因为它们都由字符 `'a'`、`'b'`、`'c'` 组成。
- 然而，`"abacba"` 和 `"bcfd"` 不相似，因为它们不是相同字符组成的。

请你找出满足字符串 `words[i]` 和 `words[j]` 相似的下标对 `(i, j)` ，并返回下标对的数目，其中 `0 <= i < j <= words.length - 1` 。
### 信息
- **难度：** easy
- **重要性：** #★★★★☆
- **标签：** #字符串 #哈希表 
### 思路一：哈希表 + 位运算
利用位运算结合mask变量记录某个字符的字母出现情况，然后结合将其放入哈希表中，并通过枚举右维护左的方式获取先前由符号条件的字母数量。 

位运算`mask |= 1 << (c-'a');` 可拆解为两步：①`1 << (c-'a')`表示将对应位置1；②`mask |= ~`表示与①的结果或运算。
```java
class Solution {
    public int similarPairs(String[] words) {
        int n = words.length;
        Map<Integer, Integer> cnt = new HashMap<>();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int mask = 0;
            for (char c : words[i].toCharArray()) {
                mask |= 1 << (c-'a');
            }
            ans += cnt.getOrDefault(mask,0);
            cnt.put(mask,cnt.getOrDefault(mask,0)+1);
        }
        return ans;
    }
}
```
**时间复杂度：** $O(L)$，L表示所有字符的总长度。
**空间复杂度：** $O(N)$，N表示words的长度。

## 290. 单词规律
>**时间**：2025-02-22 16:10:29
### 题目
给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #字符串 #哈希表 
### 思路一：哈希表
利用**两个哈希表**确保1对1的映射关系，避免出现`a->dog`，而`b->dog`的情况！
```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] strs = s.split("\\s+");
        String[] map = new String[26];
        if (strs.length != pattern.length()) return false;
        Map<String,Boolean> memo = new HashMap<>();
    
        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';
            // 已建立映射关系
            if (map[idx] != null) {
                // 判断映射关系是否相等
                if (!map[idx].equals(strs[i])) return false;
                // 相等，直接continue。
            }else { 
                // 还未建立映射关系
                if (!memo.containsKey(strs[i])){
                    map[idx] = strs[i];
                    memo.put(strs[i], true);
                }else return false;
            }
        }
        return true;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(1)$
### 思路二：
利用Set判断是否出现重复的映射关系。
```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] map = new String[26];
        String[] sArray = s.split(" ");
        if (pattern.length() != sArray.length) {
            return false;
        }
        for (int i = 0; i < pattern.length(); i++) {
            if (map[pattern.charAt(i) - 'a'] == null) {
                map[pattern.charAt(i) - 'a'] = sArray[i];
            } else if (!map[pattern.charAt(i) - 'a'].equals(sArray[i])) {
                return false;
            }
        }
        Set<String> set = new HashSet<>();
        for (String str : map) {
            if (!set.add(str) && str != null) {
                return false;
            }
        }
        return true;
    }
}
```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
## 
>**时间**：2025-02-24 14:01:22
### 题目
给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。
### 信息
- **难度：** easy
- **重要性：** #★★★☆☆
- **标签：** #数组 #哈希表 
### 思路一：哈希表
枚举右，维护左。

利用哈希表存储数组中元素的`(值, 索引)`，实现O(1)时间复杂度判断 是否已出现相等元素以及获取索引。 因此，枚举右，维护左，不断利用`containsKey()`进行判断，利用`put()`不断添加、更新元素的`(值, 索引)`关系。
	注意，由于题目要求`<=k`，因此遇到重复元素，直接更新索引即可。
```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(nums[0], 0);
        for (int i = 1; i < n; i++) {
            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {
                return true;
            }
            // 因为是<=k, 因此出现重复元素, 更新为最新索引即可.
            map.put(nums[i],i);
        }
        return false;
    }
}

```
**时间复杂度：** $O(N)$
**空间复杂度：** $O(N)$
### 思路二：哈希表 + 定长滑动窗口
利用哈希表存储窗口的元素，当窗口长度`>=k`时，左侧窗口移动，保持窗口长度`==k`并移除最左侧元素。
	注意：这里由于是先判断是否存在重复元素，因此`i == k`时就需要移除最左侧元素。
```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet<Integer> set = new HashSet<>();
        int n = nums.length;
        for (int i = 0; i < n; i++ ) {
            if (!set.add(nums[i])) {
                return true;
            }
            if (i >= k) {
                set.remove(nums[i-k]);
            }
        }
        return false;
    }
}
```
**时间复杂度：** 
**空间复杂度：** 

## 2502. 设计内存分配器
>**时间**：2025-02-25 09:53:15
### 题目
给你一个整数 `n` ，表示下标从 **0** 开始的内存数组的大小。所有内存单元开始都是空闲的。

请你设计一个具备以下功能的内存分配器：
1. **分配** 一块大小为 `size` 的连续空闲内存单元并赋 id `mID` 。
2. **释放** 给定 id `mID` 对应的所有内存单元。

**注意：**
- 多个块可以被分配到同一个 `mID` 。
- 你必须释放 `mID` 对应的所有内存单元，即便这些内存单元被分配在不同的块中。

实现 `Allocator` 类：
- `Allocator(int n)` 使用一个大小为 `n` 的内存数组初始化 `Allocator` 对象。
- `int allocate(int size, int mID)` 找出大小为 `size` 个连续空闲内存单元且位于  **最左侧** 的块，分配并赋 id `mID` 。返回块的第一个下标。如果不存在这样的块，返回 `-1` 。
- `int freeMemory(int mID)` 释放 id `mID` 对应的所有内存单元。返回释放的内存单元数目。
### 信息
- **难度：** medium
- **重要性：** #★★★☆☆ 
- **标签：** #数组 #哈希表 #设计 #模拟 
### 思路一：数组 + 哈希表
根据题意，利用数组模拟内存空间。分配内存时，可以转换为从左到右寻找符合条件的子数组的问题；释放内存，即遍历寻找mID相符的索引，置为0即可。
```java
class Allocator {
    int[] memo;
    int n;
    public Allocator(int n) {
        memo = new int[n];
        this.n = n;
    }
    // 1 <= n,mid <= 1000
    // memo[i] = 0代表此时还未被分配空间
    public int allocate(int size, int mID) {
        // 从左侧开始的长度为size的最长连续子数组.
        int cnt = 0;
        int l = 0;
        for (int i = 0; i < n; i++) {
            if (memo[i] == 0) {
                cnt++;
            }else {
                l = i+1;
                cnt = 0;
            }
            if (cnt == size) {
                Arrays.fill(memo,l,i+1,mID);
                return l;
            }
        }
        return -1;
    }
    
    public int freeMemory(int mID) {
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (memo[i] == mID){
                memo[i] = 0;
                cnt++;
            }
        }
        return cnt;
    }
}
```

## 2353. 设计食物评分系统
>**时间**：2025-02-28 14:17:11
### 题目
设计一个支持下述操作的食物评分系统：
- **修改** 系统中列出的某种食物的评分。
- 返回系统中某一类烹饪方式下评分最高的食物。

实现 `FoodRatings` 类：
- `FoodRatings(String[] foods, String[] cuisines, int[] ratings)` 初始化系统。食物由 `foods`、`cuisines` 和 `ratings` 描述，长度均为 `n` 。
    - `foods[i]` 是第 `i` 种食物的名字。
    - `cuisines[i]` 是第 `i` 种食物的烹饪方式。
    - `ratings[i]` 是第 `i` 种食物的最初评分。
- `void changeRating(String food, int newRating)` 修改名字为 `food` 的食物的评分。
- `String highestRated(String cuisine)` 返回指定烹饪方式 `cuisine` 下评分最高的食物的名字。如果存在并列，返回 **字典序较小** 的名字。

注意，字符串 `x` 的字典序比字符串 `y` 更小的前提是：`x` 在字典中出现的位置在 `y` 之前，也就是说，要么 `x` 是 `y` 的前缀，或者在满足 `x[i] != y[i]` 的第一个位置 `i` 处，`x[i]` 在字母表中出现的位置在 `y[i]` 之前。
### 信息
- **难度：** medium
- **重要性：** #★★★★★
- **标签：** #字符串 #设计 #哈希表 #有序集合 #堆（优先级队列） 
### 思路一：
对于某个烹饪方式，要按照食物的评分排序，若评分相同，则按照积分排序，因此考虑为每一个烹饪方式建立一个优先级队列。并且，还要提供修改评分功能，因此不考虑`PriorityQueue`，而是考虑`TreeSet`，可以利用其`get`、`remove`方法很方便的获取、移除，并在修改评分后重新再加入`TreeSet`中！

排序方式如何实现？对于评分排序，很容易；但是字典序排列呢？那就是使用`a.name.compareTo(b.name)`，可以比较二者的字典序，并进行排列。

>[!IMPORTANT] 字符串的字典序比较方法：
compareTo() 方法用于两种方式的比较：
>- 字符串与对象进行比较。
>- 按字典顺序比较两个字符串。

```java
class FoodItem {
    String name;
    String cuisine;
    int rating;
    public FoodItem(String name, String cuisine, int rating){
        this.name = name;
        this.cuisine = cuisine;
        this.rating = rating;
    }
}
class FoodRatings {
    // 根据名字获取事物
    Map<String, FoodItem> name2Food;
    // 存储烹饪方式对应的所有食物
    Map<String, TreeSet<FoodItem>> cuis2Food;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        name2Food = new HashMap<>();
        cuis2Food = new HashMap<>();
        for (int i = 0; i < foods.length; i++) {
            FoodItem curr = new FoodItem(foods[i],cuisines[i],ratings[i]);
            name2Food.put(foods[i], curr);
            cuis2Food.putIfAbsent(cuisines[i], new TreeSet<>((a,b) -> {
                // 分数不同, 降序排列
                if (a.rating != b.rating){
                    return b.rating - a.rating;
                }else {
                    // 分数相同, 按照字典序
                    return a.name.compareTo(b.name);
                }
            }));
            cuis2Food.get(cuisines[i]).add(curr);
        }
    }

    
    public void changeRating(String food, int newRating) {
                // 根据名字, 获取食物, 并根据烹饪方式, 获取对应TreeSet,移除、更新并重新加入, 以保证排序正确.
        FoodItem currFood = name2Food.get(food);
         
        cuis2Food.get(currFood.cuisine).remove(currFood);
        currFood.rating = newRating;
        cuis2Food.get(currFood.cuisine).add(currFood);
    }
    
    public String highestRated(String cuisine) {
        return cuis2Food.get(cuisine).first().name;
    }
}

/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);
 * obj.changeRating(food,newRating);
 * String param_2 = obj.highestRated(cuisine);
 */

```
**时间复杂度：** 
**空间复杂度：** 