## 排序算法
### 快速排序
每次选取一个基准元素，实现左区间都是小于等于基准元素的数，右区间都是大于基准元素的数。由此不断递归，最终实现排序。
- partition实现对左右区间的划分，同时返回基准元素的索引。以便后续基于已经划分好的nums数组和pivot索引，继续递归进行划分。
```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int l, int r){
        if (l >= r) {
            return;
        }
        int pivotIdx = partition(nums, l, r);
        quickSort(nums, l, pivotIdx-1);
        quickSort(nums, pivotIdx+1, r);
    }
    private int partition(int[] nums, int l, int r){
        int pivot = nums[l];
        int j = l;
        int tmp;
        for (int i = l+1; i <= r; i++) {
            // 元素小于基准元素: 交换
            if (nums[i] <= pivot) {
                j++;
                tmp = nums[j];
                nums[j] = nums[i];
                nums[i] = tmp;
            }
        }
        tmp = nums[j];
        nums[j] = nums[l];
        nums[l] = tmp;
        return j;
    }
}

```
#### 增加随机种子
增加随机数，避免完全逆序和正序数组。

	注意：random.nextInt(int i)是随机到[0,i)之间的数。

如果更改循环不变量，也可以变成：
- `int j = l + 1;`, `swap(nums, i, j-1)`
```java
import java.util.*;
class Solution {
    private static final Random random = new Random(System.currentTimeMillis());
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int l, int r){
        if (l >= r) {
            return;
        }
        int pivotIdx = partition(nums, l, r);
        quickSort(nums, l, pivotIdx-1);
        quickSort(nums, pivotIdx+1, r);
    }
    private int partition(int[] nums, int l, int r){
        int randomIdx = l + random.nextInt(r - l + 1);
        // 选取随机基准元素
        swap(nums, randomIdx, l);
        int pivot = nums[l];
        int j = l;
        for (int i = l+1; i <= r; i++) {
            // 元素小于基准元素: 交换
            if (nums[i] <= pivot) {
                j++;
                tmp = nums[j];
                nums[j] = nums[i];
                nums[i] = tmp;
            }
            // 元素大于基准元素, 不变
        }
        // 将基准值移动到分界处s
        swap(nums, l, j);
        return j;
    }
    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}
```
#### 双路快排
定义基准元素。需要保证基准元素左侧都是小于等于的元素，基准元素右侧都是大于等于的元素。
- 假设区间是le，ge，则左侧区间为`[left, le )`，右侧区间为`(ge, right)
le走到第一个大于等于pivot的元素，ge走到第一个小于等于pivot的元素，以保证le左侧都是小于基准的，ge右侧都是大于基准的。
**注意：是交换left和ge，这样才能保证左侧都是小于pivot的元素，右侧都是大于pivot的元素。**

![[Pasted image 20250806214217.png|600]]
![[Pasted image 20250806214054.png|600]]
```java
import java.util.*;
class Solution {
    private static final Random random = new Random(System.currentTimeMillis());
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int l, int r){
        if (l >= r) {
            return;
        }
        int pivotIdx = partition(nums, l, r);
        quickSort(nums, l, pivotIdx-1);
        quickSort(nums, pivotIdx+1, r);
    }
    private int partition(int[] nums, int l, int r){
        int randomIdx = l + random.nextInt(r - l + 1);
        swap(nums, randomIdx, l);
        int pivot = nums[l];
        int le = l + 1;
        int ge = r;
        while (true) {
            // le走到第一个大于等于pivot的位置
            while (le <= ge && nums[le] < pivot) {
                le++;
            }
            // ge走到第一个小于等于pivot的位置
            while (ge >= le && nums[ge] > pivot) {
                ge--;
            }
            // 跳过
            if (le >= ge) {
                break;
            }
            swap(nums, le, ge);
            le++;ge--;
        }
        swap(nums, l, ge);
        return ge;
    }
    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}
```

#### 三路快排

## 归并排序
递归地划分数组为两个部分，直到最后只剩一个元素，然后就是合并两个有序数组。
这样在最顶端，最终就会变成两个大的有序数组进行合并。
在最底端，就是两个单一元素的合并。

注意：我们需要保证i和j不越界，i的范围是`[l,m]`，j的范围是`[m+1,r]`。例如i越界后，此时就只能将j归并回去了（因为i的部分已经全部合并）。
```java
class Solution {
    private int[] tmp;
    public int[] sortArray(int[] nums) {
        tmp = new int[nums.length];
        mergeSort(nums, 0, nums.length-1, tmp);   
        return nums;
    }
    private void mergeSort(int[] nums, int l, int r, int[] tmp) {
        if (l >= r) {
            return;
        }
        int mid = (l + r) / 2;
        mergeSort(nums,l, mid, tmp);
        mergeSort(nums, mid+1, r, tmp);

        for (int i = l; i <= r; i++) {
            tmp[i] = nums[i];
        }
        // 合并两个有序数组
        int i = l;
        int j = mid+1;
        for (int k = l; k <= r; k++) {
            if (i == mid + 1) {
                nums[k] = tmp[j];
                j++;
            }else if (j == r+1) {
                nums[k] = tmp[i];
                i++;
            }else if (tmp[i] <= tmp[j]) {
                nums[k] = tmp[i];
                i++;
            }else if (tmp[i] > tmp[j]) {
                nums[k] = tmp[j];
                j++;
            }
        }
    }
}
```