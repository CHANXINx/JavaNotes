# 1. 初识JVM
## 1.1 JVM介绍
JVM(Java Virtual Machine),本质上是一个**运行在计算机上的程序**，他的职责是**运行Java字节码文件。**

**Java源代码执行流程:**
1. **编写**源代码文件`.java`;
2. 源代码文件经javac编译器**编译**获得Java字节码文件`.class`;
3. 使用Java虚拟机**加载并运行**Java字节码文件，此时会启动一个新的进程.
![[Pasted image 20241029203953.png]]

## 1.2 JVM的功能
>解释和运行; 内存管理; 即时编译.
### 1.2.1 解释和运行
JVM对字节码(class)文件中的指令，**实时的解释成机器码**，让计算机执行。

字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令**实时地解释成机器码**，机器码是计算机可以运行的指令。
- 实现了跨平台性.

### 1.2.2 内存管理
JVM:1)自动为对象,方法等分配内存,以及2)提供了自动的垃圾回收机制.

### 1.2.3 即时编译
JIT即时编译器对热点代码进行优化,提高执行效率.

若JVM在运行过程中发现某处代码是热点代码,JIT会优化这段代码并**将优化后的机器码保存在内存**中,下次调用时,JVM会将机器码**从内存中取出直接调用**,无需再进行解释,提高执行效率.


# 2. 字节码文件详解
## 2.1 Java虚拟机的组成

![[Pasted image 20241029204832.png]]
- 类加载子系统：核心组件类加载器，负责将**字节码文件中的内容加载到内存中**。
- 运行时数据区: JVM管理的内存,创建的对象,类信息等内容都存放于此.
- 执行引擎: 包含了即时编译器、解释器、垃圾回收器.
	- 执行引擎使用**解释器将字节码指令解释成机器码**
	- 使用**即时编译器优化性能**
	- 使用**垃圾回收器回收不再使用的对象**
- 本地接口: 调用本地使用C/C++编译好的方法,本地方法在Java中声明时，都会带上`native`关键字

## 2.2 字节码文件的组成
字节码文件总共可以分为以下几个部分：
- 基础信息：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息
- 常量池： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用
- 字段： 当前类或接口声明的字段信息
- 方法： 当前类或接口声明的方法信息，核心内容为方法的字节码指令
- 属性： 类的属性，比如源码的文件名、内部类的列表等

### 2.2.1 基础信息
#### 2.2.1.1 魔数
- 文件是无法通过文件扩展名来确定文件类型的，**文件扩展名可以随意修改不影响文件的内容**.
- 软件会使用**文件的头几个字节**（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。

故字节码文件(.class)也需要文件头来确定文件类型,称为魔数,值为`0xcafebabe`.

#### 2.2.1.2 主副版本号
主副版本号指的是**编译字节码文件时使用的JDK版本号**,主版本号用来标识大版本号,副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。

1.2之后的主版本号为 `主版本号-44`,例如主版本号52就是JDK8.

版本号的作用主要是**判断当前字节码的版本和运行时的JDK是否兼容**。例如低版本的JDK无法运行高版本的字节码文件.
- 解决办法:1)升级JDK(不推荐); 2)将第三方依赖的版本号降低以满足要求(推荐).

#### 2.2.1.3 其他基础信息
除了魔数,主副版本号,还包括访问标志(public),类和接口索引等.
![[Pasted image 20241029235223.png]]

### 2.2.2 常量池
常量池的作用：避免相同的内容重复定义,节省空间.

保存了字符串常量,类或接口名,字段名,主要在字节码指令中使用.

例如代码中定义了`String s1 = "Hello!!!";String s2 = "Hello!!!";`, 则可以看到常量池中只保存了一份字符串及其字面量. 
![[Pasted image 20241030000433.png]]![[Pasted image 20241030000517.png]]

字段或字节码指令中可以通过编号来快速找到字符串.
	● 字节码指令中通过编号引用到常量池的过程称之为**符号引用**.

**字节码指令中的引用:**
![[Pasted image 20241030000707.png]]
**字段中的引用:**
![[Pasted image 20241030000829.png]]
### 2.2.3 字段
当前类或接口声明的字段信息
![[Pasted image 20241029234821.png]]
- 当前类中有s1和s2两个字段
### 2.2.4 方法
字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容存放在方法的Code属性中。
![[Pasted image 20241029215421.png]]
![[Pasted image 20241029215357.png]]

**操作数栈**是用来存放**临时**数据的内容，是一个栈式的结构，先进后出。
**局部变量表(数组)** 是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。 

#### 示例:通过字节码分析方法的执行流程

```Java
int i = 0; 
i = i++;
```
问此时i的值是多少?

字节码:
```bash hl:4
0 iconst_0     :将常量0放到操作数栈中
1 istore_1     :将操作数栈中的队顶元素存放到局部变量表下标为1的位置
2 iload_1      :将下标为1的元素复制到操作数栈中.
3 iinc 1 by 1  :将局部变量表1号位置元素+1.(直接操作局部变量表元素!!)
6 istore_1     :将操作数栈中的值存放到下标为1的位置,仍是0!!
7 return
```
- 可以看到,i++首先把0取出放到操作数栈中,之后对i进行加1操作,此时局部变量表中的i变为1,最后再将操作数栈中的临时值0存入局部变量表中,覆盖了先前的+1操作,所以最后i=0.


```java
int i = 0;  
i = ++i;
```

```bash
0 iconst_0
1 istore_1
2 iinc 1 by 1
5 iload_1
6 istore_1
7 return
```
- 可以看到,区别在于这里是先自增(`0->1`),再加载到操作数栈中(`加载的是1`),所以最后执行store,存放的也是i=1.

### 2.2.5 属性
属性主要指的是**类的属性**，比如源码的文件名、内部类的列表等。
![[Pasted image 20241029232613.png]]
## 2.3 字节码常用工具
### 2.3.1 javap
javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。**适合在服务器上查看字节码文件内容。**

### 2.3.2 jclasslib
IDEA插件,可在代码编译后试试看到字节码文件内容.

### 2.3.3 Arthas
Arthas 是一款**线上监控诊断产品**，通过全局视角实时查看应用 **load、内存、gc、线程的状态信息**，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。

dump命令: 将字节码文件保存到本地.
jad命令: 将类的字节码文件进行**反编译成源代码**，用于确认服务器上的字节码文件是否是最新的.

## ==2.4 类的生命周期==
类的生命周期描述了一个类**加载、连接、初始化、使用、卸载**的整个过程.
	其中,初始化可进一步细分为验证,准备,解析三个阶段.
![[Pasted image 20241030091314.png]]
### 2.4.1 加载阶段

1. 加载(Loading)阶段第一步是类加载器**根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息**，程序员可以使用Java代码拓展的不同的渠道.
	1) 本地磁盘获取文件
	2) 运行时动态代理生成
	3) Applet技术通过网络获取字节码文件(已淘汰)
2. 类加载器加载完类后,JVM会**将字节码信息保存到方法区中**,方法区中生成一个InstanceKlass对象,保存类的所有信息,里边还包含实现特定功能.
   ![[Pasted image 20241030091755.png|450]]
3. Java虚拟机同时会在**堆上生成与方法区中数据类似的java.lang.Class对象**，作用是在Java代码中去**获取类的信息**以及存储静态字段的数据（JDK8及之后）
	- 例如反射,就是从堆区获取类的信息.
	- 方法区中的InstanceKlass对象是由C++编写的,无法访问. 所以在堆区中创建了使用java语言包装的对象供程序员使用.
	- 堆区中的方法,字段信息少于方法区,只保留了必要的,保证安全性的内容.
   ![[Pasted image 20241030092056.png|450]]

### 2.4.2 连接阶段
连接阶段分为三个子阶段:
- 验证: 验证内容是否满足《Java虚拟机规范》。
- 准备: 给**静态变量**赋初值。
- 解析: **将常量池中的符号引用替换成指向内存的直接引用**。

#### 2.4.2.1 验证
验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。主要包含四部分:

1. **文件格式验证.** 验证文件是否以0xCAFEBABE开头,验证主次版本号是否满足JVM版本要求.
2. **元信息验证.** 例如类必须有父类(父类索引不为空).
3. **验证程序执行指令的语义.** 检查方法内指令的跳转,避免出错.
4. **符号引用验证.** 例如是否访问了其他类中private的方法等.
![[Pasted image 20241030095756.png]]

#### 2.4.2.2 准备
准备阶段**为==静态==变量（static）分配内存并设置初值**，每一种基本数据类型和引用数据类型都有其初值。
	● 在初始化阶段才会将value赋为用户定义的值.

**基本引用类型和引用数据类型的初值:**
![[Pasted image 20241030095938.png]]

**注意:**
- 若变量**用`final`修饰,则在准备阶段就直接赋值**,因为在后续阶段不会发生值的变更.

#### 2.4.2.3 解析
解析阶段主要是**将常量池中的符号引用替换为直接引用**.
	● 符号引用就是在字节码文件中使用编号来访问常量池中的内容。
	● 直接引用不在使用编号，而是**使用内存中地址**进行访问具体的数据。
	![[Pasted image 20241030101432.png]]

### 2.4.3 初始化阶段
#### 2.4.3.1 介绍
初始化阶段会执行字节码文件中**clinit**（class init 类的初始化）方法的字节码指令，**包含了静态代码块中的代码，并为静态变量赋值**。

```java
public class ClinitTest {  
    public static int value = 1;  
    static {  
        value = 2;  
    }  
    
    public static void main(String[] args) {  
    }  
}
```

**clinit方法:**
```bash hl:2
0 iconst_1                               : 将常量1放入操作数栈.
1 putstatic #7 <ClinitTest.value : I>#   : 弹出操作数栈的值,为#7(编号7)的静态变量赋值.
4 iconst_2                               : 将常量2放入操作数栈.
5 putstatic #7 <ClinitTest.value : I>    : 为静态变量#7赋值.
8 return
```

#### 2.4.3.2 执行时刻:
1. 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化;
2. 调用Class.forName(String className)。
3. new一个该类的对象时
4. 执行Main方法的当前类

##### 小测:
```Java
public class Test1 {
    public static void main(String[] args) {
        System.out.println("A");
        new Test1();
        new Test1();
    }

    public Test1(){
        System.out.println("B");
    }

    {
        System.out.println("C");
    }

    static {
        System.out.println("D");
    }
}
```
执行结果: 
```bash
D	（静态代码块，类加载时执行一次）
A	（main 方法中的第一个输出）
C	（第一个对象初始化代码块）
B	（第一个对象构造方法）
C	（第二个对象初始化代码块）
B	（第二个对象构造方法）
```
	
D是静态代码块,类加载时就会初始化,所以首先执行;
A是main方法执行时打印;
C是初始化代码块,在new该类对象时会执行,所以`new Test1()`时会打印C;
B是构造方法,也是new对象时打印.
并且D是静态初始化,只会在类加载时执行一次.C是普通初始化,只要有对象创建就会执行.

#### 2.4.3.3 clinit不会执行的几种情况
1. 无静态代码块且无静态变量赋值语句.
2. 有静态变量的声明,但是没有赋值:`public static int i;`
3. 静态变量使用final修饰,则会在准备阶段进行初始化.

#### 2.4.3.4 带继承的情况:
- 直接访问父类的静态变量,不会触发子类的初始化;
- 初始化子类之前,会先初始化父类.

**示例:**
```Java
public class Demo01 {
    public static void main(String[] args) {
        new B02();
        System.out.println(B02.a);
    }
}

class A02{
    static int a = 0;
    static {
        a = 1;
    }
}

class B02 extends A02{
    static {
        a = 2;
    }
}
```
**输出为2**

创建BO2对象时,会先初始化父类A02,所以此时`a=1`,然后再执行子类初始化,此时`a=2`.

## 2.5 类加载器
### 2.5.1 什么是类加载器
类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的**字节码获取并加载到内存**这一部分。
![[Pasted image 20241030141117.png]]
类加载器会通过二进制流的方式**获取到字节码文件的内容**，接下来将获取到的数据**交给Java虚拟机**，虚拟机**会在方法区和堆上生成对应的对象保存字节码信息**。

### 2.5.2 类加载器的分类 
类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。
1. **虚拟机底层实现**：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是**保证Java程序运行中==基础类==被正确地加载**，比如java.lang.String，Java虚拟机需要确保其可靠性。
2. **JDK中默认提供或者自定义**：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。**所有Java中实现的类加载器都需要继承ClassLoader这个抽象类**

#### JDK8及之前的分类:
三大类加载器:
**1)BootstrapClassLoader; 2)ExtClassLoader; 3)AppClassLoader**
![[Pasted image 20241030141644.png]]
### 2.5.3 启动类加载器
- 启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。
- 默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。
- 使用getClassLoader获取类加载器时,**返回值是null**,因为是由C++编写,所以不适合获取.


#### 2.5.3.1 使用启动类加载器加载拓展类:
1. **方法1:** **放入jre/lib下进行扩展**. 不推荐,因为启动类加载器会校验jar包的文件名,所以扩展类可能会由于文件名不匹配而不被加载.
2. **方法2: 使用参数进行扩展.** 使用`-Xbootclasspath/a:jar包目录/jar包名` 进行扩展.
	**例如:**`-Xbootclasspath/a:E:\OneDrive\Java_Learn\JVM\classloader-test\target\classloader-test.jar`

### 2.5.4 扩展类加载器和应用程序类加载器
- 扩展类加载器和应用程序类加载器都是**JDK中提供的、使用Java编写**的类加载器。
- 它们的源码都位于sun.misc.Launcher中，是一个静态内部类。**继承自URLClassLoader**。具备**通过目录或者指定jar包将字节码文件加载到内存中**。
	- 继承关系如图:![[Pasted image 20241030145201.png]]

#### 2.5.4.1 扩展类加载器
扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。**默认加载Java安装目录/jre/lib/ext下的类文件。**

**通过扩展类加载器去加载用户jar包:**
- **放入/jre/lib/ext下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容。
- **使用参数进行扩展使用参数进行扩展**。推荐，使用`-Djava.ext.dirs=jar包目录` 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录
	- `-Djava.ext.dirs=jdk自带jar包目录;用户jar包目录`

#### 2.5.4.2 应用程序加载器
应用程序类加载器会加载**classpath下的类文件**，默认加载的是**项目中的类以及通过maven引入的第三方jar包中的类。**

## ==2.6 双亲委派机制==
>**解决一个类到底是由谁加载的问题.**

### 2.6.1 介绍
双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会**自底向上查找是否加载过，再由顶向下进行加载**。![[Pasted image 20241030152830.png]]
>因为启动类加载器不可获得,所以扩展类加载器的父类为null
### 2.6.2 双亲委派机制的作用:
1. **保证类加载的安全性**。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。
	- 因此String类会在自底向上的查找过程中被找到,所以不会被覆盖.
2. **避免重复加载**。双亲委派机制可以避免同一个类被多次加载。

### 2.6.3 如何指定加载类的类加载器？
1. **方式1:** 使用Class.forName方法，使用当前类的类加载器去加载指定的类。
2. **方式2:** 获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。

```java
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();  
System.out.println(classLoader);  
  
Class<?> aClass = classLoader.loadClass("com.chanxin.my.B");  
Object o = aClass.newInstance();
```
通过`getClassLoader()`方法获取类加载器;
使用`loadClass()`方法加载类.

### 2.6.4 打破双亲委派机制
**共三种方法:**
1. **自定义类加载器并且重写loadClass方法**。Tomcat通过这种方式实现应用之间类隔离.
2. **线程上下文类加载器**。利用上下文类加载器加载类，比如JDBC和JNDI等。
3. ~~**Osgi框架的类加载器**。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。~~

#### 2.6.4.1 自定义类加载器^

##### ClassLoader的核心方法:
```Java
public Class<?> loadClass(String name)
类加载的入口，提供了双亲委派机制。内部会调用findClass   重要

protected Class<?> findClass(String name)
由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要

protected final Class<?> defineClass(String name, byte[] b, int off, int len)
做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中

protected final void resolveClass(Class<?> c)
执行类生命周期中的连接阶段
```
##### loadClass方法:


#### 2.6.4.2 线程上下文类加载器

#### 2.6.4.3 Osgi框架的类加载器

## 2.7 JDK9之后的类加载器
由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。
1. 启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。
   Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。
   启动类加载器**依然无法通过java代码获取**到，返回的仍然是null，保持了统一。

2. **扩展类加载器被替换成了平台类加载器**（Platform Class Loader）。
   平台类加载器遵循模块化方式加载字节码文件，所以**继承关系从URLClassLoader变成了BuiltinClassLoader**，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。


# 3. 运行时数据区
- Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。
- 线程不共享是指每个线程都独有一份,安全性较高,并且线程结束后内存会释放.
![[Pasted image 20241031084549.png]]

## 3.1 程序计数器
程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器**记录当前要执行的的字节码指令的内存地址**。
![[Pasted image 20241031084942.png]]
### 3.1.1 作用1:控制程序的指令的执行
1. 在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将==**原文件中的偏移量转换成内存地址**==。每一条字节码指令都会拥有一个内存地址。![[Pasted image 20241031085248.png]]
	- 左边的`0 1 2 3 ...`偏移量在加载后会被替换成实际的内存地址`0x...`.

2. 在代码执行过程中，程序计数器会==**记录下一行字节码指令的地址**==。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。

### 3.1.2 作用2:保存指令,恢复运行

在多线程执行情况下，Java虚拟机需要通过程序计数器**记录CPU切换前解释执行到哪一句指令**,以便于线程切换回来后继续解释运行.![[Pasted image 20241031085924.png]]

### 3.1.3 内存溢出可能性分析(不会)
>内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限。

由于每个线程**只存储一个固定长度的内存地址**，程序计数器是**==不会发生内存溢出==**的。程序员无需对程序计数器做任何处理。

## 3.2 Java虚拟机栈
Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理**方法调用中的基本数据**,每一个方法的调用使用一个栈帧（Stack Frame）来保存,方法执行结束后出栈.

**IDEA虚拟机栈**:
![[Pasted image 20241031090630.png]]

遇到"运行时异常"后,会将JVM栈中的栈帧**全部弹出**.
![[Pasted image 20241031090753.png]]

### 3.2.1 生命周期
Java虚拟机栈**随着线程的创建而创建(线程间不共享)**，而**回收则会在线程的销毁时进行**。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。

### 3.2.2 栈帧组成分析
Java虚拟机栈的栈帧中主要包含三方面的内容：
- 局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量
- 操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域
- 帧数据，帧数据主要包含动态链接、方法出口、异常表的引用

#### 3.2.2.1 局部变量表
- 局部变量表的作用是在**方法执行过程中存放所有的局部变量**。
- 局部变量表分为两种，一种是字节码文件中的，另外一种是栈帧中的也就是保存在内存中。
- 栈帧中的局部变量表是**根据字节码文件中的内容生成**的。

**字节码中的局部变量表:**![[Pasted image 20241031091826.png]]
- `Nr.`代表局部变量的序号,i是定义的第一个变量,所以序号为0,j定义在i后面,所以序号为1.
- `起始PC`代表变量生效的起始位置,例如i在`0,1`指令结束时才初始化完成,所以在`2`才生效.
- `长度`代表变量的生效范围,例如`4 return`指令结束后方法运行结束,所以i的生效长度为指令`2,3,4`,长度为3.
- `序号`表示该变量在栈帧局部变量表中的位置.



**栈帧中的局部变量表:**
![[Pasted image 20241031092300.png]]栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。


**实例方法:**![[Pasted image 20241031092527.png]]
- 对于实例方法,序号0存放的是this,指的是当前调用方法的对象,运行时会在内存中存放实例对象的地址.
- 方法参数也会保存在局部变量表中，其**顺序与方法中参数定义的顺序一致**。
- ==**局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。**==
![[Pasted image 20241031092637.png]]

**案例分析:**
以下代码的局部变量表占用几个槽?
```Java
public void test4(int k,int m){
    {
        int a = 1;
        int b = 2;
    }
    {
        int c = 1;
    }
    int i = 0;
    long j = 1;
}
```

占用槽数为**6**
![[Pasted image 20241031093329.png]]
为了节省空间，局部变量表中的槽是可以复用的，**一旦某个局部变量不再生效，当前槽就可以再次被使用。**

#### 3.2.2.2 操作数栈
- 操作数栈是栈帧中虚拟机在**执行指令过程中用来存放中间数据的一块区域**。
- 在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。
  ![[Pasted image 20241031094849.png]]
#### 3.2.2.3 帧数据
帧数据主要包含动态链接、方法出口、异常表的引用。

##### 动态链接:
当前类的字节码指令**引用了其他类的属性或者方法**时，需要**将符号引用（编号）转换成对应的运行时常量池中的内存地址**。动态链接就保存了符号引用到运行时常量池的内存地址的映射关系。
![[Pasted image 20241031095318.png]]
- 字节码中只保存了符号引用`#10`,需要通过动态链接来获取常量池中的内存地址.

##### 方法出口:
方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。![[Pasted image 20241031095632.png]]
- 例如,**sleep()方法中存放了study()方法下一行指令的地址**.

##### 异常表:
异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。
![[Pasted image 20241031095814.png]]
- `起始PC`和`结束PC`代表了异常捕获的范围,也就是try代码块的内容.
- `跳转PC`则是异常发生后需要跳转的指令地址.

### 3.2.3 栈内存溢出
- Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。
- 栈内存大小取决于操作系统.
- 可以使用`-XX:ThreadStackSize=1024`或`-Xss1024K`来设置栈内存大小.
- 局部变量过多、操作数栈深度过大也会影响栈内存的大小.

## 3.3 本地方法栈
- Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是**native本地方法**的栈帧。
- 在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上**使用了同一个栈空间**。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时**也把本地方法的栈信息打印出来**。![[Pasted image 20241031101645.png]]

## 3.4 堆内存
- 一般Java程序中堆内存是空间最大的一块内存区域. **==创建出来的对象都存在于堆上==**.
- 栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。
- 堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出OutOfMemory错误。

### 3.4.1 三个重要的值:
- 堆空间有三个需要关注的值，used、total、max。
	- used指的是当前已使用的堆内存;
	- total是java虚拟机**已经分配的可用堆内存**;
	- max是java虚拟机可以分配的最大堆内存。
- 当used逐渐增大,total可使用的内存即将不足时,JVM会继续分配内存给堆(total),total最大智能与max相同.

### 3.4.2 堆内存大小设置:
- 要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。
- 限制：Xmx必须大于 2 MB，Xms必须大于1MB

**建议**:
Java服务端程序开发时，**建议将-Xmx和-Xms设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，**减少了申请并分配内存时间上的开销**，同时也**不会出现内存过剩之后堆收缩**的情况。
## 3.5 方法区
方法区是存放基础信息的位置，线程共享,主要包含三部分内容：
- **类的元信息**，保存了所有类的基本信息
- **运行时常量池**，保存了字节码文件中的常量池内容
- **字符串常量池**，保存了字符串常量

### 3.5.1 类的元信息
方法区是用来存储**每个类的基本信息**（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了**类的字段、方法等字节码文件中的内容**，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。
![[Pasted image 20241031133807.png]]
### 3.5.2 运行时常量池
- 常量池中存放的是**字节码中的常量池内容**。
- 字节码文件中**通过编号查表**的方式找到常量，这种常量池称为静态常量池。
- 当常量池加载到内存中之后，可以**通过内存地址快速的定位到常量池中的内容**，这种常量池称为运行时常量池。

### 3.5.3 方法区的实现
方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同:
- JDK7及之前的版本将方法区**存放在堆区域中的永久代空间**，堆的大小由虚拟机参数来控制.
- JDK8及之后的版本将方法区存放在**元空间**中，元空间位于操作系统维护的直接内存中，默认情况下**只要不超过操作系统承受的上限，可以一直分配**。
	- 可以使用`-XX:MaxMetaspaceSize=256M`来对元空间最大大小进行限制，防止内存占用过高！
### 3.5.4 字符串常量池
- 字符串常量池存储在代码中定义的**常量字符串内容**。比如“123” 这个123就会被放入字符串常量池。
![[Pasted image 20241031134257.png]]
- "abc"会被放入字符串常量池中，并且new出来的对象s1会被放到堆内存中。
- 而s2并没有new新对象，所以他的引用就是字符串常量池中"abc"的地址。


#### StringTable的练习题1：
```Java
/**
 * 字符串常量池案例
 */
public class Demo2 {
    public static void main(String[] args) {
        String a = "1";
        String b = "2";
        String c = "12";
        String d = a + b;
        System.out.println(c == d);
    }
}
```

**字节码：**
```bash
 0 ldc #7 <1>     :将常量1放到操作数栈中
 2 astore_1       :将操作数栈的数据放到局部变量表1号位置
 3 ldc #9 <2>
 5 astore_2
 6 ldc #11 <12>
 8 astore_3
 9 new #13 <java/lang/StringBuilder>   :new了一个StringBuilder对象
12 dup
13 invokespecial #15 <java/lang/StringBuilder.<init> : ()V>
16 aload_1        :将局部变量表1号位置的元素放到操作数栈中
17 invokevirtual #16 <java/lang/StringBuilder.append :(Ljava/lang/String;)Ljava/lang/StringBuilder;>
20 aload_2        :将局部变量表2号位置的元素放到操作数栈中
21 invokevirtual #16 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>     :调用append()方法拼接
24 invokevirtual #20 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
27 astore 4       :将拼接后的对象存放到4号位置
```
- 根据字节码可看出，`String d = a + b;`实质上是new了一个StringBuilder对象，并且通过append方法连接。所以**局部变量d是指向了堆内存中的对象，而局部变量c指向的是字符串常量池中的“12”。**

#### StringTable的练习题2：
```Java
package chapter03.stringtable;

/**
 * 字符串常量池案例
 */
public class Demo3 {
    public static void main(String[] args) {
        String a = "1";
        String b = "2";
        String c = "12";
        String d = "1" + "2";
        System.out.println(c == d);
    }
}
```
字节码：
```bash hl:7
 0 ldc #7 <1>
 2 astore_1
 3 ldc #9 <2>
 5 astore_2
 6 ldc #11 <12>
 8 astore_3
 9 ldc #11 <12>
11 astore 4
```
- 可以看到，`String d = "1" + "2";`实质上是将“12”从字符串常量池中取出放到操作数栈中，然后再存放到局部变量表的四号位置，所以**对象c和对象d的引用都是指向字符串常量池中的“12”！**

#### intern()方法:
String.intern()方法是可以**手动将字符串放入字符串常量池**中。
- 在JDK6之前，是将**字面量**放入到字符串常量池中；
- 在JDK7及以后，是将**堆上字符串的引用**放入字符串常量池。

## 3.6 直接内存
- 直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。
- 在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:
	1. Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。
	2. IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。
- 现在直接放入直接内存即可，同时**Java堆上维护直接内存的引用，减少了数据复制的开销**。写文件也是类似的思路。![[Pasted image 20241031142632.png]]
- 可以通过`-XX:MaxDirectMemorySize=1m`来设置直接内存大小。

# 4. 垃圾回收
- Java中为了**简化对象的释放**，引入了自动的垃圾回收（Garbage Collection简称GC）机制。通过垃圾回收器来**对不再使用的对象完成自动的回收**，垃圾回收器主要负责**对堆上的内存进行回收**。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器。
- 自动垃圾回收与手动垃圾回收对比：![[Pasted image 20241031144003.png]]
- 线程不共享的部分，都是**伴随着线程的创建而创建，线程的销毁而销毁**。而**方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存**。所以这一部分不需要垃圾回收器负责回收。

## 4.1 方法区的回收
方法区中能回收的内容主要就是**不再使用的类**，需要满足以下三个条件：
1. 此类所有实例对象都已经被回收，在堆中不存在任何该类的**实例对象以及子类对象**。
2. 加载该类的类加载器已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用。

可以使用`-XX:+TraceClassLoading -XX:+TraceClassUnloading`打印类加载日志，判断是否被回收。

## 4.2 如何判断对象可以回收
Java中的对象是否能被回收，**是根据对象是否被引用来决定的**。如果对象被引用了，说明该对象还在使用，不允许被回收。

例如：
![[Pasted image 20241031151916.png]]
要想让堆上A的实例对象被回收，就要切断所有引用：![[Pasted image 20241031152133.png]]
```java
b1.A = null;
a1 = null;
```

若执行`a1 = null;b1=null;`，则堆内存中的两个对象都会被回收，因为**在代码中已经无法访问这两个对象**了，即使他们之间有相互引用，也不影响对象的回收。
![[Pasted image 20241031152330.png]]

### 4.2.1 引用计数法
>**C++的智能指针就采用引用计数法。**

引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。
![[Pasted image 20241031152447.png]]

**缺点：**
1. 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响。
2. 存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。（堆内存中的对象相互引用）![[Pasted image 20241031152631.png]]

### 4.2.2 可达性分析算法
- Java使用的是可达性分析算法来判断对象是否可以被回收。
- 可达性分析将对象分为两类：**垃圾回收的根对象（GC Root）和普通对象**，对象与对象之间存在引用关系。
- 可达性分析算法指的是**如果从某个到GC Root对象是可达的，对象就不可被回收。**
	- A到B再到C和D，形成了引用链，所以BCD都不会被回收。 ![[Pasted image 20241031153031.png]]
- 四类GC Root对象：
	1. 线程Thread对象，引用线程栈帧中的方法参数、局部变量等。
	2. 系统类加载器加载的java.lang.Class对象
	3. 监视器对象，用来保存同步锁synchronized关键字持有的对象。
	4. 本地方法调用时使用的全局对象。
 
## 4.3 常见引用对象
可达性算法中描述的对象引用，一般指的是**强引用，即是GCRoot对象对普通对象有引用关系**，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：
- 软引用
- 弱引用
- 虚引用
- 终结器引用

### 4.3.1 软引用 ^
- 软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。
- 在JDK 1.2版之后提供了SoftReference类来实现软引用，**软引用常用于缓存中。**
![[Pasted image 20241031163839.png]]
- 当内存够用时，软引用对象暂时不会被回收。

#### 4.3.1.1 软引用的使用方法
软引用的执行过程如下：
1. 将对象使用软引用包装起来，`new SoftReference<对象类型>(对象)`。
2. 内存不足时，虚拟机尝试进行垃圾回收。
3. 如果**垃圾回收仍不能解决内存不足的问题，回收软引用中的对象**。
4. 如果依然内存不足，抛出OutOfMemory异常。

使用软引用包装对象：
```java
byte[] bytes = new byte[1024 * 1024 * 100];
SoftReference<byte[]> softReference = new SoftReference<byte[]>(bytes);
```


### 4.3.2 弱引用
弱引用的整体机制和软引用基本一致，区别在于**弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收**。在JDK 1.2版之后提供了`WeakReference类`来实现弱引用，**弱引用主要在ThreadLocal中使用。**

### 4.3.3 虚引用和终结器引用
这两种引用**在常规开发中是不会使用的**。
- 虚引用也叫幽灵引用/幻影引用，**不能通过虚引用对象获取到包含的对象**。虚引用唯一的用途是**当对象被垃圾回收器回收时可以接收到对应的通知**。Java中使用PhantomReference实现了虚引用。
	- **直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。**

- 终结器引用指的是在对象需要被回收时，**终结器引用会关联对象并放置在Finalizer类中的引用队列中**，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，**在对象第二次被回收时，该对象才真正的被回收**。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。

## 4.4 垃圾回收算法
>**找到内存中存活的对象，释放不再存活对象的内存，使得程序能再次利用这部分空间。**

### 4.4.1 垃圾回收算法的分类
主要分为四大类：![[Pasted image 20241031211219.png]]

### 4.4.2 垃圾回收算法的评价标准
- Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会**有部分阶段需要停止所有的用户线程**。停止的过程被称为Stop The World，简称STW。
- 用户代码执行和垃圾回收执行让用户线程停止执行（STW）是**交替执行**的。
![[Pasted image 20241031205932.png]]
#### 评价标准1：吞吐量
吞吐量指的是 **CPU 用于执行用户代码的时间与 CPU 总执行时间的比值**，即`吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）`。吞吐量数值越高，垃圾回收的效率就越高。
![[Pasted image 20241031210640.png]]
#### 评价标准2：最大暂停时间
最大暂停时间指的是所有在垃圾回收过程中的**STW时间最大值**。最大暂停时间越短，用户使用系统时受到的影响就越短。
- 上图具有更小的最大暂停时间
![[Pasted image 20241031210705.png]]
#### 评价标准3：堆使用效率
不同垃圾回收算法，**对堆内存的使用方式**是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。
- 从堆使用效率上来说，标记清除算法要优于复制算法。
![[Pasted image 20241031210832.png]]

#### 综合评价：
三种评价标准不可兼得。例如堆内存越大，则需要回收的对象可能就越多，STW就会越长。而若想降低最大暂停时间，则吞吐量可能就会减小（需要少量多次）。

### 4.4.3 标记清除算法
标记清除算法的核心思想分为两个阶段：
1. 标记阶段，将所有存活的对象进行标记。Java中使用**可达性分析算法**，从GC Root开始通过引用链**遍历出所有存活对象**。
2. 清除阶段，从内存中删除没有被标记也就是非存活对象。

**优点：**
1. 实现简单，只需要第一阶段给每个对象维护“是否存活”的标记位，然后在第二阶段清除非存活对象即可。

**缺点：**
1. 碎片化问题。由于内存是连续的，而对象被删除后，内存中会**出现很多细小可用的内存单元**，如果此时需要一片较大的内存空间，可能无法实现。![[Pasted image 20241031211556.png]]
2. 分配速度比较慢。由于内存碎片的存在，所以JVM需要在内存中维护一个链表，用来记录细小可用的内存单元。所以需要遍历链表才能找到可用的内存空间。
   - 需要遍历到第三个可用区域才能成功分配空间。![[Pasted image 20241031211701.png]]
### 4.4.4 复制算法
复制算法的核心思想是：
1. 在堆内存准备两块空间From空间和To空间，每次在**对象分配阶段，只能使用From空间。**
2. 在垃圾回收GC阶段，**将From中存活对象复制到To空间**，并清除From空间。
3. 将From空间和To空间的名字互换。

优点：
- 吞吐量高，复制算法**只需要遍历一次存活对象**复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为**标记清除算法不需要进行对象的移动**
- 不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

缺点：
**内存使用效率低**，每次只能让一半的内存空间来为创建对象使用。


### 4.4.5 标记整理算法
标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。相当于在标记清除算法的基础上将内存碎片整合了。

核心思想分为两个阶段：
1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
2. **整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。**

**优点：**
- **内存使用效率高**，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
- **不会发生碎片化**，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

**缺点：**
**整理阶段的效率不高**，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能。

### ==4.4.6 分代垃圾回收算法==
现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是**分代垃圾回收算法**(Generational GC)。

分代垃圾回收将整个内存区域划分为年轻代和老年代：![[Pasted image 20241031220333.png]]

执行流程：
1. 分代回收时，创建出来的对象，首先会被**放入Eden伊甸园区**。
   ![[Pasted image 20241031222839.png]]
2. 随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会**触发年轻代的GC**，称为Minor GC或者Young GC。
   Minor GC会把eden区和From区需要回收的对象回收，把没有回收的对象放入To区。
   （使用复制算法）
3. 接下来，From区和To区名称互换。当eden区满时再往里放入对象，依然会发生Minor GC。
  ![[Pasted image 20241031223141.png]] 注意：每次Minor GC中都会**为对象记录他的年龄，初始值为0，每次GC完加1**。![[Pasted image 20241031223334.png]]
4. 如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被**晋升至老年代**。![[Pasted image 20241031223407.png]]
当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，**Full GC会对整个堆进行垃圾回收**。
	minor GC 会清理新生代中存活时间较短的对象，这可能会**减少需要晋升到老年代的对象数量，进而减缓老年代的压力**。
	**Full GC** 会回收整个堆，包括新生代、老年代和永久代

如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。![[Pasted image 20241031223757.png]]

## 4.5 垃圾回收器
为什么分代GC算法要把堆分成年轻代和老年代?
- 系统中的大部分对象，都是创建出来之后**很快就不再使用可以被回收**，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。
- 老年代中会**存放长期存活的对象**，比如Spring的**大部分bean对象**，在程序启动之后就不会被回收了。
- 在虚拟机的默认设置中，新生代大小要**远小于**老年代的大小。
	- 可以看到，新生代是314560K，而老年代是699072K。![[Pasted image 20241101134310.png]]

分代GC算法将堆分成年轻代和老年代主要原因有：
1. 可以通过**调整年轻代和老年代的比例来适应不同类型的应用程序**，提高内存的利用率和性能。
	- 例如当有大量用户访问订单数据，此时应该适当提高新生代内存比例。
2. 新生代和老年代使用不同的垃圾回收算法，**新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法**，由程序员来选择灵活度较高。
	- 这样新生代不会出现内存碎片，且吞吐量更高；而老年代空间较大，若使用复制算法，则会浪费很大空间！
3. 分代的设计中允许**只回收新生代（minor gc）**，如果能满足对象分配的要求就**不需要对整个堆进行回收(full gc)**,STW时间就会减少。

垃圾回收器是垃圾回收算法的具体实现。由于垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。![[Pasted image 20241101134813.png]]
### 4.5.1 年轻代-Serial垃圾回收器
Serial是一种**单线程串行回收年轻代**的垃圾回收器。

- 由于是单线程，所以进行GC时，其他用户线程会被阻塞。
![[Pasted image 20241101135023.png]]

**回收年代和算法：**
- 年轻代
- 复制算法

**优点：**
- 单CPU处理器下吞吐量非常出色

**缺点：**
- 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**：
- Java编写的客户端程序或者硬件配置有限的场景

### 4.5.2 老年代-SerialOld垃圾回收器
SerialOld是Serial垃圾回收器的**老年代版本**，采用**单线程串行回收**。![[Pasted image 20241101135453 1.png]]
**回收年代和算法：**
- 老年代
- 标记-整理算法

**优点：**
- 单CPU处理器下吞吐量非常出色
**缺点：**
- 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**
- 与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用


### 4.5.3 年轻代-ParNew垃圾回收器
ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用**多线程进行垃圾回收**。
- 相较于Serial，使用多线程进行回收，阻塞时间较短。
![[Pasted image 20241101140144.png]]
**回收年代和算法：**
- 年轻代
- 复制算法

**优点：**
- 多CPU处理器下**停顿时间较短**
**缺点：**
- 吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用

**适用场景：**
 - JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用

### 4.5.4 老年代- CMS(Concurrent Mark Sweep)垃圾回收器
CMS垃圾回收器关注的是系统的暂停时间，**允许用户线程和垃圾回收线程在某些步骤中同时执行**，减少了用户线程的等待时间。
- 在**并发标记与并发清理**阶段，用户线程与GC线程同时执行，减少了等待时间。
![[Pasted image 20241101140505.png]]**回收年代和算法：**
- 老年代
- 标记清除算法

**优点**
- 系统由于垃圾回收出现的停顿时间较短，用户体验好
**缺点**
1. 内存碎片问题
2. 退化问题，某些阶段依然会退化成单线程GC。
3. 浮动垃圾问题

**适用场景**
- 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等

#### 4.5.4.1 CMS执行步骤：
1. 初始标记，用极短的时间标记出GC Roots能直接关联到的对象。
2. 并发标记, 标记所有的对象（是否需要回收），用户线程不需要暂停。
3. 重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。（相当于二次确认）
4. 并发清理，清理死亡的对象，用户线程不需要暂停。![[Pasted image 20241101140505.png]]

**缺点：**
1. CMS使用了标记-清除算法，在垃圾收集结束之后会**出现大量的内存碎片**，CMS会在**Full GC时进行碎片的整理**，这样会导致用户线程暂停。
	- 可以使用`-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）`调整N次Full GC之后再整理。
2. 无法处理在**并发清理过程**中产生的“浮动垃圾”，不能做到完全的垃圾回收。
3. 如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

### 4.5.5 年轻代-Parallel Scavenge垃圾回收器
Parallel Scavenge是**JDK8默认**的年轻代垃圾回收器，**多线程并行回收**，关注的是系统的吞吐量，具备**自动调整堆内存大小**的特点。![[Pasted image 20241101141510.png]]
**回收年代和算法：**
年轻代
复制算法

**优点**
- 吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数
**缺点**
- 不能保证单次的停顿时间

**适用场景**
- 后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出

### 4.5.6 老年代-Parallel Old垃圾回收器
Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。

**回收年代和算法：**
- 老年代
- 标记-整理算法

**优点**
- 并发收集，在多核CPU下效率较高
**缺点**
- 暂停时间会比较长

**适用场景**
- 与Parallel Scavenge配套使用

### 4.5.7 G1垃圾回收器
JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。
Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。CMS关注暂停时间，但是吞吐量方面会下降。

而G1设计目标就是将上述两种垃圾回收器的优点融合：
1. **支持巨大的堆空间回收，并有较高的吞吐量。**
2. **支持多CPU并行垃圾回收。**
3. **允许用户设置最大暂停时间。**

**回收年代和算法：**
- 年轻代+老年代
- 复制算法
**优点**
- 对比较大的堆如超过6G的堆回收时，延迟可控
- 不会产生内存碎片
- 并发标记的SATB算法效率高
**缺点**
- JDK8之前还不够成熟

**适用场景**
- JDK8最新版本、JDK9之后建议默认使用
#### 4.5.7.1 内存结构:
G1的整个堆会被**划分成多个大小相等的区域**，称之为区Region，区域**不要求是连续的**。分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数`-XX:G1HeapRegionSize=32m`指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。
![[Pasted image 20241101144056.png]]
#### 4.5.7.2 执行流程
1. 新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。
2. 标记出Eden和Survivor区域中的存活对象。
3. 根据配置的最大暂停时间 ==**选择某些区域==将存活对象复制到一个新的Survivor区**中（年龄+1），清空这些区域。
   ![[Pasted image 20241101144533.png]]
	- **回收依据：** G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的**平均耗时**，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。
4. 后续Young GC时与之前相同，只不过**Survivor区中存活对象会被搬运到另一个Survivor区。**
5. 当某个存活对象的年龄到达阈值（默认15），将被放入老年代。
   ![[Pasted image 20241101144928.png|300]]
6. 部分对象如果**大小超过Region的一半，会直接放入老年代**，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果**对象过大会横跨多个Region**。
   ![[Pasted image 20241101145001.png|300]]
7. 多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时
（-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收**MixedGC**：**回收所有年轻代和部分老年代的对象以及大对象区。** 采用复制算法来完成。

#### 4.5.7.3 年轻代回收：
年轻代回收（Young GC），回收**Eden区和Survivor区**中不用的对象。

#### 4.5.7.4 混合回收
- 混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）。
  ![[Pasted image 20241101145257.png]]
- G1对老年代的清理会**选择存活度最低的区域**来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。最后清理阶段**使用复制算法，不会产生内存碎片**。
![[Pasted image 20241101145456.png]]
- 如果清理过程中发现没有足够多的空Region存放转移对象，就会出现Full GC，单线程执行标记-整理算法，会导致用户线程的暂停。
  ![[Pasted image 20241101145655.png|300]]

