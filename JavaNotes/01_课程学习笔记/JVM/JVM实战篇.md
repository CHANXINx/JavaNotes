# 1. 内存调优
## 1.1 内存泄漏和内存溢出
**内存泄漏（memory leak）**：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏。
- 持续的内存泄露会导致内存溢出。
### 1.1.1 内存泄漏的常见场景：
1. 内存泄漏导致溢出的常见场景是大型的Java后端应用中，在**处理用户的请求之后，没有及时将用户的数据删除**。随着用户请求数量越来越多，内存泄漏的对象占满了堆内存最终导致内存溢出。
	- 例如使用Map存储用户缓存，但是没有删除。
2. 第二种常见场景是分布式任务调度系统如Elastic-job、Quartz等进行任务调度时，**被调度的Java应用在调度任务结束中出现了内存泄漏，最终导致多次调度之后内存溢出**。

## 1.2 解决内存溢出的方法
![[Pasted image 20241101152330.png]]
### 1.2.1 常用监控工具
#### top命令:
- 通过top命令可在linux下实时查看系统资源，比如执行时的进程、线程和系统参数等信息。
- 进程使用的内存为`RES常驻内存-SHR共享内存`![[Pasted image 20241101153341.png|450]]

**优点：**
- 操作简单
- 无额外的软件安装
**缺点：**
只能查看最基础的进程信息，无法查看到每个部分的内存占用（堆、方法区、堆外） 
#### VisualVM:
VisualVM是多功能合一的Java故障排除工具并且他是一款可视化工具，整合了命令行 JDK 工具和轻量级分析功能。

**优点：**
- 功能丰富，实时监控CPU、内存、线程等详细信息
- 支持Idea插件，开发过程中也可以使用
**缺点：**
- 对大量集群化部署的Java进程需要手动进行管理，例如Peform GC，Heap Dump
#### Arthas
Arthas 是一款线上监控诊断产品，通过**全局视角实时查看应用 load、内存、gc、线程的状态信息**，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。

优点：
- 功能强大，不止于监控基础的信息，还能监控单个方法的执行耗时等细节内容。
- 支持应用的集群管理
缺点：
- 部分高级功能使用门槛较高

#### Prometheus+Grafana
- 支持系统级别和应用级别的监控，比如linux操作系统、Redis、MySQL、Java进程。
- 支持告警并允许自定义告警指标，通过邮件、短信等方式尽早通知相关人员进行处理

### 1.2.2 堆内存状况对比
#### 正常情况:
  - 处理业务时会出现**上下起伏**，业务对象频繁创建内存会升高，**触发MinorGC之后内存会降下来**。
  - 手动执行FULL GC之后，内存大小会骤降，而且每次降完之后的大小是接近的。
  - 长时间观察内存曲线应该是在一个范围内。
    ![[Pasted image 20241101161816.png|200]]

#### 内存泄漏:
- 处于持续增长的情况，即使Minor GC也不能把大部分对象回收(**内存泄漏对象不会被回收**)
- 手动FULL GC之后的内存量每一次都在增长
- 长时间观察内存曲线持续增长
  ![[Pasted image 20241101161801.png|200]]
### 1.2.3 产生内存溢出原因一 ：代码中的内存泄漏
- equals()和hashCode()，不正确的equals()和hashCode()实现导致内存泄漏
- 内部类引用外部类，非静态的内部类和匿名内部类的错误使用导致内存泄漏
- ThreadLocal的使用，由于线程池中的线程不被回收导致的ThreadLocal内存泄漏
- String的intern方法，由于JDK6中的字符串常量池位于永久代，intern被大量调用并保存产生的内存泄漏
- 通过静态字段保存对象，大量的数据在静态变量中被引用，但是不再使用，成为了内存泄漏
- 资源没有正常关闭，由于资源没有调用close方法正常关闭，导致的内存溢出


#### 1.2.3.1 equals()和hashCode()
hashCode方法实现不正确，会导致相同id的学生对象计算出来的hash值不同，可能会被分到不同的槽中。
equals方法实现不正确，会导致key在比对时，即便学生对象的id是相同的，也被认为是不同的key。

#### 1.2.3.2 内部类引用外部类
1. **非静态的内部类默认会持有外部类**，尽管代码上不再使用外部类，所以如果有地方引用了这个非静态内部类，会导致外部类也被引用，垃圾回收时无法回收这个外部类。
- **解决办法:**
	- 使用静态内部类.

2. 匿名内部类对象如果在非静态方法中被创建，会**持有调用者对象**，垃圾回收时无法回收调用者。

### 1.2.5 诊断
#### 1.2.5.1 内存快照
- 当堆内存溢出时，需要在堆内存溢出时将整个堆内存保存下来，生成内存快照(Heap Profile )文件。
- 使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源。

#### 1.2.5.2 MAT内存泄漏检测的原理
MAT提供了称为支配树（Dominator Tree）的对象图。支配树展示的是**对象实例间的支配关系**。在对象引用图中，**所有指向对象B的路径都经过对象A，则认为对象A支配对象B。**
![[Pasted image 20241101234242.png]]
- 支配树中对象本身占用的空间称之为浅堆(Shallow Heap）。
- 支配树中对象的子树就是所有被该对象支配的内容，这些内容组成了对象的深堆（Retained Heap），也称之为保留集（ Retained Set .
	- 深堆的大小表示该对象如果可以被回收，能释放多大的内存空间。![[Pasted image 20241102085246.png|450]]
- MAT就是根据支配树，从叶子节点向根节点遍历，如果发现**深堆的大小超过整个堆内存的一定比例阈值，就会将其标记成内存泄漏的“嫌疑对象”**。

#### 案例1-ThreadLocal使用时占用大量内存
**原因:**
- 使用拦截器解析请求头数据,并放入ThreadLocal. 在拦截器中，ThreadLocal清理的代码被**错误地放在postHandle**中，如果接口发生了异常(例如Controller层发生异常)，这段代码不会调用到，这样就产生了内存泄漏.

**解决方案:**
- 将ThreadLocal中的清理操作放在afterCompletion中.
#### 案例2-导出大文件内存溢出
**原因:**
- Excel文件导出如果使用POI的XSSFWorkbook，在大数据量（几十万）的情况下会占用大量的内存。
**解决方案:**
- 使用poi的SXSSFWorkbook(XSSFWorkbook的优化版本)
- hutool提供的BigExcelWriter减少内存开销。
- 使用easy excel，对内存进行了大量的优化。
	- 通过分批导出的方式进行优化，但是耗时会比较长。

#### 案例3-文章内容审核接口的内存问题^^^
**原因:**
- 在项目中如果要使用异步进行业务处理，或者实现`生产者 – 消费者`的模型，如果在Java代码中实现，会**占用大量的内存去保存中间数据**。

**方法1:使用@Async注解异步审核:**![[Pasted image 20241102100825.png]]
1. 线程池参数设置不当，会导致**大量线程的创建或者队列中保存大量的数据**。
2. 任务没有持久化，一旦走线程池的拒绝策略或者服务宕机、服务器掉电等情况很有可能会丢失任务。
**方法2:使用生产者-消费者模式处理:**![[Pasted image 20241102100818.png]]
1. 可以将任务持久化到数据库中.
2. 队列参数设置不正确，会保存大量的数据。
3. 实现复杂，需要自行实现持久化的机制，否则数据会丢失。

**解决方案-使用mq消息队列**![[Pasted image 20241102100903.png]]
- 使用mq消息队列进行处理，由mq来保存文章的数据。发送消息的服务和拉取消息的服务可以是同一个，也可以不是同一个。
- 使用Mq消息队列，可以很好地**将中间数据单独进行保存**，不会占用Java的内存。同时也可以将生产者和消费者拆分成不同的微服务。
# 2. GC调优
GC调优指的是对垃圾回收（Garbage Collection）进行调优。GC调优的主要目标是**避免由垃圾回收引起程序性能下降**。

GC调优的核心分成三部分：
1. 通用Jvm参数的设置。
2. 特定垃圾回收器的Jvm参数的设置。
3. 解决由频繁的FULLGC引起的程序性能问题。

## 2.1 GC调优的核心指标
>**三个核心指标: 1)吞吐量; 2)延迟; 3)内存使用量**
### 2.1.1 垃圾回收吞吐量
- 垃圾回收吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即`吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）`。
- 吞吐量数值越高，垃圾回收的效率就越高，允许更多的CPU时间去处理用户的业务，相应的业务吞吐量也就越高。
### 2.1.2 延迟
- 延迟指的是从用户发起一个请求到收到响应这其中经历的时间。
- `延迟 = GC延迟 + 业务执行时间`，所以如果GC时间过长，会影响到用户的使用。
	- 延迟为6秒!![[Pasted image 20241102101859.png]]
### 2.1.3 内存使用量
- 内存使用量指的是**Java应用占用系统内存的最大值**，一般通过Jvm参数调整，在满足上述两个指标的前提下，这个值越小越好。
## 2.2 GC调优步骤
![[Pasted image 20241102102120.png]]

### 2.2.2 常见的GC模式

#### 2.2.2.1 正常情况
特点：呈现**锯齿状**，对象创建之后内存上升，一旦发生垃圾回收之后下降到底部，并且每次下降之后的内存大小接近，存留的对象较少。
![[Pasted image 20241102103620.png]]

#### 2.2.2.2 缓存对象过多
呈现锯齿状，对象创建之后内存上升，一旦发生垃圾回收之后下降到底部，并且**每次下降之后的内存大小接近，处于比较高的位置**。

**问题产生原因：**
- 程序中**保存了大量的缓存对象**，导致GC之后无法释放。
![[Pasted image 20241102103738.png]]

#### 2.2.2.3 内存泄漏
呈现锯齿状，每次垃圾回收之后下降到的内存位置越来越高，最后由于垃圾回收无法释放空间导致对象无法分配产生OutOfMemory的错误。

**问题产生原因：**
- 程序中**保存了大量的内存泄漏对象，导致GC之后无法释放**。
![[Pasted image 20241102103903.png]]
#### 2.2.2.4 持续的FullGC
在**某个时间点产生多次Full GC**，CPU使用率同时飙高，**用户请求基本无法处理**。一段时间之后恢复正常。

**问题产生原因：**
- 在该时间范围请求量激增，程序开始生成更多对象，同时**垃圾收集无法跟上对象创建速率**，导致持续地在进行FULL GC。
![[Pasted image 20241102104023.png]]

#### 2.2.2.5 元空间不足导致的FULLGC
堆内存的大小并不是特别大，但是持续发生FULLGC。

**问题产生原因：**
- 元空间大小不足，导致持续FULLGC回收元空间的数据。
	- 元空间并不是满了才触发FULLGC，而是JVM自动会计算一个阈值，进行FullGC。


### 2.2.3 解决GC问题的手段
- 优化基础JVM参数，基础JVM参数的设置不当，会导致频繁FULLGC的产生
- 减少对象产生，大多数场景下的FULLGC是由于对象产生速度过快导致的，减少对象产生可以有效的缓解FULLGC的发生
- 更换垃圾回收器，选择适合当前业务场景的垃圾回收器，减少延迟、提高吞吐量
- 优化垃圾回收器参数，优化垃圾回收器的参数，能在一定程度上提升GC效率

#### 2.2.3.1 优化基础JVM参数
##### 参数1：-Xmx和-Xms
- -Xmx参数设置的是**最大堆内存**，但是由于程序是运行在服务器或者容器上，计算可用内存时，要将元空间、操作系统、其它软件占用的内存排除掉。
	- 服务器内存分配：![[Pasted image 20241102140201.png]]
- -Xms用来设置**初始堆大小**，建议将-Xms设置的和-Xmx一样大
	1. 可以避免频繁扩容造成的性能下降；
	2. 避免扩容时其他程序正在使用大量内存，容易因为内存不足而分配失败；
	3. 启动速度快。如果初始堆太小，Java 应用程序启动会变得很慢，因为 JVM 被迫频繁执行垃圾收集，直到堆增长到更合理的大小。

##### 参数2：-XX:MaxMetaspaceSize 和 –XX:MetaspaceSize
- -XX:MaxMetaspaceSize指的是最大元空间大小。默认值比较大，如果出现**元空间内存泄漏会让操作系统可用内存不可控**，建议根据测试情况设置最大值，一般设置为256m。
- -XX:MetaspaceSize指的是到达这个值之后会触发FULLGC。后续的Full GC阈值，JVM会自行计算。若Meta设置的与Max一样大，则不会进行Full GC，同时也会导致对象无法回收。![[Pasted image 20241102140952.png]]
##### 参数3：-Xss虚拟机栈大小
JVM 将创建一个具有默认大小的栈。
##### 参数4 ： 不建议手动设置的参数
1. **-Xmn 年轻代的大小**：默认值为整个堆的1/3，可以根据峰值流量计算最大的年轻代大小，尽量让对象只存放在年轻代，不进入老年代。调整时需要进行大量测试。并且G1回收器建议不设置该值，会动态调整。
2. **‐XX:SurvivorRatio 伊甸园区和幸存者区的大小比例**：默认值为8。
3. **‐XX:MaxTenuringThreshold 最大晋升阈值**，年龄大于此值之后，会进入老年代。另外JVM有动态年龄判断机制：将年龄从小到大的对象占据的空间加起来，如果大于survivor区域的50%，然后把等于或大于该年龄的对象，放入到老年代。
##### 参数模板：
```Java
-Xms1g
-Xmx1g
-Xss256k
-XX:MaxMetaspaceSize=512m 
-XX:+DisableExplicitGC-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/opt/logs/my-service.hprof-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-Xloggc:文件路径
```
#### 2.2.3.2 垃圾回收器的选择
JDK11之后使用G1垃圾回收器！

### 案例实战总结：
1. 压力比较大的服务中，尽量不要存放大量的缓存或者定时任务，会影响到服务的内存使用。
2. 内存分析发现有大量线程创建时，可以使用**导出线程栈**来查看线程的运行情况。
3. 如果请求确实创建了大量的内存超过了内存上限，只能考虑减少请求时创建的对象，或者使用更大的内存。
4. 推荐使用g1垃圾回收器，并且使用较新的JDK可以获得更好的性能。
# 3. 性能调优
![[Pasted image 20241102181248.png]]
## 3.1 性能调优解决的问题
1. CPU占用率高。CPU占用率过高（多核情况下可能超过100%），可能是陷入了循环导致。
2. 请求单个服务处理时间过长。
3. 程序启动之后运行正常，但是在运行一段时间之后无法处理任何的请求。
## 3.2 性能调优的方法
### 3.2.1 线程转储
线程转储（Thread Dump）提供了**对所有运行中的线程当前状态的快照**。线程转储可以通过jstack、visualvm等工具获取。其中包含了线程名、优先级、线程ID、线程状态、线程栈信息等等内容，可以**用来解决CPU占用率高、死锁等问题**。

**转储文件核心内容：**
- 名称： 线程名称，通过给线程设置合适的名称更容易“见名知意”
- 优先级（prio）：线程的优先级
- Java ID（tid）：JVM中线程的唯一ID
- 本地 ID (nid)：操作系统分配给线程的唯一ID
- 状态：线程的状态，分为：
	- NEW – 新创建的线程，尚未开始执行
	- RUNNABLE –正在运行或准备执行
	- BLOCKED – 等待获取监视器锁以进入或重新进入同步块/方法
	- WAITING – 等待其他线程执行特定操作，没有时间限制
	- TIMED_WAITING – 等待其他线程在指定时间内执行特定操作
	- TERMINATED – 已完成执行
## 3.3 案例实战
### 案例1：定位偏底层的性能问题
**问题：**
有一个接口中使用了for循环向ArrayList中添加数据，但是最终发现执行时间比较长，需要定位是由于什么原因导致的性能低下。
## 3.4 JMH基准测试框架
Java程序在运行过程中，**JIT即时编译器会实时对代码进行性能优化，所以仅凭少量的测试是无法真实反应运行系统最终给用户提供的性能。**

**使用MVN模板创建JMH框架：**
```Shell
mvn archetype:generate "-DinteractiveMode=false" "-DarchetypeGroupId=org.openjdk.jmh" "-DarchetypeArtifactId=jmh-java-benchmark-archetype" "-DgroupId=com.chanxin" "-DartifactId=test" "-Dversion=1.0"
```

**死代码问题：**
- JIT将不用的代码直接删除。

**黑洞的用法：**
- 当存在多个变量时，为了避免JIT即时编译器忽略，可以在形参处添加Blackhole。
```
void test(Blackhole bh){
	...
	bh.consume(i);
	bh.consume(j);
}
```

**案例：测试LocalDateTime和SimpleDateFormat**