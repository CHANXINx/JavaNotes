# Day01:（3月23日）
 时长及内容：
- 3.5h左右；
- 尚硅谷视频01~13；
## 学习复盘
### 1. 简单的cmd：
- `cd`：change dir，切换根目录。`cd E:\`可切换至其他目录；`cd /dE:\`可强制切换至其他目录，适用于切换目录后无反应的情况（或者可在输入切换目录命令后再输入`E:`；
- `md`：make dir，创建目录。
- `rd`：remove dir，移除目录。移除文件夹，但是不能移除包含其他文件/文件夹的目录。要删除这种目录得用到`del`命令。
### 2. 环境变量：
- 要想在任何盘符目录中都可以运行`java xxx.class`or`javac xxx.java`，就必须添加环境变量。
- 环境变量的位置至关重要，若jdk1.8的环境变量在jdk17.0的环境变量上面，则会先运行jdk1.8，因为对环境变量的检索是由上至下的。
- 定义环境变量的方法可以是直接在PATH中添加bin文件夹目录；也可以是定义`JAVA_HOME=···`，然后在PATH中添加`%JAVA_HOME\bin%`，这样可以避免在后面的学习中出错。
### 3. Java程序的编写：
①编写代码。创建`.java`源文件文件，内含代码；
②编译。`javac xxx.java`可将源文件编译生成`.class`的类文件（类文件的名称跟代码块里定义的类名相同；
③运行。`java xxx.class`即运行类文件。

# Day02：（3月24日）
## 时长及内容：
- 15mins
- 尚硅谷视频14；

## 学习复盘：
### 1. 代码规范：
- `System.out.println`中，大小写要规范。其中`println`表示打印后换行，若不想换行，则可去掉`ln`。
- `Public static void main(String[] args)`，可将其中的参数/变量名字更换，即`args`可替换成`a`也无所谓。args为arguments的缩写。同时，方括号也可加在args后面。

# Day03：（3月25日）
## 时长与内容：
- 约2.5h
- 尚硅谷视频15~21；

## 学习复盘：
### 1. 关于内存：
- Java区别于C++，有自动的内存释放机制。但是Java也会有内存溢出和内存泄露的问题！
	- **内存溢出：** 当程序所需内存大于JVM内存，此时就会发生内存溢出。
	- **内存泄露：** 内存需要释放，被清除时，但因为某些原因未被释放机制看作垃圾清楚，因此会发生内存泄漏。

# Day04：（3月26日）
## 时长与内容：
- 约3.5h
- 尚硅谷视频21~35
## 学习复盘：
### 1. 关键字与标识符：
- **关键字：** 诸如`class`、`public`、`void`、`static`等都可算作关键字，这类字符都已被占用，不可定义使用。
- **标识符**：变量、方法、类等要素命名使用的字符序列，都可称作标识符。标识符定义的规则如下：
	- 由大小写字母，数字以及_$组成；
	- 不可以数字开头；
	- 严格区分大小写；
	- 不能包含空格；
### 2. 变量：
- 变量包含三个要素：数据类型、变量名、数值。
- **基本数据类型**：包括8种数据类型：**整数型：** `byte,short,int,long,` **字符型：** `char` ,**浮点型：** `float,double`,**布尔型**：`boolean`.
	- **byte**:1字节。
	- **short**:2字节。
	- **int**:4字节，为整型的默认类型。
	- **long**:8字节，在定义时需要在末尾加上`l`或`L`。
	- **char**:2字节。`char c1 = 'x'` 或 `char c1 = '\u00xx'` \u00xx表示Unicode码 或`char c1 = xx`，其中xx为ASCII码。（运算时使用ASCII码）
	- **float:** 4字节，定义时末尾需加上`f`或`F`。
	- **double**:8字节，为浮点型的默认类型。
		BigDecimal型的精度高于浮点型，不会自动舍入。
	- **boolean**:1字节或4字节，具体看JVM规范。只有`true`和`false`两种类型。
- **运算规则**：
	- **自动类型提升:** 存储范围小的自动转换为存储范围大的。char,byte,short->int->long->float->double
		- char,byte,short进行运算时，默认提升为int型。
	- **强制类型转换:** 范围大向范围小时会报错，但在实际应用中需要使用，可使用强转符来强制转换，即`()`。`long l1 = 12345L; int l1 = (int)12345;`
- **引用数据类型：** String.
	- **使用：** `String s1 = "xxx"。
	- **运算：** String与基本数据类型运算时，使用连接符`+`，并且默认转换为String型。
### 3. 计算机存储：
- 计算机默认使用补码存放数据。
- 正数的原码、反码和补码都一样；负数的反码为原码除符号位取反，补码为反码+1。
### 4. 运算符：
- `++`：自增运算符。放前面时，表示先自增，后赋值；放后面时，表示先赋值，后自增。**自增运算符不改变数据类型！**

# Day05：（3月27日）
## 时长与内容：
- 3h左右；
- 尚硅谷视频35~41.
## 学习复盘：
### 1. 运算符：
- **赋值运算符：** `+=`,`*=`...，等，不改变数据类型，在开发中更常用。
- **比较运算符：** `==`,`!=`，可适用于基本数据类型以及String型，在开发中可`if(!xx)`or`if(xx)`代替，可避免`==`和`=`的混淆。
- **逻辑运算符：** `&,|`,`&&,||`，后者为短路运算符，即条件中的前者通过，则直接执行，而不需要两个都判断，在开发中更加适用，具体如下：
	- `if( 5>10 && 10>5)`，因为左边`5>10`为false，故不会执行符号右边的操作。
	- `if(10>5 || 3>5`)，因为等式左边是false，故不会执行符号右边的操作。
- **位运算符：** `<<,>>,>>>,%,|,^,~`，其中`^`为异或操作。
	- `<<`,`>>`：左移和右移操作，每次左(右)移一位，就代表在原有的基础上乘(除)2。据此，可提出快速计算`2*8`的方法，即`2*8=2*2^3`,即将2左移3位即可。
- **条件运算符：** `(条件表达式)?表达式1:表达式2`。
	- `(条件表达式)?表达式1:表达式2`的使用方法：`()`内为需要判断的条件语句，后面的表达式1和表达式2为条件为true/false分别要执行的语句。这里要注意，表达式1和表达式2需要为同种或兼容类型，例如同为int型，或同为String型等。
		- **兼容**指的是符合自动类型提升的类型，或者可以使用强转符。
### 2. 0.1+0.2不等于0.3的原因：
- 二进制转换为十进制时，整数可以符合一对一且连续的映射关系，例如0b00=0, 0b01=1, 0b10=2；而在小数中，0b0.0001=0.0625, 0b0.0010=0.125, 0b0.0011=0.1875。二进制小数虽然连贯，但十进制小数不连贯，即无法用二进制小数表示0.125~0.1875中的十进制小数。
# Day06：（3月28日）
## 时长及内容：
- 约3.5h
- 尚硅谷视频41~46+59~61.
## 学习复盘：
### 1. 流程控制语句：
- **`if-else`：** 这里要注意是`else if(){}`，并且最后的else可以不加。
- **`switch case`：** 格式如下。这里要注意，`xx`只能为byte,short,char,int这四种基本数据类型。(后面新增了enum和String类型)
	- 在判断case通过后，会执行下面的语句，若无break，则会将接下来的执行语句均执行了。
	- `default`语句可以任意置放，但要注意加break，否则会把default接下来的语句都执行了。
	```
	switch (xx){
	case x:
		~
	case y:
		~
	default:
		~
	}
	```
# Day07：（3月29日）
## 时长及内容：
- 约2h；
- 尚硅谷视频46~49；
## 学习复盘：
### 1. switch-case：
- **利用好switch-case的穿透性，可同时执行多个分支：** 例如在计算对应日期是每年的第几天时，可利用switch-case的穿透性，即倒着数来实现对对应月份前面的所有月份天数相加。
### 2.闰年的判断方法：
- **闰年判断：** 能被4整除，且不能被100整除或能被400整除。
# Day08：（3月30日）
### 和小丽出去玩了，没学习！

# Day09：（3月31日）
## 时长及内容：
- 约4h；
- 尚硅谷视频49~55；
## 学习复盘：
- `for`循环
- `while`循环：`与for循环区分，while循环是在执行语句中声明迭代部分。`
- `do-while`循环：与`while`循环区分，`do-while`一定会执行一次执行语句，其形式为：
	```
	do{
	执行语句
	}while(循环条件)
	
	```
- 随机生成[a,b]范围内的整数，可利用`Math.random`来实现，即[a, b]=(int)(Math.random * (b-a+1) )+ a.
- 定义`Scanner`类后，记得使用`scan.close()`关闭。
- 可利用`continue`跳出本次循环，利用`break`结束循环。并且可以在`for/while/do-while`前加标签，这样就可以使用`break/continue`来跳出外层循环。
# Day10：（4月1日）
## 时长及内容：
- 4h左右
- 尚硅谷视频55~58+62~64+谷粒项目；
## 学习复盘：
### 1. 谷粒项目：
- 利用定义`String`型变量来便捷打印重复出现的字符串；
- 若要使用无限循环，利用`while`循环比较美观简洁。
- 对于String型的`==`判断，需要用`xxx.equals("x")`或者`"x".equals(xxx)`.


### 2. 数组：
- **数组的定义方法：**
	```
	int[] array1 = new int[]{}; //静态定义方法
	int[] array2 = new int[3];  //动态定义方法
	```

- **数组的默认值：** 
	- 整型：0
	- 浮点型：0.0
	- 字符型：0（\u0000)
	- 布尔型：false
	- 引用数据类型：null
	- （若无法判断是ASCII码还是字符'0'，可利用`if(==)`来判断。
# Day11：（4月2日）
## 时长及内容：
- 约5h；
- 尚硅谷视频64~70；
## 学习复盘：
### 1. 数组的内存划分：
- new了新数组后，JVM会在堆内存中开辟空间，创建数组。数组有对应其类型的初始值，并且对应有一个16进制的地址，地址还会包含类型信息。JVM会将堆中的数组地址赋给栈中的arr。故arr保存的是堆中的数组地址。
- **数组的下标从0开始：** 因为数组的第一个元素距离首地址间隔0个单元格。（数组的首地址就是第一个元素的地址。）
### 2. 对于获取最大值：
- 定义一个中间变量，并在数组赋值的同时进行比较，若大则替换，小则continue。
### 3. 多维数组：
- **定义：** 
```
int[][] arr1 = new int[][]{{x,x},{x,x}};//静态定义；
int[][] arr1 = new int[3][4];//动态定义；
int[][] arr1 = new int[3][];//这样单独定义每一个一维数组的列数。
```
- **内存解析：** 
	二维数组（实质上仍是一维数组），同样是在方法栈中定义一个arr1。方法堆中对应创建一个一维数组（长度等于arr1.length)，此一维数组的每个值都为一个地址，指向其对应的一维数组的地址。此对应的一维数组的长度等于arr1[i].length。故实质上是在堆中创建了arr1.length+arr1[i].length个一维数组！
- **数组的复制：** 令`arr2 = arr1`，实质上是令arr2和arr1的地址指向同一个数组，本质上二者已经是同一个数组，故改变arr2的值也会对应改变arr1的值。若想实现复制操作，应该`new int arr2[]`，并且利用for循环来使其对应值赋相同值。只有这样，才是两个不同的数组，即地址不同！
- **数组的扩容：** new一个新数组`newArr`，若长度为2倍，则可用`arr1.length << 1`来实现。利用for循环使前面的值相等，后面的值对应赋值即可。最后再让`arr1 = newArr`即可，此时`arr1`的地址即指向`newArr`的地址。
- **数组的缩容：** new新数组，令其在缩容元素前的值相等，后的值对应向前挪动。最后再让`arr1 = newArr`，令其地址相同。
- **缩容方法2：** 直接从缩容元素开始，将数组元素值向前挪动，最后将数组中最后一个元素的值赋值为0.这样数组的长度不变，但最后一个元素的值为0（null），也算是实现了缩容！并且不需要创建新数组。
- **数组的反转：** 利用`for`循环，在`arr1.length`前利用中间变量temp执行`arr1[i] = arr1[arr1.length - i - 1]`的操作。
# Day12：（4月3日）
## 时长及内容：
- 约4h；
- 尚硅谷视频70~74；
## 学习复盘：
### 1. 查找、排序：
- **顺序查找：** 即对数组中中所有元素遍历，找到对应元素并输出相应的索引值；
- **二分查找：** （要求数组按大小顺序排列），定义三个参数：`mid,head,end`.判断`value`和`arr[mid]`的大小，若`value < arr[mid]`，则`end = mid - 1`. 继续执行此操作，直到`value == arr[mid]`.
- **冒泡排序：** 即每次执行一轮大小比较，得到一个最大值，继续执行直到排序完成。对于`arr.length`个元素，外层循环为`for(int i = 0;i < arr.length - 1;i++`，内层循环为`for(int j = 0;j < arr.length - j - 1;j++`. 冒泡排序的时间复杂度为`O(n^2)`.
- **快速排序：** 即每轮都会将基准值放好，使其右边都是大的，左边都是小的，即二分为两个数组。再对这两个数组进行同样的划分操作，直到完成排序。时间复杂度为`O(nlogn)`。具体地操作如下：
```
	left从左向右，遇到大的数值则进行交换；right从右向左，遇到小的则进行交换！直到left和right指向同一个元素，则将其与基准值进行交换。继续对左右两边的小数组执行此操作，直到完成排序！
```
### 2.Arrays工具类：
- **打印数组元素：** `Arrays.toString()`.
- **对数组进行排序（快速排序）：** `Arrays.sort()`.
- **数组元素的二分查找：** `Arrays.binarySearch()`.

# Day13：（4月4日）
## 时长及内容：
- 约4h；
- 尚硅谷视频74~79.
## 学习复盘：
### 1. 面向对象编程：
- **思想：** 以对象为单位进行编程，区别于面向过程。面向过程指的是将某件事划分为多个行为；而面向对象是指将某件事抽象为多个对象，每个对象都有对应的属性和方法，共同完成了这件事。
- **对象：** 类是某类实物的抽象概念，是一个大范围的概念。而对象则是类的实例化，即具体的某件事。
- **类的概述：** 类包含属性和方法。**方法必须在类中定义！** **方法中可以调用类的属性或方法。** 类是通过`class`来定义的，而方法的定义方法是`权限修饰符 返回值类型 方法名(形参){}`。属性是类的变量，方法是类中执行的操作。
- **具体实现：** 
	1. **类的定义：** 利用`修饰符 class 类名{}`来定义一个类；
	2. **类的实例化（创建对象）：** `类名 xx = new 类名()`来将类实例化；
	3. **对象属性/方法的调用：** `xx.属性 = ~;`,`xx.方法`，访问类的属性和方法。
- **<span style="background:#ff4d4f">内存解析：</span>** `new`出来的结构和对象都存放在堆空间里；方法执行时要入栈，执行结束后即出栈。

- **`return`分析：** `return`是在有返回值时使用，例如`return avg;`。并且`return`后即结束方法，故也可当作`break`来使用。


# Day14：（4月5日）
## 时长及内容：
- 约3h；
- 尚硅谷视频79-80.
## 学习复盘：
### 1. 对象数组：
- 对象数组就是定义一个数组，其中的元素都是对象！定义方法为：`方法名[] 对象名 = new 方法名[n];//动态定义方法`.
- 每个元素都为对象，都有对应的属性和方法。可以通过`xx.属性;xx.方法`来调用。
- 当对对象的某一个属性执行排序时，我们会执行交换操作，这里要注意：不是只交换属性的值，这样会导致属性和对应索引的对象不匹配，即出错！而是要交换整个对象，即改变各自的索引值。

# Day15：（04月06日）
## 时长及内容：
- 约2.5h；
- 尚硅谷视频80-83.
## 学习复盘：
### 1. 方法的重载：
- **定义：** 在同一个类中，可以定义同名的多个方法。要求同名的方法的**形参类型或形参个数不同**，但是权限修饰符和返回值不同无效！
- **println的重载：** println中有多个重载的方法，其中对于char类型的数组，会打印其中的元素，而不是地址！
### 2. 可变个数的形参：
- **定义：** 若传入参数的个数不确定，可以不需要将形参定义为数组，而将形参定义为可变数量的基本数据类型，即`public void 方法名(int ... xx);`,即在形参类型和形参名中加入`...`.
- **重点：** 
	1. 形参个数为0~n；
	2. 可变个数的形参定义必须放在后面，例如`public void print(int i, int ... j)`符合要求，但`public void print(int ... i, int j)`则会报错！
	3. 可变个数形参的调用优先级较低，若有重载且为确定个数的方法，会优先调用。例如：`public void xx(int i)`和`public void xx(int ... i)`，会优先调用前者。
	4. 可变个数的形参和数组类型的形参的同名方法不构成重载，即会报错！例如：`public void xx(int ... x)`和`public void xx(int[] x)`不可同时存在！
### 3. 方法的值传递机制：
- **复习：** 基本数据类型的变量相等`i2 = i1`，是将数据值传递；而引用数据类型的`arr2 = arr1`，传递的是地址值。但本质上二者都是值传递。
- **定义：** 调用方法时，会将实参的值传递给形参！对基本数据类型和引用数据类型，传递的分别是数据值和地址值。 
- **理解：** 调用方法时（以变量值交换为例），若形参是引用数据类型，如对象、数组等，虽然方法没有返回值，但实参的值其实也已经在方法执行中随之改变！而若形参是基本数据类型，则形参值会在方法中改变，但随着方法执行完出栈，实参的值还是不变
- **细节：** 
	- 对于基本数据类型，即放在main方法的栈中，存放的是数据值；而对于引用数据类型，变量也存在main方法栈中，但存放的是地址值，地址值指向堆中存放的new出来的对象。
	- 调用方法时，方法入栈，执行结束后出栈！
	- 对象的属性值是存放在堆中的！
# Day16：（04月07日）
## 时长及内容：
- 约1h；
- 尚硅谷视频83.
## 学习复盘：
### 1. 递归方法：
- **定义：** 在方法中调用自己。
- **重点：** 
	- 要注意有终止语句，例如`if (i == 0) { return 0;}`。否则会导致栈溢出。
	- 系统中查询文件夹的大小即是采用了递归遍历的思想。
	- 递归会占用大量系统堆栈，内存耗用多！而循环速度更快，并且节省内存。
	- 在递归时，对返回值为两个相加的情况，会采用类似于二叉树遍历的方式执行。

# Day17：（04月08日）
## 时长及内容：
- 约4h；
- 尚硅谷视频83-90；
## 学习复盘：
### 1. package的使用：
- 用于指明文件中定义的类、接口等结构定义的包。格式为：`package 包名`。
- 包名属于标识符，要求全小写。
- MVC设计模式：Model、Viewer、Controller，分别负责不同的作用。
### 2. import关键字的使用：
- 显式引入指定包下所需要的类。格式：`import 包.类;`。
- `import`只导入该包下的类，而不包含包中的子包的类！
- 对于不同包中，若含有相同的方法，则需要使用`包.xx`样式的全类名方法来区分。
### 3. 封装性：
- 封装性，是指利用权限修饰符来控制属性和方法的访问，使该开放的开放，该隐藏的隐藏，限制访问权限。
- 四种权限修饰符：`public`,`protected`,`缺省`,`private`。`protected`可以在其他包的子类内都能访问；`缺省`最多只能在本包内访问！
### 4. 构造器：
- **构造器：** 凡是类中都有！在new新对象时会调用，即`类名 对象名 = new 类名();`，其中`类名()`即为构造器。
- 在不进行定义时，默认类构造器为空参构造器，且权限与对应类的权限相同。
- **构造器的定义：** 通过传入形参列表，可以在new新对象的同时给属性赋值。（例如给`private`属性赋值）
	```
	public 类名(形参列表){
		方法体;
	}
	```
- 构造器也可重载(overload)，通过形参列表不同来进行区分。在定义了含参构造器后，便无法再使用空参构造器，除非再主动定义。
- 若某个方法/构造器的形参列表是对象，则可直接`(new 类名())`的方法来传入实参，避免额外定义一个变量了。
### 5. 属性赋值、JavaBean：
- 属性赋值的5种方法：①默认初始化；②显式赋值；③构造器初始化；④利用`对象.属性`赋值；⑤利用`对象.方法`赋值。
- JavaBean：①public类；②空参构造器；③有getter、setter.
# Day18：（04月09日）
## 时长及内容：
- 约3h；
- 尚硅谷视频90-92；
## 学习复盘：
- `final`：在定义常量时使用。
## 1. 关键字`this`：
- 在定义方法、构造器时，有时需要定义形参列表，此时可将形参名定义的与属性名相同（易懂，省事）。此时为了避免属性与形参的混淆，则通过`this.属性 = 形参;`的方法来定义。（此处的`this`可以理解为当前对象(方法调用时)或正在创建的对象(构造器调用时)）.
- `this`除了代指对象来定义属性，还可以用来代指构造器！常在同时存在多个构造器时调用，避免重复输入相同的方法体，造成代码冗余、繁琐。`this(形参列表);`.通过形参列表来区分是哪个构造器。
	- 注意，使用`this(形参列表);`代指构造器时，必须放在首行！因此也必须只能声明一个（使用一次）！

# Day19、20：（04月10日、04月11日）
## 时长及内容：
### Day19：
- 早上看论文，下午一直做实验，晚上本打算去看恶鼠，结果没看到，最终一直坐着在地大，也没学习！
### Day20：
- 早上上课，下午和小丽去医院，晚上回实验室赶报告！最终没学习！
# Day21：（04月12日）
## 时长及内容：
- 早上改报告、下午开会、晚上去吃龙虾殿，回去了也玩游戏，最终没学习！
# Day22：（04月13日）
## 时长及内容：
- 约5h；
- 尚硅谷视频92~99；
## 学习复盘：
### 1. 继承性：
#### 定义：
- `class A/B/C extends D{};`
- 即A、B、C等子类继承了父类D的所有属性、构造器和方法，并可以额外增添子类特有的属性和方法。
#### 说明：
- 父类中声明为`private`的属性和方法子类也会继承，但由于封装性，子类无法对其进行调用。
#### 方法的重写：
- 父类被子类继承的方法，可在子类中被重写!(区别于方法的重载->在用一个类中拥有相同方法名不同形参列表的方法。)
- 父类与子类的方法名与形参列表必须相同（区别于重载），并且子类的权限不小于父类！
- 父类与子类的返回值应相同；但若返回的是对象类型，则子类的返回值也可以是父类返回值的子类对象。
#### super关键字：
##### 定义：
- 与this类似（代指当前类中的对象或正在创建的对象），super用于代指父类中的方法、属性或构造器。
##### super调用属性与方法：
- `super.xx`可实现调用父类的属性或方法；
- `super()`可实现调用父类的构造器，但只能放在首行！（故可知，`super()`和`this()`只能调用一个）
- 子类继承父类时，必须主动在父类声明空参构造器（若不止一个构造器），这样才能不报错。也因为子类在不声明时会默认调用父类的空参构造器。
### 2. 多态性：
#### 定义：
- `父类 对象名 = new 子类();`
- 父类的引用指向子类的对象。
#### 调用：
- 此时，对象为父类引用类型，但执行时调用的是子类的方法，这也称为“虚方法调用”。（编译时看左边，运行时看右边）
- **无法调用子类有而父类没有的方法！！！**
- **字段隐藏**: 当子类定义了与父类同名的字段时，子类的字段隐藏了父类的字段。它们在内存中是分开的，子类的字段不会影响到父类的字段。
# Day23：（04月14日）
## 时长及内容：
- 约4h；
- 尚硅谷视频99~104；
## 学习复盘：
### 1.向下转型与向上转型：
#### 向下转型：
- 在多态性的使用下：`Animal d1 = new Dog();`，即通过父类的引用类型来调用子类重写的方法。此时分为三种情况：①父类特有的方法，此时子类没有重写；②子类重写了父类的方法；③子类特有的属性和方法（父类没有！）
	- 针对情况①，此时可看作子类继承了父类的方法，故此时执行的是子类的方法。
	- 针对情况②，此时引用类型是父类，但仍执行的是子类的方法。
	- 针对情况③，此时是子类特有（指父类没有）的属性和方法，但由于引用类型是父类，故无法调用子类特有的方法！这种情况可以通过向下转型来解决。
- 因为`Dog`类是`Animal`类的子类，故可以通过强转符()将对象从父类引用转换为子类引用，即`Dog p1 = (Dog) d1`.此时并没有创建新对象，只是创建了一个新的引用，指向了对象d1。（即d1和p1指向堆空间的同一对象，二者地址相同！）
- 为了避免出现类型转换异常，则可以在进行强转前进行判定：`instanceof`.
- 若`a instanof A`为`true`，则`a instanof superA`也为`true`.
#### Object类：
- Object类是java类的根父类，没有属性，但有空参构造器。
- `toString()`:默认返回当前对象的地址；重写后常用来返回其内部实质内容。
- `equals()`:比较两个引用类型变量的地址是否相同;重写后常用来比较二者的实质内容是否相等;
- `clone()`:复制一个与原对象地址不同的新对象.
- `finalize()`:可看作垃圾回收前最后的执行语句.

# Day24：（04月15日）
## 时长及内容：
- 约3h；
- 尚硅谷视频104~108；
## 学习复盘：
### 1. 多态性：
- **多态性理解：** 编译时，看的是父类，运行时，看的是主类。若子类无重写的方法，则会调用父类的方法；但若子类有重写的方法，则优先调用子类的方法！
### 2. 关键字static：
- 可用于修饰属性、方法、代码块和内部类，使其成为静态变量/静态方法。
#### 属性：
- 修饰属性时，则成为静态变量，在内存空间中只存在一份，被多个实例所共享。此时任意修改某个实例中静态变量的值，其他实例中该值都会改变！
- 静态变量存放在堆空间中。
- 随着类加载而加载。
- 可通过`类.属性` 或`对象.属性` 的方法调用！
#### 方法：
- 可通过`类.属性` 或`对象.属性` 的方法调用！
- 静态方法中，无法使用关键字`this`和`super`.因为这二者看作对本类或父类对象的引用。而静态方法随类的加载而加载，故此时对象不一定存在！
- 若在同一个类中存在静态方法，则可直接通过`方法名()`的形式调用，无需创建对象，也无需带上类名。
### 3. 单例设计模式：
#### 定义：
- 某个类只存在一个对象实例，并且只提供一个取得该对象实例的方法。
#### 调用：
- 将构造器定义为`private`；
- 提供静态方法和静态变量，返回在类的内部创建的对象。
#### 饿汉式单例模式：
1. 类的构造器私有化；
2. 在类的内部new一个`static`对象；
3. 提供`public`的`static`方法，用于在类的外部调用对象。
#### 懒汉式单例模式：
1. 类的构造器私有化；
2. 类的内部提供类的实例；
3. 提供`public`的`static`方法，用于在类的外部调用对象。（若对象为空，则先new一个新对象；若非空，则直接返回对象）
#### 两者对比：
**饿汉式：**
- 能在加载类的同时创建对象，避免了多线程安全问题；
- 但是加载时创建了对象，会一直占用堆空间的内存，导致内存浪费；
**懒汉式：**
- 延迟加载，在调用方法时才会创建对象，节省内存；
- 可能会有多线程安全问题！（即不止创建了一个对象）
### 4. main()的语法：
- main是程序的入口，JVM会调用类的main()方法来执行，故必须是`public.
- JVM在调用main方法时，此时类的实例还未被创建，故需为static类型，才能保证其被JVM正常调用！
- 总之，main方法定义为`public`和`static`，可以保证JVM正常访问及调用main方法。
- `String[] args`是main方法的形参列表，用于接收命令行传入的参数。
# Day25：（04月16日）
## 时长及内容：
- 约3h；
- 尚硅谷视频108~111；
## 学习复盘：
### 1. 代码块：
#### 定义：
- `(static){}`
- 用于初始化类或对象的信息；
- 执行顺序位于构造器之前！
#### **静态代码块：**
- 随类的加载而加载，故只会执行一次；
- **作用：** 初始化类的信息；
- 静态代码块内部只能调用静态结构，否则此时对象并未创建，非静态结构无法被调用；
#### 非静态代码块：
- 随着对象的创建而加载，每创建一个对象就加载一次；
- **作用：** 初始化对象信息；
- 执行顺序位于静态代码块之后；
### final关键字：
#### 定义：
- 用于定义”常量“；
- 可用来修饰类、方法、变量等；
#### 重点：
- 被`final`修饰的类无法被继承；
- 被`final`修饰的方法无法被重写；
- 被`final`修饰的变量为常量，值无法被更改，并且定义时必须主动赋初始值；
- `final`修饰的对象，地址无法被改变（这就是对象的“值”），但其属性值可以被更改；
#### final与static：
- 用于修饰全局常量，例如：`Math.PI`

# Day26：（04月17日）
## 时长及内容：
- 约2h；
- 尚硅谷视频111~113
## 学习复盘：
### 1. abstract关键字：
#### 定义：
- 使类/方法抽象化，即无法被实例化。
#### 类的抽象：
- 类抽象化后，无法被实例化，但可以被子类继承！
- **作用：** 类抽象化后，提出抽象化的方法，然后通过子类来具体实现！方便了某一个功能在不同子类中的不同实现。
#### 方法的抽象：
#### 定义：
- 方法的抽象：`public abstract void xx()`。方法的抽象定义不可以带大括号，无需要执行的方法体！
- 方法抽象后，其类也必须是抽象化的。
- 父类的所有抽象方法，都必须被子类重写！
# Day27：（04月18日）
## 时长及内容：
- 约1.5h；
- 尚硅谷视频113~114；
- 力扣题1.
## 学习复盘：
### 1.接口：
#### 定义：
- 接口是一种引用数据类型，不可创建对象。
- 利用关键字`interface`定义。对于属性，必须加上`public static final`定义；对于方法，在jdk8之后，可以声明私有方法。
- 无法修饰构造器和代码块。（接口区别于类，无构造器！）
- 接口与类为实现关系；接口与接口为多继承关系。
#### 使用：
1. 实现类与接口：`class 类名 implements 接口{}`.
2. 可直接通过`接口.方法();`来调用其中的方法！
3. 实现类可以同时实现多个接口（可理解为满足多个协议）；类在实现接口的同时也可继承父类。
4. 接口中可以定义抽象方法，但此时实现类必须重写所有抽象方法，否则无法实例化！
5. **接口的多态性：** `接口 变量名 = new 实现类;`此时为接口类型，但是执行的是实现类中重写的方法（要求实现类为该接口的实现类！）
#### 创建接口的匿名实现类的对象：
- `接口 对象名 = new 接口(){抽象方法的实现};`  相当于用`接口(){}`来替代匿名实现类！
#### 创建接口的匿名实现类的匿名对象：
- `类.方法(new 接口(){抽象方法的实现})` 因为是匿名对象，故不会出现对象名。相当于直接利用`new 接口(){实现}`来充当“实现类的对象”。
# Day28：（04月19日）
## 时长及内容：
- 约2.5h
- 尚硅谷视频114~116；
## 学习复盘：
### 1. 接口：
- 接口类似于类，也有`instanceof`方法，用于判断该对象是否是接口的实现类对象。
- 若对象是接口的实现类，则可利用强转符`()`转换并调用接口方法。
### 2. jdk8与jdk9的接口：
#### jdk8：
- `jdk8`：接口内定义静态方法，但该静态方法只能被`接口.方法();`调用，而不能通过实现类实例化调用；
- `jdk8`：接口内定义默认方法，需要通过实现类实例化调用，（并且在实现类中可以重写）。
	- 若在实现类中需要调用接口中已被重写的方法，可通过`接口.super.方法();`来实现。
#### jk9：
`jdk9`：接口内定义私有方法。无法被实现类继承，作用为在接口内减少代码的重复冗余。
#### 多接口问题：
对于多接口（多继承）的情况，若不同接口内存在同名同参数的方法，则会报错。但以下两种情况不会报错：
	① 实现类中有对该同名方法的重写；
	② 实现类同时有继承的父类，并且该父类中存在同名的方法，则优先调用父类方法，不会报错。

# Day29：（04月20日）
## 时长及内容：
- 约6h；
- 尚硅谷视频116-124
## 学习复盘：
### 1. 内部类：
#### 定义：
- 内部类，定义在类中的类，可进一步分为成员内部类和局部内部类。
	**成员内部类：** 直接声明在外部类中。还可分为静态/非静态，静态内部类可直接调用，无需创建实例。
	**局部内部类：** 声明在方法、构造器、代码块中。
#### 成员内部类：
- 可以声明为`static`类，但此时无法再调用外部的非静态结构。
- 可以声明为`abstract`类，此时需要有子类继承并冲写法方法。
- 可以声明为`final`类，此时无法被继承。
- 可以有继承的父类/实现的接口，此时需要重写方法。
##### 使用：
- **实例化静态内部类：** `外部类.静态内部类 对象名 = new 外部类.静态内部类();`
- **实例化非静态内部类：** 
	```
	外部类 对象1 = new 外部类();`
	外部类.非静态内部类名 对象2 = 对象1.new.. 非静态内部类名();
	对象2.非静态方法();
	```




### 2. 枚举类：
#### 定义：
- 本质也是类，但枚举类的对象有限、固定，用户不可随意创建。
```
enum 枚举类名{
	MONDAY(xxx,xxx),
	TUESDAY(xxx,xxx),....
	SUNDAY(xxx,xxx);
}
```
- 不同的对象用逗号隔开，最后用分号结尾。
- 枚举类的属性值默认为`public final`类型；有参/无参构造器为`private`类型，并且可忽略；枚举类的对象为`public static final`类型，定义时可忽略。
#### 实现接口方法：
- 若在枚举类中重写/实现方法，则每个对象调用方法输出的结果均相同；
- 但若在定义每个枚举类对象时重写/实现方法，则输出结果均不同。

### 3. 注解：
#### 定义：
- `@xxxxx`，可用于生成文档注释、标记重写/实现方法、进行单元测试。
- 常用注解：
	- `@Override`:限定父类重写方法，只能用于重写方法。
	- `@Deprecated`:用于标记过时的类、方法等。
	- `@SuppressWarnings`:抑制编译器警告。

### 4. 包装类：
#### 定义：
- 让基本数据类型能拥有引用数据类型的相关特点，如封装性、继承性和多态性。

#### 基本数据类型-->包装类（装箱）：
- ①使用构造器：`Integer xx = new Integer();`②调用包装类的方法：`Integer xx = Integer.valueOf(num);`③自动装箱：`Integer 对象名 = i1;`
#### 包装类-->基本数据类型（拆箱）：
- ①调用包装类方法：`int i1 = obj.intValue;`②自动拆箱：`int i1 = 对象名;`
#### 基本数据类型-->String：
- ①调用String型的方法：`String s1 = String.valueOf(num);`②直接利用String型的连接符`+`.
#### String-->基本数据类型：
- ①利用包装类的方法实现：`int i1 = Integer.parseInt(String s1);`②利用包装类的构造器：`int i1 = new Integer(String s1);`③利用包装类的方法：`int i1 = Integer.valueOf(String s1);`(实质上是先转换成Integer型，再自动拆箱成为int型。)

#### 注意事项：
- 自动装箱时，若传入的int数值为`[-128~127]`之间，则包装类的地址是相同的，因为Java对于这区间中的数值做了缓存，在使用自动装箱时，会尽可能重用这其中的对象。（前提是使用了自动装箱，但若new了新对象，则地址不相同！）


# Day30：（04月21日）
## 时长及内容：
早上睡懒觉、下午睡午觉、晚上和小丽吃饭，最终没学习！
## 学习复盘：
无！
# Day31：（04月22日）
## 时长及内容：
- 约4h.
- 尚硅谷视频124-129.
## 学习复盘：
### 1. 异常：
#### 定义：
- 程序执行过程中，出现的非正常情况，并且若不正常处理，会导致JVM停止运行。
#### 分类：
- `Throwable`为根父类；`Error`和`Exception`为对应`Throwable`的两个类；`Exception`又可分为编译时异常和运行时异常。我们常处理的是**编译时异常**。
#### 异常处理方式：
##### 1. `try-catch-finally`：
- `try`：将可能出错的代码放在`try`之中，若出现异常，则生成异常对象，并将对象抛给`catch`进行处理；
- `catch`：匹配、捕获异常对象，进行处理。处理异常后可继续运行。
- `finally`：无论如何，都会执行的代码！例如`try`中出现异常，或出现return语句，则会在类似使程序结束的代码执行前先执行`finally`中的语句。（常将输入输出流、数据库连接等资源的显式关闭操作放在`finally`语句中，防止内存泄漏。
- 若未出现异常，则先执行完try中的语句，再执行finally中的语句（若try中有return语句，finally中的语句会在return之前执行）。
- 若出现异常，则会跳过try语句中出现异常后的的代码，并且进入catch语句匹配异常，执行catch中的语句，最后再执行finally中的语句。
##### 2. `throws`：
- `void xx() throws 异常1, 异常2{}`：将异常抛给方法的调用者进行处理，最底层为main方法，在main方法中必须处理异常。
- 子类`throws`的异常必须为父类`throws`的异常的子类或同类，不能为其父类。
- 若父类无`throws`异常，则子类也不可有，即只能使用 `try-catch-finally`进行处理。
##### 3.手动throw异常对象：
- 在方法内部，满足指定条件时，使用`throw 异常对象`的方式手动抛出异常对象进行处理。常在程序输入不违反语法条件，但不符合实际场景时使用。

##### 4. 自定义异常类
- ①`public class 异常类名 extends Exception/RuntimeException{}`.②提供若干重载构造器；③提供全局常量ID，让IO流能根据ID进行访问:`static final long serialVersionUID = xxxl;

# Day32：（04月23日）
## 时长及内容：
- 约5h
- 21、22、23日的学习笔记复盘；
- 尚硅谷视频132-134；
- 《Hello-Algo》：栈、队列的数组/链表实现。
## 学习复盘：
### 1. 多线程：
#### 定义：
- **程序：** 用某种语言编写的一组指令的集合，即一段静态代码。
- **进程：** 程序的一次执行过程，或正在内存中运行的程序。
	- 进程是操作系统调度和分配资源的最小单元。
- **线程：** 进程的一条执行路径。
	- 线程是CPU调度和执行的最小单元。
	- 一个进程中的多个线程共享相同的内存单元。
	- **分时调度：** 为每个线程平均分配时间；
	- **抢占式调度：** 优先级高的线程以较大的概率优先使用CPU。
- **并行：** 两个或多个事件在同一时刻发生。如多条指令在多个CPU上同时执行。
- **并发：** 两个或多个事件在同一时间段内发生。如多条指令在单个CPU上快速轮换、交替执行。
#### 创建线程：
##### 方式一：继承Thread类：
- ①创建继承Thread类的子类；②重写Thread类的`run`方法；③创建子类的实例；④调用子类对象的`start`方法：开始线程，执行run方法。

##### 方式二：实现Runnable接口：
- ①创建实现Runnable接口的实现类；②实现接口中的run方法；③创建实现类的`对象1`；④将`对象1`传入Thread类的构造器中，创建Thread类的`对象2`；⑤调用`对象2`中的start方法。
- 

# Day33：（04月24日）
## 时长及内容：
- 约5h；
- 尚硅谷视频134~137；
- 《Hello-Algo》；
## 学习复盘：
### 1. 多线程：
#### 使用方法：
- ①继承Thread类；②实现Runnable接口。
#### 常用方法：

| `start()`               | 启动线程, 执行`run`方法.                                        |
| ----------------------- | ------------------------------------------------------- |
| `run()`                 | 内部代码块为线程要执行的操作.                                         |
| `currentThread()`       | 获取当前正在执行的线程.                                            |
| `getName()`             | 获取当前执行线程的名称.                                            |
| `setName()`             | 修改线程的名称.                                                |
| `sleep(long milltimes)` | 让线程休眠milltimes毫秒.                                       |
| `yield()`               | 释放当前线程的执行权, 让CPU重新选择新线程执行.                              |
| `join()`                | `A.join()`, 即让线程A暂时进入阻塞状态, 执行线程B, 并直到线程B执行结束后, 才会继续执行A. |
| `isAlive()`             | 用于判断当前线程是否存活.                                           |

#### 线程优先级:
- 分为三种优先级, 为 `MAX_PRIORITY(10)`, `NORM_PRIORITY(5)`, `MIN_PRIORITY(1)`. 其中`NORM_PRIORITY`为默认优先级.
- 可通过`getPriority()`获取当前线程优先级,`setPriority()`修改当前线程优先级.
#### 线程的生命周期:
- jdk5之前, 只分为5种状态: 新建, 就绪, 阻塞, 运行, 死亡.
![[530544829a1707d0801e6470.png]]
- jdk5之后,可将阻塞继续细分, 则分为以下几种状态: `NEW`, `RUNNABLE`, `BLOCKED`, `TIME_WAITED`, `WAITING`, `TERMINATED`.![[aaa948f1aa78d4de6b34f6c2.png]]

#### 线程安全问题:
- 线程安全问题的引起主要是 多个线程同时访问共享资源, 进行读写操作. 例如: 当线程A通过`if(共享资源)`的判定, 对共享资源进行操作. 此时线程B按理是无法通过`if(共享资源)`的判定的! 但由于线程A进入阻塞状态, 即暂未对共享资源进行写操作. 故此时线程B仍通过了判定! 则当阻塞状态结束, A和B同时对共享资源进行写操作, 导致出错!
#### 解决办法:
##### **同步监视器:** 
- 可以使用任何类的对象来充当, 用于监视线程, 保证同一时刻只有1个线程在对共享资源进行读写操作. 为了保证唯一的读写操作, 多个线程必须共用同一同步监视器, 即这个对象需唯一.
- 常用的同步监视器有两种: ①对于非静态方法/代码块, 可使用对象实例: `this`;②对于静态方法/代码块, 可使用类对象本身来作为同步监视器: `ClassName.class` ③还可以使用自定义的对象来作为同步监视器.
##### 1. 同步代码块:
```
synchronized(同步监视器) {
	操作共享数据的代码;
}
```
##### 2. 同步方法:
```
public void synchronized method1(){
	操作共享资源的代码;
}
```
# Day34：（04月25日）
## 时长及内容：
- 尚硅谷视频137~140.
## 学习复盘：
### 1. 线程安全的懒汉问题:
#### 饿汉式与懒汉式的设计模式回顾:
- 二者均为单利设计模式, 通过①私有化构造器;②类的内部定义公开, 静态的获取实例的方法`getInstance()`; ③类的内部定义私有的静态变量来存储唯一实例, 确保每个类只有一个实例.
##### 饿汉式: 
- 类加载时就进行初始化, 创建单例对象. 因此①能避免线程安全问题; ②若不需要使用实例, 则会导致内存资源的浪费.
```
public class HungrySingle{
	private static (final) HungrySingle INSTANCE = new HungrySingle();
	private HungrySingle(){}
	public static HungrySingle getInstance(){
		return INSTANCE;
	}
}
```
##### 懒汉式：
- 在第一次调用时初始化, ①保证了内存资源不浪费; ②可能会有线程安全问题, 导致不止一个实例被创建.
```
public class LazyOne{
	private static LazyOne instance;
	private LazyOne(){}
	public static LazyOne getInstance(){
		if(instance == null)
			instance = new LazyOne();
		return instance;
	}
}
```
#### 懒汉式的线程安全问题解决:
出现线程安全问题的原因主要是`getInstance()`方法中的if判断语句.
```
方式1:(同步方法)
public static synchronized LazyOne getInstance(){
	if(instance == null)
		instance = new LazyOne();
	return instance;
}

方式2:(getInstance内部的同步代码块)
public static LazyOne getInstance2(){
        synchronized(LazyOne.class) {
            if (instance == null) {
                instance = new LazyOne();
            }
            return instance;
        }
    }
```
### 2. 死锁问题:
- 即A与B都处于阻塞状态, 并且A在等待B释放资源, 而B也在等待A释放资源, 导致进入了死锁状态.
### 3. Lock的使用:
- 解决线程安全的新方法, 控制多个线程对共享资源的访问. 每次只能有一个线程对Lock对象加锁.
#### 使用方法:
- 通过显式的调用`Lock()`来获取锁,并调用`unlock()`来释放锁. 
- 需要手动开启和关闭, 并且`unlock()`一般放在finally语句中, 保证能释放锁.
```
class LockTest{
	private final ReentrantLock lock = new ReentrantLock();
	public void m(){
		lock.lock();
		try{
			操作共享资源的代码块;
		}finally{
		lock.unlock();
		}
	}
}
```
- **优点:** ①JVM能花费更少的时间来调度线程, 性能更好; ②相比于synchronized, 能提供更高级别的线程访问控制级别;
### 4. 线程间通信: (等待-唤醒机制)
- 多个线程共同完成同一任务时, 通过线程间通信来保证不同线程能按顺序/有规律地执行. 
#### 使用方法:
- 通过`wait()`来使线程进入阻塞状态, 并释放持有的对象锁, 使可以执行其他线程; 当其他线程执行完, 调用`notify()`或`notifyAll()`来唤醒线程, 重新争取CPU的执行权.
- `wait(), notify(), notifyAll()`均需在同步方法/同步代码块中中调用.

### 5. 多线程的两种新实现方式:
#### 创建接口Callable的实现类:
- **优点:** ①可以有返回值(通过`call()`实现.); ②可以抛出异常.
```
class A implements Callable{
	public Object call() throws Exception {
		代码块;
		return xx;
	}
}
```
#### 线程池:
~
# Day35：（04月26日）
- 看了下《Hello-Algo》, 没怎么学习. 下午打球了, 晚上和小丽吃饭去了.
# Day36：（04月27日）
## 时长及内容：
尚硅谷视频141~143.
## 学习复盘：
### 1. String:
#### 源码解析:
##### 类的定义:
- 由`final`定义, 即不可被继承; Serializable, 可序列化; `Comparable`: 可比较大小.
##### 内部属性:
- `private final char value[]`: 字符串内容存储在value数组中, 并且不可变.
- `private final byte[] value;`: 将char-->byte, 避免了内存资源的浪费(拉丁文字只占用1个字节.)
##### 内存结构:
**字符串常量池:** 
- **堆空间中**的一个特殊的存储区域, 用于存放由**字面量形式创建的字符串对象**. 目的是节省内存, 避免重复创建相同的字符串对象.
- **共享性:** `String s1 = "Hello";`, 若字符串常量池中 有`"Hello"`,则会返回对该字符串的地址; 若不存在, 则会在池中创建`"Hello"`, 再返回该字符串的引用.
**创建对象时的内存分配:**
- 方法①: `String s1 = new String("Hello");`: 实际上是创建了两个新对象. 一个新对象为"Hello", 存放在字符串常量池中; 另一个新对象为s1, 存放在堆空间中, 其值为"Hello"的地址.
- 方法②: `String s1 = "Hello"`: 若字符串常量池中无"Hello", 则会创建两个对象, 即一个位于字符串常量池, 另一个位于堆空间中. 但是!!!若字符串常量池中已有"Hello", 则会直接引用字符串常量池中的"Hello"对象. 即两者`==`!!!







##### 字符串连接方法:
- `"Hello" + "World"`:  若常量池中不存在, 则新建"HelloWorld"对象; 若存在, 则返回其地址.
- `s1+"World"`:  字符串变量和字符串常量的运算, 会在堆空间中创建一个`s1 + "World"`的字符串, 会导致内存的浪费.
- `s1 + s2`:  变量+变量, 同上.
- `(s1 + s2).intern()`: 调用`intern()`方法, 先在堆空间中创建了`s1 + s2(HelloWorld)`, 然后调用intern()方法, 若常量池中存在`HelloWorld`, 则返回其地址. 避免了重复的字符串创建.
#### String与其它类型的转换:
**`String<-->char[]`**:
- `-->`: 通过`toCharArray()`实现.
- `<--`: 通过构造器`String(char[] arr)`实现.
**`String-->byte[]`:** 
- `-->`: 通过`getBytes()`实现. 得到的是`byte[]`数组, 其内部元素为对应字符的ASCII码.(或其它字符集编码)
- `<--`: 通过构造器`String(byte[] arr)`实现.
#### 常用方法:

| `concat()`                            | 字符串进行拼接                          |
| ------------------------------------- | -------------------------------- |
| `compareTo()`                         | 根据字符串的Unicode码, 比较字符串大小.         |
| `trim()`                              | 去除字符串前后的空白.                      |
| `intern()`                            | 确保字符串常量池中只有唯一的字符串对象.             |
| `contains(String s1)`                 | 判断字符串中是否包含s1.                    |
| `toLowerCase()`                       | 将字符串中的大写字母转换为小写字母.               |
| `indexOf(String s1)`                  | 返回s1在字符串中首次出现的位置.                |
| `lastIndexOf(String s1)`              | 从后往前查找, 返回s1首次出现的位置.             |
| `subString(a, b)`                     | 返回`[a, b-1]`的字符子串.               |
| `startWith(String s1, int fromIndex)` | 判断字符串是否是以s1开头.(可从fromIndex开始判断.) |

# Day37：（04月28日）
## 时长及内容：
- 早上阅读了《Hello-Algo》。下午上课，晚上和小丽出去住了。
# Day38：（04月29日）
## 时长及内容：
- 尚硅谷视频145~148.
## 学习复盘：
#### `String, StringBuffer, StringBuilder`:
- 三者底层都是使用`byte[]`存储字符串.
- `StringBuffer`为可变字符串, 无需在常量池中新建字符串.(即进行增删改查等操作, 会在原来的字符串上修改, 而不是)
- `StringBuilder`也为可变字符串, 与`StringBuffer`区别为: **线程不安全.**
##### 源码分析:
- `byte[] value`: 底层为一个长度为16的byte数组, 用于存储字符串内容. 当需要存储的字符串长度超过数组长度时, 会进行扩容操作.
##### 常用方法:

| `append(xx)`           | 字符串尾部添加xx.                    |
| ---------------------- | ----------------------------- |
| `delete(i,j)`          | 删除`[i,j-1]`的字符.               |
| `deleteCharAt(i)`      | 删除第i个字符.                      |
| `replace(i, j, str)`   | 将`[i,j-1]`替换成str.(str的长度不限.)  |
| `setCharAt(i, char c)` | 将第i个字符替换成c.                   |
| `charAt(i)`            | 返回字符串中第i个字符.                  |
| `insert(i, str)`       | 在第i个字符后插入str.                 |
| `reverse()`            | 返回翻转后的字符串.                    |
| `setLength(i)`         | 截取前i个字符子串返回. 若i>length, 则补\0. |

# Day39：（04月30日）
## 时长及内容：
 - 尚硅谷视频148~149.
 - 《Hello-Alog》结束哈希表.
## 学习复盘：
### 1. Date:
#### Java.util.Date:
##### 构造器:
- `Date date1 = new Date();`: 用于获取基于当前系统时间的Date实例.
- `Date date1 = new Date(long Times);`: 用于获取基于毫秒数Times的Date实例.
##### 常用方法:
- `toString()`: 输出Date实例的时间.
- `getTime()`: 输出Date实例时间对应的毫秒数.
#### `java.sql.Date`:
##### 构造器:
- `Date date1 = new Date(long Times);`: 获取毫秒数Times对应的时间的Date实例.
##### 常用方法:
- `toString()`: 输出Date实例的时间, 时间格式为"年-月-日".
### `SimpleDateFormat`:
#### 作用:
- 用于日期时间格式的转换, 将`Date<-->字符串`.
#### 构造器:
- `SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd ~");`: 将格式定义为`"yyyy-MM-dd ~"`. 可将Date实例格式化为实例sdf对应的格式. 也可将`"yyyy-MM-dd ~"`格式的字符串解析为Date实例.
#### 使用方法:
- **格式化:** `Date-->String` 
- **解析:** `String-->Date`
	```
	Date date1 = new Date();
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm");
	sdf.format(date1); //返回一个yyyy-MM-dd HH:mm的字符串.
	sdf.parse("2024-5-2 15:22:10"); //将"2024-5-2 15:22:10"解析为对应的Date实例.
	```
### 2. `Calendar`:
#### 介绍:
- 为抽象类, 必须通过静态方法`getInstance()`获取实例
- 日期可变, 若使用方法修改时间, 则实例的时间会改变, 而不是创建新对象.
#### 常用方法:
- `field`可为`YEAR`, `MONTH`, `DAY_OF_MONTH`等...

| `getInstance()`              | 获取Calendar实例.                   |
| ---------------------------- | ------------------------------- |
| `get(int field)`             | 返回field的值.                      |
| `add(int field, int amount)` | 对`field`的值累加上`amount`.          |
| `set(int field, int amount)` | 将`field`的值设置为`amount`.          |
| `getTime()`                  | 将Calendar实例转换成Date实例.           |
| `setTime(Date date)`         | 将Calendar实例对应的时间转换成date实例对应的时间. |

### 3. `LocalDate`, `LocalDateTime`, `LocalTime`:
#### 介绍:
- 区别于`Calendar`, `date`, 具有不可变性!! 即若对其实例进行修改, 会创建新的对象, 而不是在原有的实例上进行修改, 类似于String.
#### 实例化方法:
- `now()`: 获取当前系统时间的`Local~实例.
- `of(year, month, day)`: 获取指定时间的`Local~`实例.
#### 常用方法:

| `getMonth()/getDayOfMonth()/...`             | 获取当前月份/当前月份的第几天/...          |
| -------------------------------------------- | ---------------------------- |
| `withDayOfMonth(int i)/withMonth(int i)/...` | 将当前天数/月份修改为第`i`天/月.          |
| `plusDays(int i)/plusMonths(int i)/...`      | 将当前天数/当前月份/...累加上第`i`天/月/... |
### 4. `Instant`:
#### 实例化方法:
- `now()`: 返回默认时区的年月日时分秒的`Instant`实例.
- `ofEpochMilli(long Times)`: 返回时间为对应毫秒数Times的`Instant`实例.
#### 常用方法:

| `toEpochMilli()`              | 获取Instant实例对应的毫秒数. |
| ----------------------------- | ------------------ |
| `atOffset(ZoneOffset offset)` | 用于调整时区带来的偏移量.      |

### 5. `DateTimeFormatter`:
#### 实例化方法:
- `ofPattern("yyyy-MM-dd ~")`: 自定义日期格式, 将`Local`实例的日期格式调整为`"yyyy-MM-dd ~"`形式.
- `ISO_LOCAL_DATE_TIME`: 预定义日期格式, 转换为默认格式.
#### 常用方法:

| `foramt(Local~ l1)`       | 将l1对应的日期格式化为字符串.                                                                   |
| ------------------------- | ---------------------------------------------------------------------------------- |
| `parse(String s1)`        | 用于将字符串转换为`TemporalAccessor`类实例, 通过`Local~.from(TemporalAccessor t1)`可转换成`Local`实例. |
| `ofpattern("yyyy-MM-dd")` | 将格式设置为`yyyy-MM-dd`, 注意: 若为1月份等个位数, 应写成`2022-01-02`, 保证为两位数.                        |

# Day40：（05月01日）
## 时长及内容：
- 补前一周的学习笔记!!!

# Day41：（05月02日）
## 时长及内容：
- 尚硅谷视频149~156.
## 学习复盘：

### 1. Java比较器:
#### 方式一: 实现Comparable接口(自然排序):
##### 使用方法:
- 定义类A实现`Comparable`接口;
- 实现`CompareTo(Object obj)`方法, 内部指明比较逻辑;
- 调用静态方法`Arrays.sort(Object[] arr)`进行排序.
- (注意: `sort`的排序逻辑取决于`arr`内部的`CompareTo`方法.)

#### 方式二: 实现Comparator接口(定制排序):
##### 使用方法:
- 定义类A实现`Comparator`接口;
- 实现接口中的`compare(Object obj1, Object obj2)`方法;
- 调用静态方法`Arrays.sort(arr, new A())`进行排序.

#### 二者区别:
- 自然排序是待比较对象内部的方法, 是唯一的; 定制排序是外部的, 可定义多个不同的实现类A, 可有不同的比较逻辑.

### 2. 集合:
#### java.util.Collection: 存放一个一个的数据
- **子接口:** `List`, 存放有序的, 可重复的数据;
	- **实现类:** `ArrayList`, `LinkedList`, `Vector`.
- **子接口:** `Set`, 存放无序的, 不可重复的数据;
	- **实现类:** `HashSet`, `LinkedHashSet`, `TreeSet`.
#### java.util.Map: 存放一堆一堆的数据(键值对)
- **实现类:** `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`, `Properties`.

#### 常用方法:

| `add(Object obj, int index)`    | 添加`obj`到集合的`index`位置上.                     |
| ------------------------------- | ------------------------------------------ |
| `addAll(Collection c1)`         | 将`c1`中所有元素添加到集合中.                          |
| `size()`                        | 获取集合的大小.                                   |
| `isEmpty()`                     | 判断集合是否为空.                                  |
| `contains(Object obj)`          | 判断`obj`是否在集合中.                             |
| `c1.containsAll(Collection c2)` | 判断`c2`的元素是否都在集合`c1`中. (即`c2`是否是`c1`的子集)    |
| `equals(Object obj)`            | 判断集合是否与`obj`相等. (可传入`c1`判断两个集合内的元素是否完全一致.) |
| `clear()`                       | 清空集合内部元素.                                  |
| `remove(Object obj)`            | 清除集合内的元素`obj`.                             |
| `c1.removeAll(Collection c2)`   | 清除集合`c1`内部与`c2`有交集的元素.                     |
| `c1.retainAll(Collection c2)`   | 返回`c1`与`c2`的交集.                            |
| `Object[] c1.toArray()`         | 将集合`c1`作为数组返回.                             |
| `Arrays.asList(Object[] arr)`   | 将`arr`转换成集合.                               |
| `iterator()`                    | 迭代器.                                       |
#### 迭代器:
##### 作用:
- 用于遍历集合内元素.(一般只用于输出, 不用于修改等操作.)
##### 常用方法:
- `hasNext()`: 判断指针所指的下一个元素是否为空.
- `next()`: ①指针下移一位; ②输出指针对应元素.
##### 使用方法:
```
iterator itr1 =  coll.iterator(); //获取集合对象的迭代器实例.
while(itr1.hasNext()){ //判断下一个元素是否为空.
	System.out.println(itr1.next()); //移动指针到下一位, 并输出指针对应元素.
}
```

### 3. List接口:

# Day42：（05月03日）
## 时长及内容：
- 尚硅谷视频156~160;
## 学习复盘：
### 1. List接口:(Collection的子接口)
#### ArrayList:
- 线程不安全, 效率高;
#### LinkedList:
- 底层使用双向链表存储;

### 2. Set:(Collection的子接口):
- 存放无序的, 不可重复的数据.
#### HashSet:(主要实现类)
- 底层使用`HashMap`, 即数组+单向链表+红黑树结构.
#### 使用场景:
- 相对于`List`, `Map`, `Set`使用较少.
- 若需要处理重复数据, 可用`Set`进行过滤.
#### 无序性和不可重复性的理解:
- **无序性:** "集合中的元素不保证按照任何特定顺序存储或迭代." 使用对象的哈希码来决定对象存储的位置.
- **不可重复性:** 哈希值相同, 且`equals()`相同. 即使用待存储对象的`equals()`和`hashCode()`方法进行判定.
#### TreeSet:(实现类)
- 底层使用红黑树结构.
- 区别于`HashSet`, 可以按照添加元素的指定属性的大小顺序进行遍历.
- 添加到`TreeSet`中的元素必须同类型, 否则会报`ClassCastException`.
##### 使用:
- 添加元素时会调用待添加对象的`compareTo()`方法进行自然排序. 并且不会调用`equals()`和`hashCode()`方法.
- 若想进行定制排序, 则可通过传入`comparator`接口的实现类的实例.
```
TreeSet t1 = new TreeSet(comparator1);
```
- `TreeSet`作为`Set`的实现类, 同样不能存放相同的元素. 判定相同的方法是调用排序方法. 若返回值为0, 则只会选择先添加的进行存放.
### 3. Map:(与Collection同级, 用于存放一对一对的数据.)
#### 实现类:
##### `HashMap`:
- 为`Map`的主要实现类;
- 线程不安全, 但是效率较高;
- 健壮性强, 可以添加`null`的`key`和`values`.
- 底层使用数据+单向链表+红黑树的数据结构.
- 子类`LinkedHashMap`: 添加了双向链表, 用于记录元素添加的先后顺序, 以便按添加顺序输出.
##### `Hashtable`:
- 为`Map`的古老实现类, 自`jdk1.0`就出现, 现已过时.
- 与`HashMap`对比, 是线程安全的, 但是效率也较低!
- 健壮性差, 无法存储值为`null`的`key`或`values`.
##### `TreeMap`:
- 底层使用红黑树存储;
- 可按照添加元素的指定属性大小顺序进行遍历;
- 子类:`Properties:` `key`和`values`都是`String`类型, 用来处理属性文件.

#### 元素特点:
- 键值对可理解为映射, 故不同的`key`可以对应相同的`values`, 而不同的`values`不可以对应相同的`key`. 
- `key`用`Set`存放, 不允许重复, 且无序; --> `key`元素所属类需重写`hashCode()`和`equals()`方法.
- `values`用`Collection`存放, 可重复, 但仍无序. --> `values`元素所在的类需重写`equals()`方法
- `key-values`用`Entry`进行存储, `entry`之间不可重复, 且无序. 所有的`entry`之间构成`Set`.
# Day43：（05月04日）
## 时长及内容：
- 尚硅谷视频160~163;
## 学习复盘：

### 1. `Map`
- 与`Collection`并列的类, 主要用来存储一对一对的数据, 即键值对!
#### 常用方法:

| `put(Object key, Object value)` | 1. 将指定的键值对`key-value`传入`map`中.<br>2. 若相应`key`值已存在, 则默认更新原有的键值对. |
| ------------------------------- | --------------------------------------------------------------- |
| `putAll(Map m)`                 | 1. 将指定的`Map`对象`m`传入`Map`中.<br>2. 将原有的`Map`中的键值对替换成`m`           |
| `remove(Object key)`            | 将`key`值为key的键值对删除.                                              |
| `clear()`                       | 清空`map`.                                                        |
| `get(Object key)`               | 返回`key`对应的`value`值.                                             |
| `containsKey(Object key)`       | 判断`key`是否存在.                                                    |
| `containsValue(Object value)`   | 判断`value`是否存在.                                                  |
##### 遍历:
1. 遍历`key`集:(`Set`类型)
```
Set set = map.keySet();
之后可利用迭代器或增强for循环遍历.
```
2. 遍历`value`集:(`Collection`类型)
```
Collection valueColl = map.values();
之后可利用迭代器或增强for循环实现遍历.
还可利用keySet()和get(key)实现对values的遍历.
```
3. 遍历`key-value`集(`entry`类型): 
```
Set entrySet = map.entrySet();
利用迭代器实现遍历.
也可利用增强for循环实现遍历:
for (Object entry : entrySet)
	System.out.println(entry);
或：(利用泛型参数代替Object)
Set<Map.Entry<Integer, String >> entrySet = map.entrySet();  
for (Map.Entry<Integer, String > entry : entrySet)  
    System.out.println(entry);
```
#### TreeMap的使用:
- TreeMap, `key`的类型必须相同, 因为对于TreeMap, 会比较传入的键值对大小(利用`key`中的`compareTo()`方法,或者定制排序的`comparator`中的`compare()`方法) 进行排序.
### `Collections`工具类:
- 是`private`构造器, 无法被实例化. 故内部都为静态方法, 通过类直接调用.
- 主要用于操作`Collection`类的对象. 并且某些方法只能操作能基于索引随机访问的`List`, 而不能操作`Queue`和`Set`.

| `reverse(list)`                     | 将`list`翻转.                                                                                                              |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `shuffle(list)`                     | 将`list`随机排列.                                                                                                            |
| `swap(list, i1, i2)`                | 将`list`中元素`i1`和`i2`交换.                                                                                                  |
| `max/min(Collection, (comparator))` | 根据自然排序(或定制排序)返回`Collection`中的最大值/最小值.                                                                                   |
| `binarySearch(list)`                | 二分查找( 只适用于有序`list`)                                                                                                     |
| `frequency(list, obj)`              | 返回`obj`在`list`出现的频次.                                                                                                    |
| `copy(List dest, List src)`         | 将`src`复制到`dest`中<br>(这里需要保证`dest`已经被初始化并且有足够的容量.) (浅复制)↓通过以下代码实现<br>`List list = Arrays.asList(new Object[src.size()])` |
| `unmodifiableList(List list)`       | 返回只读的`list`                                                                                                             |
### `Arrays.asList`使用辨析:
```
List l0 = Arrays.asList(list1.size());  
List l1 = Arrays.asList(new Object[list1.size()]);  
List l2 = new ArrayList(Arrays.asList(new Object[list1.size()]));
```
`Arrays.asList(T... t)`, 接收参数类型为泛型T, 因此此时:
1. 若传入`list1.size()`, 则返回的是包含单一元素`3`的`list`.
2. 若传入的为`new Object[list1.size()]`, 则返回的是`size`为`list1.size()`的`list`, 其中每个元素都为`null`!
3. `new ArrayList(Arrays.asList(new Object[list1.size()]));`, 得到的`list`的大小与元素都与"2"相同, 但是与原数组已无联系, 即改变数组元素的值, 不会对`list3`造成影响!

# Day44：（05月05日）
## 时长及内容：
- 尚硅谷视频164~168;
## 学习复盘：
### 1. 泛型:
#### 定义:
- 允许在定义接口, 类时通过标识符`<>`表示类中的某个属性, 或某个方法的返回值或某个方法的形参类型.
#### 作用:
- 保证类型安全, 避免强转导致的`ClassCastException`.
#### 注意事项:
- 若父类带泛型`<>`, 子类可以选择不带泛型. 此时默认泛型类为`Object`.
	- 继承泛型类为`Object`, 会导致失去泛型优势: 类型安全.
- 父类带泛型，子类可以不带泛型；父类不带泛型，子类也可以带泛型。
- 泛型的使用说明: 
```
new T[]会报错,因为泛型T的类型不确定.
T[] eles = (T[]) new Object[capacity];
```
#### 自定义泛型接口/类:
```
class A<T>{}
interface B<T>{}
```
##### 注意:
- 异常类中不能使用泛型;
- 静态方法中不可以使用类或接口的泛型! 会报错:`'类.this' cannot be referenced from a static context`.
#### 自定义泛型方法:
```
权限修饰符 <T> 返回值类型 方法名(形参列表){}
权限修饰符 <T,U> 返回值类型 方法名(U u){}
```
- 泛型方法可以声明为静态方法, 但此时调用时必须带上类名(即使在同一个`module`/`class`)
#### 泛型在继承上的使用:
- `class A<superT>{} and class A<T>{}`: 二者无任何关系. 泛型不能继承或实现.
- `class superA<T>{} and class A<T>{}`: 子父类关系.
#### 通配符`?`:
- `List<?>`可以表示任何类型的`List`, 可以当成`List<Object>`等的父类!
##### 通配符的读写操作:
- 只能进行读操作, 而不能进行写操作(`null`除外, 因其是所有引用类型的默认值).
- 可以进行读操作, 因为不管 `list`的真实类型是什么, 它包含的都是`Object`.
##### 有上界限定的通配符:
- `<? extends Type>`: 此时可以接受`Type`或者`Type`的任何子类泛型的列表.
				  (即满足`?≤Type`)
- **主要适用于读操作:** 此时允许读取内部对象, 因为可以保证为`Type`或`Type`的子类.
- **不适用于写操作:** 因为若进行写操作, 则由于无下界, 则总可能找到其子类, 即不符合要求(会导致向下转型, 类型不安全).
##### 有下界限定的通配符:
- `<? super Type>`: 此时可以接受`Type`及`Type`的任何父类列表.
- **主要适用于写操作:** 此时允许添加`Type`及`Type`的子类对象, 因为`list`中均为`Type`及其父类, 故添加的`Type`和`Type`的子类可以自动向上转型, 是类型安全的!
	  有下界, 若写入`Type`及其父类, 则会由于`?`是飘忽不定的, 可能出现向下强转, 类型不安全, 故不可能.
- **可适用于读操作:** 因为添加的是`Type`的父类, 则由于多态性, 均为`Object`的子类对象.
**(PS: 向上转型与向下转型:** 向上往往是自动进行(即多态性), 向下需要强制进行.)

# Day45：（05月06日）
## 时长及内容：
- 尚硅谷视频168~177; (171~174跳过.)
## 学习复盘：
### 1. `File`类:
#### 构造器:
```
public File(String filename)
public File(String parent, String child)
public File(File parent, String child)
```
- 根据传入到构造器的实参, 确定`File`的文件/文件夹.
#### 常用方法:

| `getName()`           | 获取名称                                                                   |
| --------------------- | ---------------------------------------------------------------------- |
| `getPath()`           | 获取路径                                                                   |
| `getAbsolutePath()`   | 获取绝对路径(`String`型)                                                      |
| `getAbsoluteFile()`   | 获取绝对路径(`File`类)                                                        |
| `getParent()`         | 获取上层的文件目录. 若`file`为相对路径, 则返回`null`.                                    |
| `length()`            | 获取文件长度(字节数) `int`型                                                     |
| `lastModified()`      | 获取最后一次的修改时间(毫秒数)`long`型                                                |
| `list()`              | 返回路径下的所有子文件或者子文件夹(`String`型)                                           |
| `listFile()`          | 获取路径下的所有子文件或者子文件夹(`File`类)                                             |
| `renameTo(File dest)` | 将`srcFile`重命名为`dest`.<br>(要求`srcFile`必须存在, `dest`不存在)-->否则返回值为`false`. |
| `exists()`            | 判断文件或者文件夹是否存在.                                                         |
| `isFile()`            | 判断是否为文件.                                                               |
| `isDirectory()`       | 判断是否为文件夹.                                                              |
| `createNewFile()`     | 创建文件.                                                                  |
| `mkdir()`             | 创建文件夹.(要求上层存在)                                                         |
| `mkdirs()`            | 创建文件夹(上层可以不存在)                                                         |
| `delete()`            | 删除文件/文件夹(要求文件夹内部为空.)                                                   |

### 2. IO流:
#### 流的分类:
- 输入流, 输出流;
- 字符流, 字节流;
- 节点流, 处理流;
#### `FileReader/FileWriter`的使用:
##### 构造器：

| `public FileWriter(File file, boolean)` | 向`file`中写入.<br>若为`true`, 则在原有的基础上追加.<br>默认为`false`, 即覆盖原文件. |
| --------------------------------------- | ----------------------------------------------------------- |
| `public FileReader(File file)`          | 读取`file`中的内容.                                               |
##### 常用方法:


| `read(char[] cbuf, off, len)`  | `cbuf`存储读取的字符;<br>`off`代表从`cbuf`的索引`off`开始存储(即`off`以前的索引皆为ASCII的0);<br>`len`代表每次读取的长度. (`off+len<=cbuf.length()`) |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------- |
| `write(char[] cbuf, off, len)` | 同上.                                                                                                               |


1. 创建`File`类对象, 即写入/读取的文件;
2. 创建输入/输出流对象;
3. 读取数据/写入数据, 注意进行异常处理;
4. 流的关闭, 避免资源泄露.
```
File file = new File("xxx");
FileReader fr = null;
try{
	fr = new FileReader(file);
	char[] cbuffer = new char[5]; //创建char[]存储读取的字符, 每次最多存5个!
	int len;
	while((len = fr.read(cbuffer)) != -1){
		for (int i = 0; i < len; i++)
			System.out.print(cbuffer[i]);
	}
} catch(IOException e) {
	e.printStackTrace();
} finally{
	try{
		if (fr != null)
			fr.close();
	} catch (IOException e){
		e.printStackTrace();
	 }
}
```

```
File file = new File("xxx");
FileWriter fw = null;
try{
	fw = new FileWriter(file);
	fw.write("123");
} catch (IOException e){
	e.printStackTrace();
} finally {
	try{
		if (fw != null)
			fw.close();
	} catch (IOException e){
	
		e.printStackTrace();
	}
}
```
# Day46：（05月07日）
## 时长及内容：
- 尚硅谷视频177-179;
## 学习复盘：
### 1. `InputStream`和`OutputStream`:
- 字符流: 只能用于操作文本文件   
- 字节流: 可以用于非文本文件的读取和复制操作; 也可用于文本文件的复制操作. 但若读取文本文件, 则有可能出现乱码! (即中文字符占多个字节, 有可能被"分割", 即只存储了其2个字节,或1个字节等, 导致出现乱码.)
#### 使用方法:
1. 创建输入或写出的File类对象;  
2. 创建输入或输出流;  
3. 具体的读入或写出的过程.  
4. 关闭资源.
```  
File file = new File("...");  
FileInputStream fis = new FileInputStream(file);  

fis.read(byte[] cbuffer, off, len);  
fos.write(String str) / fos.write(byte[] buffer, 0, len);  
```
使用方法与字符流相同! 区别在于一个是处理字符, 而现在是处理字节.--> 故需要用`byte[]`数组进行存储.

# Day47：（05月08日）
## 时长及内容：
- 尚硅谷视频180-185；
## 学习复盘：
### IO流:
#### 缓冲流:
##### 分类:
- `BufferedInputStream`, `BuifferedOutputStream`: 处理字节;
- `BufferedReader`, `BufferedWriter`: 处理字符;
##### 作用:
- 创建内存字符/字节缓冲流, 将字符/字节先存储到提供的内存缓冲区中, 减少了程序直接与内存或网络进行交互的次数, 提高文件读写的效率, 比直接进行I/O操作快得多.
- 当①内存缓冲区已被写满; ②调用`flush()`方法; ③调用`close()`方法时, 会将内存缓冲区的数据输出.
##### 常用方法:

| `BufferedReader`           |                         |
| -------------------------- | ----------------------- |
| `read(char[] cbuffer)`     | 读取数据源中的字符到`cbuffer`数组中. |
| `readLine()`               | 读取数据源中的单行文字.            |
| **`BufferedWriter`**       |                         |
| `write(char[] cbuffer)`    | 将`cbuffer`中的字符写入到数据源中   |
| `write(String str)`        | 将`str`写入到内存缓冲区中         |
| **`BufferedInputStream`**  |                         |
| `read(byte[] buffer)`      | 读取数据源中的数据到`buffer`数组.   |
| **`BufferedOutputStream`** |                         |
| `write(byte[] buffer)`     | 将`buffer`中的数据写入到数据源中.   |
##### 使用方法:
- 缓冲流也属于包装类, 用于在不修改原有对象结构的情况下动态地给一个对象添加额外的功能. 通过包装底层流来提供额外的缓冲功能.
  具体来说, 缓冲流需要结合`FileInputStream`, `FileOutputStream`, `FileReader`和`FileWriter`来使用, 即将这四个底层流作为缓冲流的实参传入.
##### `flush()`:
- 主动刷新. 调用时会主动刷新, 将内存中的数据写入到磁盘文件中.
- 在调用输出流的`close()`时, 会在内部先调用`flush()`方法将内存中的资源写入到磁盘文件中.
#### 转换流:
##### 作用:
- 转换流是字节流和字符流的桥梁, 用于实现字节流和字符流的转换. 
- 由于`FileReader`和`FileWriter`使用的是默认的UTF-8字符集, 所以在读取和写入GBK等使用其它字符集进行编码的文件时, 会出现乱码. 故转换流可以指定编码集的特性此时就很有必要!!
	  实际上, `FileReader`和`FileWriter`是转换流的子类, 也是其便利类, 默认使用UTF-8编码. 便利的点在于其可以直接传入`File类`作为输入, 而转换流需要传入`InputStream/OutStream`
##### 分类:
- `InputStreamReader`: 用于将字节流转换为字符流, 即实现解码的过程. (转换成可读类型)
- `OutputStreamWriter`: 用于将字符流转换为字节流, 实现编码的过程. (转换成二进制字节)
##### 使用方法:
```
File file = new File("xxx");
InputStream is = new FileInputStream(file);
InputStreamRead isr = new InputStreamReader(is);
int len;
char[] cbuf = new char[1024];
while ((len = isr.read(cbuf)) != -1){
	String str = new String(cbuf, 0, len);
	System.out.print(str);
}
isr.close;
```

---
### 网络编程:
#### 软件架构:
- C/S架构: 客户端/服务器架构
- B/S架构: 浏览器/服务器架构.
#### 网络基础:
##### 网络编程的目的:
- 直接或间接地通过网络协议与其他计算机进行数据交换.
##### 网络编程的三个问题:
- 如果定位网络上一个或多个主机;
- 如果定位主机上的特定应用;
- 如何进行可靠, 高效的数据传输.
##### 网络编程三要素:
1. **IP地址** 
	- IP地址用于准确定位主机.
	- 可分为IPv4地址和IPv6地址, 前者使用4字节编码, 后者使用6字节编码.
	- 可分为私网地址和公网地址, 前者用于局域网, 后者用于万维网
	- 域名: 可理解为可读性更强的IP地址, 与IP地址是一一对应的关系. 域名可通过DNS转换为IP地址.
2. **端口号**
	- 唯一标识主机中的进程, 取值范围为0-65535,即2^16.
3. **通信协议:**
	- OSI参考模型
	- TCP/IP协议: 应用层->传输层->网络层->物理+数据链路层
#### INetAddress:
##### 介绍:
- 用于在网络通信中表示IP地址的类. 可通过创建实例来表示一个具体的IP地址.
- 私有化构造器, 无法通过构造器创建实例!
##### 实例化方法:
- `getByName(String host)`: 获取IP地址的实例, 形参`host`为域名或IP地址.
- `getByAddress(String host, byte[] arr)`
##### 常用方法:
- `getLocalHost()`: 获取本机的IP地址实例;
- `getHostName()`: 获取IP地址的域名;
- `getHostAddress()`: 获取实例的IP地址的字符串形式.
#### 三次握手:
- 第一次: 客户端向服务器发起连接请求;
- 第二次: 服务器发送针对客户端的TCP连接请求确认;
- 第三次: 客户端发送确认的确认;
#### 四次挥手:
- 第一次: 客户端先向服务器发送释放连接的请求, 此时客户端处于半关闭状态, 只能接收数据, 而不进行数据的发送;
- 第二次: 服务器接收到释放连接的请求, 向客户端发送最后的数据, 并告知上层不再接收数据;
- 第三次: 服务器发送最后的数据时, 还会发送释放连接的报文. 客户端接收后就可以正式释放连接.
- 第四次: 客户端接收到最后的报文后, 需要回复一个彻底断开连接的报文.
#### Socket类:
# Day48：（05月09日）
## 时长及内容：
- 尚硅谷视频185-190；
## 学习复盘：
### IO流：
**关于`InputStream`和`OutputStream`的理解:**
`InputStream`用于从数据源中读取数据到Java程序中; `OutputStream`用于将Java程序中的数据写入到数据源中, 如文件, 图片等. 此处注意Input是从外部输入到Java程序中, 而Output就是从Java程序中输出到数据源中.

### 网络编程:
#### TCP协议与UDP协议:
- **从可靠性的角度:** TCP协议是可靠传输的, 需要在客户端和服务器建立连接, 具体实现是通过"三次握手"建立连接, 通过"四次挥手"释放连接; UDP协议是不可靠传输, 无需建立连接.
- **从传输数据的基本单位的角度:** TCP协议传输数据的基本单位是字节流, 用于大数据传输; 而UDP协议传输数据的基本单位是数据包, 单个数据包大小在64K以内.
- **从传输效率的角度:** TCP协议在传输结束后需要释放连接, 效率低; 而UDP协议无需释放连接, 开销小, 效率高.

### 反射:
#### 出现背景:
- 反射出现的背景为: Java中所有对象都有类型: `编译时类型(静态类型)`和`运行时类型(动态类型)`.
	- 这也是多态性的保证. `Animal a = new Dog();` 此时编译时认为`a`是Animal类, 而运行时认为`a`为Dog类. JVM根据对象的运行时类型来判断应该调用的属性和方法 --> 动态绑定.
#### 反射概述:
- 反射是Java作为`动态语言`的关键. 可以使程序在运行期间借助`Reflection API`获取类的内部信息, 并能直接操作对象的构造器, 属性和方法!
#### 使用方法:
- 利用`getDeclaredXx()`来获取公有化/私有化构造器/属性/方法, 利用`setAccessible(true)`设置权限, 使私有化构造器能被访问, 最后利用`set(args)`来调用构造器和属性, 利用`invoke()`来调用方法.
```
//1. 获取Class实例.
Class<Person> clazz = Person.class

//构造器:(获取私有化构造器并创建对象)
Constructor cons = clazz.getDeclaredConstructor(形参列表);
cons.setAccessible(true);
Person p1 = (Person) cons.newInstance(形参列表);

//属性:(私有化属性)
Field ageField = clazz.getDeclaredField(形参列表);
ageField.setAccessible(true);
ageField.set(p1, 20);

//方法:(私有化方法)
Method showMethod = clazz.getDeclaredMethod(形参列表);
showMethod.setAccessible(true);
showMethod.invoke(形参列表);
```
#### 使用场景:
- 平时开发时, 反射机制较少涉及. 但是若需要设计框架, 阅读框架源码, 此时就需要使用反射机制, 提高程序的灵活性和扩展性, 降低耦合性, 提高自适应能力.

### Class类的理解:

#### 获取Class实例的4种方法:
```
Class clazz = Person.class;    //调用运行时类的静态属性class.
Class clazz = p1.getClass();   //调用运行时类的对象的getClass()方法.
Class clazz = Class.forName(全类名);   //调用静态方法forName(String className).
Class clazz = ClassLoader.getSystemClassLoader.loadClass(全类名); 调用ClassLoader.
```

#### 使用类加载器获取流:
```
Properties pros = new Properties();

InputStream is = new FileInputStream(String file); //file需在src文件夹中.

pros.load(is);

String name = pros.getProperties("name");

```

# Day49：（05月10日）
## 时长及内容：
尚硅谷视频190~193
## 学习复盘：
反射的学习。
# Day50：（05月11日）
## 时长及内容：
- 尚硅谷视频193~197
## 学习复盘：
Lambda表达式、方法引用、StreamAPI。
# Day51：（05月12日）
## 时长及内容：
尚硅谷视频197~200
## 学习复盘：
JDK8之后的新特性！
# Day52：（05月13日）
## 时长及内容：
凸优化复习，没学Java。
# Day53：（05月14日）
## 时长及内容：
1. 个人网站建站尝试。
## 学习复盘：
### 利用Github Pages和Hugo搭建个人网站：
#### 方法一：
1. 首先下载好Hugo：①官网下载；②安装，并将`xx//Hugo//bin`添加到`Path`中；③利用`Hugo version`判断是否安装成功.
2. 选择要保存本地仓库的磁盘位置, 输入`Hugo new site "xxx"`创建网站(如我的是`Hugo new site Myblog`), `Myblog`内部会有如下几个文件夹:![[Pasted image 20240515085427.png]]
3. 从HugoThemes选择自己想要的模板, 并`clone`到`themes`文件夹中: 
   `git clone ~ `. 
4. 选择好主题后, 可以通过`hugo new posts/xx/mm.md`, 这里在posts文件里新建了xx文件夹, 并在xx下继续新建了`mm.md`的markdown格式文件. posts是网站存储博客的地方, 并且会在建立静态网站是将内部的md文件解析成网页形式.
5. 新建好第一篇博文后, 当然想测试一下! `hugo server -D`来实现在本地部署服务器, 此时可通过`localhost:1313`或`127.0.0.1`来访问网站.
6. 测试成功后, 再通过`hugo`生成所需的静态网页.
7. 在本地测试成功后, 即需要部署到服务器上, 这里有两种方法:①利用`github pages`, 是免费的, 缺点是国内访问慢; ②通过云服务器, 如阿里云等, 需要购买域名, 备案等..., 并且需要付费, 推荐new blogger选择第一个, 之后若有需要, 再部署到云服务器上.
8. 在Github上新建`Username.github.io`仓库, 以此作为部署网页的托管服务器.
9. 在

# Day54：（05月15日）
## 时长及内容：
建站, 凸优化复习.
# Day55：（05月16日）
## 时长及内容：
建站, 凸优化复习.

# Day56：（05月17日）
## 时长及内容：
没怎么学习。成功搭建个人网站！
# Day57：（05月18日）
## 时长及内容：
MySQL初级1-25;

# Day58-65：（05月19日-05月25日）
## 时长及内容：
- 结束MySQL学习.

# Day66：（05月26日）
## 时长及内容：
- JDBC学习并跳过.
# Day67-74：（05月27日-06月3日）
## 时长及内容：
- 尚硅谷JavaWeb:01-68
# Day75-76：（06月04日-06月05日）
## 时长及内容：
- 出差，未学习。
# Day77~81：（06月06日-06月10日）
## 时长及内容：
- 尚硅谷JavaWeb:68~94.

# Day82~84：（06月11日~6月13日）
## 时长及内容：
- 尚硅谷JavaWeb94~129(跳过了日程管理小项目)
# Day85~87：（06月14日~06月16日）
## 时长及内容：
- 尚硅谷JavaWeb129~155
# Day88~Day94：（06月17日~06月23日）
## 时长及内容：
无！复习考试+摸鱼！
# Day95~Day101：（06月24日~06月30日）
## 时长及内容：
- 尚硅谷JavaWeb结束；
- Git教程结束；
- Maven基础结束。
# Day102~112：（07月1日~07月11日）
## 时长及内容：
- Spring6学习，结束（剩下与Mybatis未看）。
# Day113~Day115：（07月12日~07月14日）
## 时长及内容：
- MyBatis1~84;
# Day116：（07月15日）
## 时长及内容：
- MyBatis84~125；
# Day117：（07月16日）
## 时长及内容：
- MyBatis结束；
- SpringMVC1~26
# Day118：（07月17日）
## 时长及内容：
- SpringMVC26~46.

# Day119：（07月18日）
## 时长及内容：
- SpringMVC46~78+86~106；

# Day120~121：（07月19日~07月20日）
## 时长及内容：
- SpringMVC完成；

# Day122~124：（07月21日~07月23日）
## 时长及内容：
- 周日（21日）：Springboot3学习：1~10；大部分时间在休息。
- 周一（22日）：看电影去了；
- 周二（23日）：做实验，没学习。

# Day125~130：（07月24日~07月29日）
## 时长及内容：
- 结束Springboot3学习(剩余与Redis的结合等没看)
- 开始Redis7学习:1~18

# Day131:（07月31日）
## 时长及内容：
- Redis18~27.
- Nginx的了解及学习.
# Day132~Day139:（08月01日~08月08日）
## 时长及内容：
- Redis27~108.(结束Redis哨兵)

---

