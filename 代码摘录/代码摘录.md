# 项目中某个方法异步执行
## 作用:
- 方法异步执行,避免任务执行时间过长,占用线程过久.
1. **定义线程池**,用于异步生成兑换码.
```Java
@Slf4j
// Config注解,代表这是个配置类!
@Configuration
public class PromotionConfig {
	// 注意@Bean注解,交由Spring容器管理.
    @Bean
    public Executor generateExchangeCodeExecutor(){
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 1.核心线程池大小
        executor.setCorePoolSize(2);
        // 2.最大线程池大小
        executor.setMaxPoolSize(5);
        // 3.队列大小
        executor.setQueueCapacity(200);
        // 4.线程名称
        executor.setThreadNamePrefix("exchange-code-handler-");
        // 5.拒绝策略
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```
2. **启动类上**添加`@EnableAsync`注解,开启异步功能;
3. 需要**异步执行**的方法上加上`@Async`注解.


# Day10-领取优惠券
## 1. 需求分析和接口设计
### 1.1 原型分析
根据页面不同,需要分别显示"**优惠券列表**"和"**我的优惠券**",并且点击"立即兑换"后可以输入兑换码**兑换优惠券**,或者对"优惠券列表"中的优惠券点击"立即领取",可以**领取优惠券**

所以,一共四个接口:
1)查询优惠券列表; 2)查询我的优惠券; 3)兑换优惠券; 4)领取优惠券.

### 1.2 数据库设计
领取优惠券,需要记录哪个用户领取了哪张优惠券.并且,还需要记录用户领券后的使用情况.

**用户券表如下:**
![[Pasted image 20240927223434.png]]
## 2. 领取优惠券
### 2.1 查询发放中的优惠券
#### 2.1.1 接口分析
**页面原型:**![[Pasted image 20240927230708.png]]
1. 查看时,必定是能查看多个优惠券,所以这里应该是一个批量查询接口,返回值是list!
2. 返回的字段需要包括以下信息: (信息较多,使用VO封装.)
	- 1)优惠券名称; 2)折扣类型; 3)适用范围; 4)有效期 等等. 
![[Pasted image 20240927230547.png]]

#### 2.1.2 VO实体
![[Pasted image 20240927231135.png]]

#### 2.1.3 接口实现
- 难点在于查询"**是否可领取**"和"**是否已经领取**"这两个属性.
![[Pasted image 20240927232847.png]]
**优惠券还有剩余并且用户已领取未超过限领数量:**
	1) 用户券表中该优惠券id对应的数量>优惠券发放数量;
	2) 当前userId,优惠券id对应的id数量<限领数量.
**已经领取,尚未使用:**
	1) 对应某个券,userId,存在该数据,并且状态为"待使用".

**实际开发流程:**
1) 查询用户券表user_coupon,条件为:**当前用户**,**状态为发放中**的优惠券id;
	1) 因为**发放中**不在user_coupon表中,所以先查询优惠券表,获取状态为发放中的优惠券的id集合.
2) 统计当前用户,针对每一个优惠券的已领数量;
3) 统计当前用户,针对每一个券的已领且未使用数量.
```Java 
@Override
public List<CouponVO> queryIssuingCoupons() {
    // 1.查询发放中的优惠券列表: 1)状态为发放中;2)方式为手动领取
    List<Coupon> coupons = lambdaQuery()
            .eq(Coupon::getStatus, ISSUING)
            .eq(Coupon::getObtainWay, ObtainType.PUBLIC)
            .list();
    if (CollUtils.isEmpty(coupons)) {
        return CollUtils.emptyList();
    }
    // 2.统计当前用户已经领取的优惠券的信息
    List<Long> couponIds = coupons.stream().map(Coupon::getId).collect(Collectors.toList());
    // 2.1.查询当前用户已经领取的优惠券的数据
    List<UserCoupon> userCoupons = userCouponService.lambdaQuery()
            .eq(UserCoupon::getUserId, UserContext.getUser())
            .in(UserCoupon::getCouponId, couponIds)
            .list();
    // 2.2.统计当前用户对优惠券的已经领取数量
    Map<Long, Long> issuedMap = userCoupons.stream()
            .collect(Collectors.groupingBy(UserCoupon::getCouponId, Collectors.counting()));
    // 2.3.统计当前用户对优惠券的已经领取并且未使用的数量
    Map<Long, Long> unusedMap = userCoupons.stream()
            .filter(uc -> uc.getStatus() == UserCouponStatus.UNUSED)
            .collect(Collectors.groupingBy(UserCoupon::getCouponId, Collectors.counting()));
    // 3.封装VO结果
    List<CouponVO> list = new ArrayList<>(coupons.size());
    for (Coupon c : coupons) {
        // 3.1.拷贝PO属性到VO
        CouponVO vo = BeanUtils.copyBean(c, CouponVO.class);
        list.add(vo);
        // 3.2.是否可以领取：已经被领取的数量 < 优惠券总数量 && 当前用户已经领取的数量 < 每人限领数量
        vo.setAvailable(
                c.getIssueNum() < c.getTotalNum()
                && issuedMap.getOrDefault(c.getId(), 0L) < c.getUserLimit()
        );
        // 3.3.是否可以使用：当前用户已经领取并且未使用的优惠券数量 > 0
        vo.setReceived(unusedMap.getOrDefault(c.getId(),  0L) > 0);
    }
    return list;
}
```